{"posts":[{"title":"Effective C++ 第一章 让自己习惯 C++","text":"第一章 让自己习惯 C++（Accustoming Youself to C++）条款1：视C++为一个语言联邦C++是个多重范型编程语言，同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式。 视C++为一个语言联邦，包括以下四个部分： C：面向过程的部分 Object-Oriented C++：面向对象的部分，包括封装、继承、多态以及虚函数（动态绑定）等。 Template C++：泛型编程部分 STL： 融合泛型编程和OOP编程思想的C++标准模板库，包括容器、迭代器、算法以及函数对象等。 请记住： C++高效编程守则视状况而变化，取决于使用的是这四个部分中的哪一部分。 条款2：尽量以const，enum，inline代替#define宁可以编译器代替预处理器。 #define即宏定义在预处理阶段进行处理，不进入记号表（symbol table）。 123int a = 5, b = 0;CALL_MAX(++a, b); //a被累加2次CALL_MAX(++a, b + 10); //a被累加1次 这是不可预料的行为，因此使用内联函数来代替宏定义函数。 请记住： 对于单纯常量，最好使用const对象或enum替换#defines。 对于形似函数的宏，最好改用inline函数替换#defines。 条款3：尽可能使用constconst关键字告诉编译器某值应该保持不变，即为只读的。 const成员函数两个成员函数如果只是常量性不同，可以被重载。 const成员函数代表this指针的类型为：const className &amp;。 使用const成员函数来处理const对象。 在const和non-cons成员函数中避免重复利用non-const版本调用const版本，再加上转型const_cast、static_cast,例如： 123456const char&amp; operator[](int pos) const;//const版本char&amp; operator[](int pos) { //non-const版本 return const_cast&lt;char&amp;&gt; //返回值转型，移除const (static_cast&lt;const className&amp;&gt;(*this)[pos]);//*this转型,增加const} 但反过来使用const版本调用non-const版本则是一种错误行为。 请记住： 将某些东西声明为const可以帮助编译器侦测除错误；const可以被施加在任何作用域内的对象、函数参数、函数返回类型、成员函数本身。 编译器强制实施bitwise constness，但是你编写程序时应该使用“概念上的常量性”。 当const和non-const成员函数有着实质等价的实现时，使用non-const版本来调用const版本可以避免代码重复。 条款4：确定对象使用前已被初始化永远在对象使用之前将其初始化。 对于内置类型，手动初始化。 对于非内置类型，使用构造函数进行初始化。 赋值和初始化有区别： 12345678910// 赋值，而非初始化ABEntry(const string&amp; name, const string&amp; address, int num) { _name = name; _address = address; _num = num; }// 初始化，发生在进入构造函数本体之前// 即成员初值列(member initialization list)ABEntry::ABEntry(const string&amp; name, const string&amp; address, int num) : _name(name), _address(address), _num(num) { } C++有着固定的初始化顺序：按照声明顺序进行初始化，且基类先于派生类初始化 static对象：其寿命从被构造出来直到程序结束为止。 local static object(局部静态对象)：函数内的static对象。 non-local static object(非局部静态对象)：非函数内的static对象，不同编译单元之间初始化次序不确定 因此，要解决non-local static object初始化次序问题，就要将non-local static object转换为local static object（使用单例模式，即封装一层函数） 123456789101112class Singleton{public: static Singleton&amp; getInstance() { static Singleton s; return s; }private: Singleton() {} Singleton(const Singleton&amp;); void operator=(const Singleton&amp;);}; 请记住: 为内置类型进行手工初始化，C++不保证初始化它们。 构造函数最好使用成员初值列，不要在构造函数中使用赋值操作，初值列中的成员变量的顺序应该和声明顺序一致。 为免除“跨编译单元之初始化次序”问题，使用返回local static对象引用的函数来代替non-local static对象。 reference[1] Effective C++ · Scott Meyers","link":"/2021/12/12/effective-cpp-1/"},{"title":"Effective C++ 第二章 构造&#x2F;析构&#x2F;赋值运算","text":"第一章 让自己习惯 C++（Accustoming Youself to C++）条款1：视C++为一个语言联邦C++是个多重范型编程语言，同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式。 视C++为一个语言联邦，包括以下四个部分： C：面向过程的部分 Object-Oriented C++：面向对象的部分，包括封装、继承、多态以及虚函数（动态绑定）等。 Template C++：泛型编程部分 STL： 融合泛型编程和OOP编程思想的C++标准模板库，包括容器、迭代器、算法以及函数对象等。 请记住： C++高效编程守则视状况而变化，取决于使用的是这四个部分中的哪一部分。 条款2：尽量以const，enum，inline代替#define宁可以编译器代替预处理器。 #define即宏定义在预处理阶段进行处理，不进入记号表（symbol table）。 123int a = 5, b = 0;CALL_MAX(++a, b); //a被累加2次CALL_MAX(++a, b + 10); //a被累加1次 这是不可预料的行为，因此使用内联函数来代替宏定义函数。 请记住： 对于单纯常量，最好使用const对象或enum替换#defines。 对于形似函数的宏，最好改用inline函数替换#defines。 条款3：尽可能使用constconst关键字告诉编译器某值应该保持不变，即为只读的。 const成员函数两个成员函数如果只是常量性不同，可以被重载。 const成员函数代表this指针的类型为：const className &amp;。 使用const成员函数来处理const对象。 在const和non-cons成员函数中避免重复利用non-const版本调用const版本，再加上转型const_cast、static_cast,例如： 123456const char&amp; operator[](int pos) const;//const版本char&amp; operator[](int pos) { //non-const版本 return const_cast&lt;char&amp;&gt; //返回值转型，移除const (static_cast&lt;const className&amp;&gt;(*this)[pos]);//*this转型,增加const} 但反过来使用const版本调用non-const版本则是一种错误行为。 请记住： 将某些东西声明为const可以帮助编译器侦测除错误；const可以被施加在任何作用域内的对象、函数参数、函数返回类型、成员函数本身。 编译器强制实施bitwise constness，但是你编写程序时应该使用“概念上的常量性”。 当const和non-const成员函数有着实质等价的实现时，使用non-const版本来调用const版本可以避免代码重复。 条款4：确定对象使用前已被初始化永远在对象使用之前将其初始化。 对于内置类型，手动初始化。 对于非内置类型，使用构造函数进行初始化。 赋值和初始化有区别： 12345678910// 赋值，而非初始化ABEntry(const string&amp; name, const string&amp; address, int num) { _name = name; _address = address; _num = num; }// 初始化，发生在进入构造函数本体之前// 即成员初值列(member initialization list)ABEntry::ABEntry(const string&amp; name, const string&amp; address, int num) : _name(name), _address(address), _num(num) { } C++有着固定的初始化顺序：按照声明顺序进行初始化，且基类先于派生类初始化 static对象：其寿命从被构造出来直到程序结束为止。 local static object(局部静态对象)：函数内的static对象。 non-local static object(非局部静态对象)：非函数内的static对象，不同编译单元之间初始化次序不确定 因此，要解决non-local static object初始化次序问题，就要将non-local static object转换为local static object（使用单例模式，即封装一层函数） 123456789101112class Singleton{public: static Singleton&amp; getInstance() { static Singleton s; return s; }private: Singleton() {} Singleton(const Singleton&amp;); void operator=(const Singleton&amp;);}; 请记住: 为内置类型进行手工初始化，C++不保证初始化它们。 构造函数最好使用成员初值列，不要在构造函数中使用赋值操作，初值列中的成员变量的顺序应该和声明顺序一致。 为免除“跨编译单元之初始化次序”问题，使用返回local static对象引用的函数来代替non-local static对象。 reference[1] Effective C++ · Scott Meyers","link":"/2021/12/19/effective-cpp-2/"},{"title":"CPP - 函数默认参数","text":"c++规定默认参数必须从函数参数的右边向左边使用，如下： 正确： 12void fun1(int a, int b=10);void fun2(int a, int b=10, int c=20); 错误： 12void fun3(int a=5, int b, int c);void fun4(int a, int b=5, int c); 默认参数不能在声明和定义中同时出现 错误： 12void fun1(int a=10);void fun1(int a=10){......} 正确： 12345void fun2(int a=10);void fun2(int a){......}// orvoid fun2(int a);void fun2(int a=10){......}","link":"/2021/12/11/cpp-default-parameters/"},{"title":"CPP - 头文件","text":"1 头文件的布局： 2 #define 保护 所有头文件都应该有 #define 保护来防止头文件被多重包含, 命名格式当是: &lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_ 。 防御式开头防止重复include头文件。 1234#ifndef COMMON_H#define COMMON_H//.... code#endif //COMMON_H Google C++规范： 为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径。 例如, 项目 foo 中的头文件 foo/src/bar/baz.h 可按如下方式保护: 1234#ifndef FOO_BAR_BAZ_H_#define FOO_BAR_BAZ_H_...#endif // FOO_BAR_BAZ_H_ 也可以使用 1#pragma once 3 前置声明 尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。 前置声明（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义。 前置声明是为了降低编译依赖，防止修改一个头文件引发多米诺效应。 Google C++规范： 优点： 节省编译时间：多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。 节省不必要的重新编译的时间： #include 使代码因为头文件中无关的改动而被重新编译多次。 缺点： 前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。 前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。 极端情况下，用前置声明代替 #include 甚至都会暗暗地改变代码的含义： 123456789// b.h:struct B {};struct D : B {};// good_user.cc:#include &quot;b.h&quot;void f(B*);void f(void*);void test(D* x) { f(x); } // calls f(B*) ​ 如果 #include 被 B 和 D 的前置声明替代， test() 就会调用 f(void*) 结论： 尽量避免前置声明那些定义在其他项目中的实体. 函数：总是使用 #include. 类模板：优先使用 #include. 4 内联函数 只有当函数只有 10 行甚至更少时才将其定义为内联函数. 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用。 在类的声明中定义的函数将被编译器尝试翻译为内联函数。 优点: 只要内联的函数体较小, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联. 缺点: 滥用内联将导致程序变得更慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。 经验： 不要内联超过 10 行的函数 谨慎对待析构函数 内联包含循环或 switch 语句的函数往往得不偿失 一般不会被内联的函数：虚函数和递归函数不会被正常内联 5 #include 的路径及顺序 使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 .h, 本项目内的 .h. 项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 . (当前目录) 或 .. (上级目录).(即使用绝对路径而非相对路径) #include 的顺序： dir2/foo2.h (这个cpp文件对应的.h文件，放置于优先位置) C 系统文件 C++ 系统文件 其他库的 .h 文件 本项目内 .h 文件 这种优先的顺序排序保证 dir2/foo2.h（.h文件） 遗漏某些必要的库时， 其实现/测试（.cpp文件）的构建会立刻中止。这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是别人。","link":"/2021/10/26/cpp-header-file/"},{"title":"CPP面向对象 - 概述","text":"C vs C++C是面向过程的，C++是面向对象的，面向对象即是讲一些数据和函数绑定在一起。 对象(classes)的两种经典分类 Class without pointer members complex 拷贝都得一一复制（因为数据成员都包含在对象中了） Class with pointer members string 拷贝分深浅，因此有移动语义（C++11支持） C++程序代码的基本形式一般而言分 .cpp 或 .h 两种： .h ：写一些类的声明 .cpp ：类的实现 也不一定是 .cpp 或 .h 文件，也有可能是 .hpp 等文件。","link":"/2021/10/26/cpp-oop-intro/"},{"title":"CPP - 栈展开(stack unwinding)","text":"栈展开（stack unwinding）的定义抛出异常时，将暂停当前函数的执行，开始查找匹配的 catch 子句。首先检查 throw 本身是否在 try 块内部，如果是，检查与该 try 相关的 catch 子句，看是否可以处理该异常。如果不能处理，就退出当前函数，并且释放当前函数的内存并销毁局部对象，继续到上层的调用函数中查找，直到找到一个可以处理该异常的 catch 。这个过程称为栈展开（stack unwinding）。当处理该异常的 catch 结束之后，紧接着该 catch 之后的点继续执行。 为局部对象调用析构函数 在栈展开的过程中，会释放局部对象所占用的内存并运行类类型局部对象的析构函数。但需要注意的是，如果一个块通过 new 动态分配内存，并且在释放该资源之前发生异常，该块因异常而退出，那么在栈展开期间不会释放该资源，编译器不会删除该指针，这样就会造成内存泄露。 析构函数应该从不抛出异常 在为某个异常进行栈展开的时候，析构函数如果又抛出自己的未经处理的另一个异常，将会导致调用标准库 terminate 函数。通常 terminate 函数将调用 abort 函数，导致程序的非正常退出。所以析构函数应该从不抛出异常。 异常与构造函数 如果在构造函数对象时发生异常，此时该对象可能只是被部分构造，要保证能够适当的撤销这些已构造的成员。 未捕获的异常将会终止程序 不能不处理异常。如果找不到匹配的catch，程序就会调用库函数terminate。 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;class MyException{};class Dummy {public: // 构造函数 Dummy(string s) : MyName(s) { PrintMsg(&quot;Created Dummy:&quot;); } // 拷贝构造 Dummy(const Dummy&amp; other) : MyName(other.MyName){ PrintMsg(&quot;Copy created Dummy:&quot;); } // 析构函数 ~Dummy(){ PrintMsg(&quot;Destroyed Dummy:&quot;); } void PrintMsg(string s) { cout &lt;&lt; s &lt;&lt; MyName &lt;&lt; endl; } string MyName; int level;};void C(Dummy d, int i) { cout &lt;&lt; &quot;Entering Function C&quot; &lt;&lt; endl; d.MyName = &quot; C&quot;; throw MyException(); cout &lt;&lt; &quot;Exiting Function C&quot; &lt;&lt; endl;}void B(Dummy d, int i) { cout &lt;&lt; &quot;Entering Function B&quot; &lt;&lt; endl; d.MyName = &quot; B&quot;; C(d, i + 1); cout &lt;&lt; &quot;Exiting Function B&quot; &lt;&lt; endl;}void A(Dummy d, int i) { cout &lt;&lt; &quot;Entering Function A&quot; &lt;&lt; endl; d.MyName = &quot; A&quot; ; // Dummy* pd = new Dummy(&quot;new Dummy&quot;); //Not exception safe!!! B(d, i + 1); // delete pd; cout &lt;&lt; &quot;Exiting FunctionA&quot; &lt;&lt; endl;}int main() { cout &lt;&lt; &quot;Entering main&quot; &lt;&lt; endl; try { Dummy d(&quot; M&quot;); A(d,1); } catch (MyException&amp; e) { cout &lt;&lt; &quot;Caught an exception of type: &quot; &lt;&lt; typeid(e).name() &lt;&lt; endl; } cout &lt;&lt; &quot;Exiting main.&quot; &lt;&lt; endl; return 0;}/**/ 进行编译，运行，可得到如下结果： 1234567891011121314151617$ g++ stack_unwinding.cpp -o stack_test -std=c++11$ ./stack_test Entering mainCreated Dummy: MCopy created Dummy: MEntering Function ACopy created Dummy: AEntering Function BCopy created Dummy: BEntering Function CDestroyed Dummy: CDestroyed Dummy: BDestroyed Dummy: ADestroyed Dummy: MCaught an exception of type: 11MyExceptionExiting main. 程序运行时对应栈的内容如下图所示： 程序执行将从 C 中的 throw 语句跳转到 main 中的 catch 语句，并在此过程中展开每个函数。 根据创建 Dummy 对象的顺序，在它们超出范围时将其销毁。 除了包含 catch 语句的 main 之外，其他函数均未完成。 函数 A 绝不会从其对 B() 的调用返回，并且 B 绝不会从其对 C() 的调用返回。 reference[1] microsoft C++文档 [2] 抛出异常与栈展开（stack unwinding）","link":"/2023/03/05/cpp-stack-unwinding/"},{"title":"CPP - 虚函数指针和虚函数表","text":"虚函数指针和虚函数表虚函数表的定义多态是由虚函数实现的，而虚函数主要是通过虚函数表（V-Table）来实现的。 如果一个类中包含虚函数（virtual修饰的函数），那么这个类就会包含一张虚函数表(vftbl)，虚函数表存储的每一项是一个虚函数的地址。在一个对象的内存布局中，指向这张虚函数表的指针（vfptr）位于最前端。如下图： 一般继承（无虚函数覆盖）对于如下UML的类：在普通继承情况，派生类没有重写基类的虚函数： 体现在代码上为： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;class Base{public: virtual void f() { cout &lt;&lt; &quot;Base:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base:h()&quot; &lt;&lt; endl; }};class Derive : public Base{public: virtual void f1() { cout &lt;&lt; &quot;Derive:f1()&quot; &lt;&lt; endl; } virtual void g1() { cout &lt;&lt; &quot;Derive:g1()&quot; &lt;&lt; endl; } virtual void h1() { cout &lt;&lt; &quot;Derive:h1()&quot; &lt;&lt; endl; }};int main() { Base base; Derive derive;} 使用lldb查看虚函数指针和虚函数表内容： 根据结果，可以得知其虚函数表如下图： 一般继承（有虚函数覆盖）对于如下UML的类：在普通继承情况，派生类重写了基类的虚函数( f() )： 代码为： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;class Base{public: virtual void f() { cout &lt;&lt; &quot;Base:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base:h()&quot; &lt;&lt; endl; }};class Derive : public Base{public: virtual void f() { cout &lt;&lt; &quot;Derive:f()&quot; &lt;&lt; endl; } virtual void g1() { cout &lt;&lt; &quot;Derive:g1()&quot; &lt;&lt; endl; } virtual void h1() { cout &lt;&lt; &quot;Derive:h1()&quot; &lt;&lt; endl; }};int main() { Base base; Derive derive;} 结果为： 绘制成图，为： 多重继承（无虚函数覆盖）对于如下UML的类：在多重继承情况，派生类没有重写了基类的虚函数： 代码为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;using namespace std;class Base1{public: virtual void f() { cout &lt;&lt; &quot;Base1:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base1:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base1:h()&quot; &lt;&lt; endl; }};class Base2{public: virtual void f() { cout &lt;&lt; &quot;Base2:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base2:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base2:h()&quot; &lt;&lt; endl; }};class Base3{public: virtual void f() { cout &lt;&lt; &quot;Base3:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base3:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base3:h()&quot; &lt;&lt; endl; }};class Derive : public Base1, public Base2, public Base3{public: virtual void f1() { cout &lt;&lt; &quot;Derive:f1()&quot; &lt;&lt; endl; } virtual void g1() { cout &lt;&lt; &quot;Derive:g1()&quot; &lt;&lt; endl; }};int main() { Derive derive;} 结果为： 绘制成图，为： 多重继承（有虚函数覆盖）对于如下UML的类：在多重继承情况，派生类没有重写了基类的虚函数： 代码为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;using namespace std;class Base1{public: virtual void f() { cout &lt;&lt; &quot;Base1:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base1:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base1:h()&quot; &lt;&lt; endl; }};class Base2{public: virtual void f() { cout &lt;&lt; &quot;Base2:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base2:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base2:h()&quot; &lt;&lt; endl; }};class Base3{public: virtual void f() { cout &lt;&lt; &quot;Base3:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base3:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base3:h()&quot; &lt;&lt; endl; }};class Derive : public Base1, public Base2, public Base3{public: virtual void f() { cout &lt;&lt; &quot;Derive:f()&quot; &lt;&lt; endl; } virtual void g1() { cout &lt;&lt; &quot;Derive:g1()&quot; &lt;&lt; endl; }};int main() { Derive derive;} 结果为： 绘制成图，为：","link":"/2023/03/05/cpp-virtual-function/"},{"title":"STL - 番外2 优先队列默认是大根堆？","text":"stl中默认堆为大根堆，大根堆的定义为： 1priority_queue&lt;int&gt; q; 根据源码中的定义，有如下代码： 123456789101112131415template &lt;class _Tp, class _Container = vector&lt;_Tp&gt;, class _Compare = less&lt;typename _Container::value_type&gt; &gt;class _LIBCPP_TEMPLATE_VIS priority_queue{public: typedef _Container container_type; typedef _Compare value_compare; typedef typename container_type::value_type value_type; typedef typename container_type::reference reference; typedef typename container_type::size_type size_type;protected: container_type c; value_compare comp;} 从最开头我们可以看出，声明优先队列时，第一参数为类型，第二参数为容器，第三参数为比较函数（默认小于）。 那么问题来了，为什么默认的这个cmp仿函数为小于的堆，是个大根堆（堆顶元素为最大值）？ 建堆时都是一步步push()的，查看源码，可以看到如下函数： 1234567891011// 类里边的声明void push(value_type&amp;&amp; __v);// push实现template &lt;class _Tp, class _Container, class _Compare&gt;inlinevoidpriority_queue&lt;_Tp, _Container, _Compare&gt;::push(value_type&amp;&amp; __v){ c.push_back(_VSTD::move(__v)); _VSTD::push_heap(c.begin(), c.end(), comp);} 从上述代码可以看出，优先队列的push操作就是往容器内push_back一个数，然后执行一个push_heap()操作。 查看push_heap()操作，可以看到如下代码： 12345678template &lt;class _RandomAccessIterator, class _Compare&gt;inline _LIBCPP_INLINE_VISIBILITYvoidpush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp){ typedef typename __comp_ref_type&lt;_Compare&gt;::type _Comp_ref; __sift_up&lt;_Comp_ref&gt;(__first, __last, __comp, __last - __first);} 其又掉用了__sift_up()函数，学过堆的小伙伴应该对这个up操作十分熟悉吧！ __sift_up()函数实现如下： 123456789101112131415161718192021222324252627282930313233343536template &lt;class _Compare, class _RandomAccessIterator&gt;void__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp, typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type __len){ typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type value_type; if (__len &gt; 1) { // ((__len - 1) -1) / 2; __len = (__len - 2) / 2; _RandomAccessIterator __ptr = __first + __len; if (__comp(*__ptr, *--__last)) { value_type __t(_VSTD::move(*__last)); do { *__last = _VSTD::move(*__ptr); __last = __ptr; if (__len == 0) break; __len = (__len - 1) / 2; __ptr = __first + __len; } while (__comp(*__ptr, __t)); *__last = _VSTD::move(__t); } }}template &lt;class _Tp&gt;inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPRtypename remove_reference&lt;_Tp&gt;::type&amp;&amp;move(_Tp&amp;&amp; __t) _NOEXCEPT{ typedef _LIBCPP_NODEBUG_TYPE typename remove_reference&lt;_Tp&gt;::type _Up; return static_cast&lt;_Up&amp;&amp;&gt;(__t);} 从__sift_up()函数的代码我们可以看出：这个cmp仿函数时一直传进来了的，而且是根据 __comp(*__ptr, __t)一直在执行某操作的。 这里就要涉及到heap的up操作了。 heap的up，简而言之，就是把元素和他的父亲节点（/2便是父亲节点，完全二叉树性质）比较，如果符合某性质，就将该节点上移。 以上源码类似于如下代码： 12345678910void sift-up ( MaxHeap H){ i = H-&gt;size; item = H-&gt;Element [i]; for ( ; H -&gt; Element [ i/2 ] &lt; item; i /= 2 ) // 与父结点做比较，i / 2 表示的就是父结点的下标 { H -&gt; Element [ i ] = H -&gt; Element [ i/2 ]; // 向下过滤结点 } H -&gt; Element [ i ] = item ; //若for循环完成后,i更新为父节点i，然后将 item 插入} 对于less的话，就是满足小于，则将节点上移，这样就形成了一个大根堆。 所以大小根堆可以以以下方式声明。 1234// 大根堆 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q;// 小根堆 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;","link":"/2023/03/05/stl-priority-queue/"},{"title":"STL - deque源码分析","text":"deque概述deque是一种双向开口的“连续”线性空间（即可以在头尾两端分别做元素的插入和删除操作）。 deque与vector的差别： deque允许在常数时间内对头端进行元素的插入和删除操作，vector尾部插入和删除常数时间，头部操作O（n）时间 deque没有容量概念，不需要和vector一样进行老三样：申请新空间-&gt;复制元素-&gt;释放旧空间 deque的Ramdon Access Iterator进行过特殊设计，复杂度比vector高。 deque的中控器底层内存分布deque的“连续”空间只是在逻辑上连续的，实际上deque是由一段一段的定量连续空间构成。一旦有必要在deque的头端或尾端增加新空间，便配置一段定量的连续空间，串接在整个deque的头端或尾端。 deque的核心任务是维护 分段的定量连续空间整体连续的假象，并提供随机存取的接口，避免vector的申请新空间-&gt;复制元素-&gt;释放旧空间，但其代价是deque的迭代器架构较复杂。 中控器正如上面那张图看到的，对于分段的定量连续空间，我们需要一个map（就是一小段连续空间，和数组类似）来指示他（就像一个包租婆有很多房子，手里得有一个地图，找到他的每个房子） 1234567891011121314template &lt;class T, class Alloc = alloc, size_t BufSiz = 0&gt; class deque {public: // Basic types typedef T value_type; typedef value_type* pointer; typedef value_type&amp; reference; typedef size_t size_type; typedef ptrdiff_t difference_type;protected: // Internal typedefs typedef pointer* map_pointer;protected: map_pointer map;//指向指针数组 T** 类似于二维数组 T*指向一个缓冲区，T**就是这个map size_type map_size;//指针数组元素个数} deque的迭代器迭代器结构deque是分段连续空间，维护“整体连续”假象的任务就落在了operator++和operator–两个运算上了。 我们可以想象，一个iterator指向一个缓冲区（buffer）内元素时，当到了一个buffer的末端则需要跳到下一个buffer，到了buffer的头端则需要跳转到前一个buffer，这里则需要我们前面所说的map来调节。如何知道我们是否在buffer的头尾端呢？这就需要iterator保存这个buffer的begin和end了。 综上，deque的iterator需要以下元素： 指向当前元素的指针 指向当前buffer头端的指针 指向当前buffer尾端的指针 指向map中控的指针 SGI STL中源码如下： 123456789101112131415161718192021222324252627282930313233343536template &lt;class T, class Ref, class Ptr, size_t BufSiz&gt;struct __deque_iterator { // 未继承 std::iterator typedef __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator; typedef __deque_iterator&lt;T, const T&amp;, const T*, BufSiz&gt; const_iterator; static size_t buffer_size() {return __deque_buf_size(BufSiz, sizeof(T)); }#else /* __STL_NON_TYPE_TMPL_PARAM_BUG */template &lt;class T, class Ref, class Ptr&gt;struct __deque_iterator { // 未继承 std::iterator typedef __deque_iterator&lt;T, T&amp;, T*&gt; iterator; typedef __deque_iterator&lt;T, const T&amp;, const T*&gt; const_iterator; static size_t buffer_size() {return __deque_buf_size(0, sizeof(T)); }#endif // 未继承 std::iterator，所以必须自己写五个必要的迭代器相应型别 typedef random_access_iterator_tag iterator_category; // (1) typedef T value_type; // (2) typedef Ptr pointer; // (3) typedef Ref reference; // (4) typedef size_t size_type; typedef ptrdiff_t difference_type; // (5) typedef T** map_pointer; typedef __deque_iterator self; // 保持与容器的联结 T* cur; // 此迭代器所指之缓冲区中的现行（current）元素 T* first; // 此迭代器所指之缓冲区头 T* last; // 此迭代器所指之缓冲区尾（含备用空间） map_pointer node; __deque_iterator(T* x, map_pointer y) : cur(x), first(*y), last(*y + buffer_size()), node(y) {} __deque_iterator() : cur(0), first(0), last(0), node(0) {} __deque_iterator(const iterator&amp; x) : cur(x.cur), first(x.first), last(x.last), node(x.node) {}} 其中用来决定缓冲区大小的函数buffer_size()，调用__deque_buf_size() 123456789// 如果 n 不为 0，传回 n，表示 buffer size 由使用者自定。// 如果 n 为 0，表示buffer size 使用预设值，那么// 如果 sz（元素大小，sizeof(value_type)）小于 512，传回 512/sz，// 如果 sz 不小于 512，传回 1。inline size_t __deque_buf_size(size_t n, size_t sz){ return n != 0 ? n : (sz &lt; 512 ? size_t(512 / sz) : size_t(1));} 有了迭代器，缓存区，中控map，我们的deque的原型就出来啦： 迭代器操作迭代器到buffer边缘，则需要请求中控map，看怎么跳转buffer。 12345void set_node(map_pointer new_node) { node = new_node; first = *new_node; last = first + difference_type(buffer_size());} 解引用操作： 12reference operator*() const { return *cur; }pointer operator-&gt;() const { return &amp;(operator*()); } 计算两迭代器之间距离： 12345// 两个iterator相减，计算距离difference_type operator-(const self&amp; x) const { return difference_type(buffer_size()) * (node - x.node - 1) + (cur - first) + (x.last - x.cur);} 迭代器的++、–操作： 123456789101112131415161718192021222324252627282930// 参考 More Effective C++, item6: Distinguish between prefix and// postfix forms of increment and decrement operators.self&amp; operator++() { ++cur; // 切换至下一个元素。 if (cur == last) { // 如果已达所在缓冲区的尾端， set_node(node + 1); // 就切换至下一个节点（亦即缓冲区） cur = first; // 的第一个元素。 } return *this;}self operator++(int) { self tmp = *this; ++*this; return tmp;}self&amp; operator--() { if (cur == first) { // 如果已达所在缓冲区的头端， set_node(node - 1); // 就切换至前一个节点（亦即缓冲区） cur = last; // 的最后一个元素。 } --cur; // 切换至前一个元素。 return *this;}self operator--(int) { self tmp = *this; --*this; return tmp;} 迭代器+一个数值访问实现： 123456789101112131415161718192021222324252627282930313233343536// 參考 More Effective C++, item22: Consider using op= instead of// stand-alone op.self operator+(difference_type n) const { self tmp = *this; return tmp += n; // 调用operator+=}self&amp; operator+=(difference_type n) { difference_type offset = n + (cur - first); if (offset &gt;= 0 &amp;&amp; offset &lt; difference_type(buffer_size())) // 目标位置在同一缓冲区內 cur += n; else { // 目标位置不在同一缓冲区內 difference_type node_offset = offset &gt; 0 ? offset / difference_type(buffer_size()) : -difference_type((-offset - 1) / buffer_size()) - 1; // 切换至正确的节点（亦即缓冲区） set_node(node + node_offset); // 切换至正确的元素 cur = first + (offset - node_offset * difference_type(buffer_size())); } return *this;}// 參考 More Effective C++, item22: Consider using op= instead of // stand-alone op.self operator-(difference_type n) const { self tmp = *this; return tmp -= n; // 调用operator-=}self&amp; operator-=(difference_type n) { return *this += -n; }// 以上利用operator+= 来完成 operator-= 随机访问实现，模拟连续空间： 123//随机存取实现reference operator[](difference_type n) const { return *(*this + n); }// 以上调用operator*, operator+ 迭代器的比较操作： 12345bool operator==(const self&amp; x) const { return cur == x.cur; }bool operator!=(const self&amp; x) const { return !(*this == x); }bool operator&lt;(const self&amp; x) const { return (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node);} deque的数据结构deque除了维护一个map中控和map中控大小外，还维护了start、finish两个迭代器，分别指向第一个buffer的第一个元素和最后buffer的最后一个元素的下一个位置（左闭右开）。map中控大小的作用是：一旦节点不足，就得配置一块更大的map。 deque的数据结构如下： 1234567891011121314151617181920212223template &lt;class T, class Alloc = alloc, size_t BufSiz = 0&gt; class deque {public: // Basic types typedef T value_type; typedef value_type* pointer; typedef value_type&amp; reference; typedef size_t size_type; typedef ptrdiff_t difference_type;protected: // Internal typedefs typedef pointer* map_pointer; static size_type buffer_size() {//返回 return __deque_buf_size(BufSiz, sizeof(value_type)); } static size_type initial_map_size() { return 8; }protected: // Data members map_pointer map;//指向指针数组 size_type map_size;//指针数组元素个数 iterator start;//开始迭代器，其中cur指向头部元素 iterator finish;//结束迭代器，其中cur指向尾部元素后面的一个元素} deque的基本对外接口： 123456789101112131415161718192021222324252627282930public: // Basic accessorsiterator begin() { return start; }iterator end() { return finish; }const_iterator begin() const { return start; }const_iterator end() const { return finish; }reference operator[](size_type n) { return start[difference_type(n)]; // 调用 __deque_iterator&lt;&gt;::operator[]}const_reference operator[](size_type n) const { return start[difference_type(n)];}reference front() { return *start; } // 调用 __deque_iterator&lt;&gt;::operator*reference back() { iterator tmp = finish; --tmp; // 调用 __deque_iterator&lt;&gt;::operator-- return *tmp; // 调用 __deque_iterator&lt;&gt;::operator*}size_type size() const { return finish - start; }// 以上调用iterator::operator-size_type max_size() const { return size_type(-1); }bool empty() const { return finish == start; } deque的构造与内存管理deque的ctordeque自行定义了两个空间配置器： 12345protected: // Internal typedefs// 专属之空间配置器，每次配置一个元素大小typedef simple_alloc&lt;value_type, Alloc&gt; data_allocator;// 专属之空间配置器，每次配置一个指标大小typedef simple_alloc&lt;pointer, Alloc&gt; map_allocator; 并有如下构造函数： 12345deque(size_type n, const value_type&amp; value) : start(), finish(), map(0), map_size(0){ fill_initialize(n, value);} fill_initialize()负责产生并安排好deque的结构，并将元素的初值设置好： 123456789101112131415template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::fill_initialize(size_type n, const value_type&amp; value) { create_map_and_nodes(n); // 把deque的结构都产生并安排好 map_pointer cur; __STL_TRY { // 为每个节点的缓冲区設定初值 for (cur = start.node; cur &lt; finish.node; ++cur) uninitialized_fill(*cur, *cur + buffer_size(), value); // 最后一个节点的设定稍有不同（因为尾端可能有备用空间，不必设初值） uninitialized_fill(finish.first, finish.cur, value); } catch(...) { // &quot;commit or rollback&quot; ：若非全部成功，就一个不留。 } 其中create_map_and_nodes()复制产生并安排好deque的结构： 123456789101112131415161718192021222324252627282930313233343536template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::create_map_and_nodes(size_type num_elements) { // 需要节点数=(元素个数/每个缓冲区可容纳的元素个数)+1 // 如果刚好整除，會多配一个节点。 size_type num_nodes = num_elements / buffer_size() + 1; // 一个 map 要管理几个节点。最少8个，最多是 “所需节点数加2” // （前后各預留一个，扩充時可用）。 map_size = max(initial_map_size(), num_nodes + 2); map = map_allocator::allocate(map_size); // 以上配置出一个 “具有 map_size个节点” 的map。 // 以下令nstart和nfinish指向map所拥有之全部节点的最中央区段。 // 保持在最中央，可使头尾两端的扩充能量一样大。每个节点可对应一个缓冲区。 map_pointer nstart = map + (map_size - num_nodes) / 2; map_pointer nfinish = nstart + num_nodes - 1; map_pointer cur; __STL_TRY { // 为map內的每个現用节点配置缓冲区。所有缓冲区加起来就是deque的空间 // （最后一个缓冲区可能留有一些余裕）。 for (cur = nstart; cur &lt;= nfinish; ++cur) *cur = allocate_node(); } catch(...) { // &quot;commit or rollback&quot; ：若非全部成功，就一个不留。 } // 为deque内的两个迭代器start和end 設定正确的内容。 start.set_node(nstart); finish.set_node(nfinish); start.cur = start.first; // first, cur都是public finish.cur = finish.first + num_elements % buffer_size(); // 前面说过，如果刚好整除，会多配一个节点。 // 此时即令cur指向這多配的一個节点（所对应之缓冲区）的起点。} push_back() &amp; push_front()12345678910public: // push_* and pop_*void push_back(const value_type&amp; t) { if (finish.cur != finish.last - 1) { // 最后缓冲区尚有一个以上的备用空间 construct(finish.cur, t); // 直接在备用空间上建构元素 ++finish.cur; // 調整最后缓冲区的使用状态 } else // 最后缓冲区已无（或只剩一个）元素备用空间。 push_back_aux(t);} 尾端只有一个元素备用空间时，push_back调用push_back_aux()，先设置一整块的buffer，再设置新元素内容，然后更改finish： 1234567891011121314// 只有当 finish.cur == finish.last – 1 时才会被呼叫。// 也就是说只有当最后一个缓冲区只剩一个备用元素空間时才会被呼叫。template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::push_back_aux(const value_type&amp; t) { value_type t_copy = t; reserve_map_at_back(); // 若符合某种条件則必須重换一个map *(finish.node + 1) = allocate_node(); // 配置一个新节点（缓冲区） __STL_TRY { construct(finish.cur, t_copy); // 设值 finish.set_node(finish.node + 1); // 改变finish，令其指向新节点 finish.cur = finish.first; // 設定 finish 的状态 } __STL_UNWIND(deallocate_node(*(finish.node + 1)));} push_front()和push_back()同理： 123456789101112131415161718192021222324252627282930void push_front(const value_type&amp; t) { if (start.cur != start.first) { // 第一缓冲区尚有备用空間 construct(start.cur - 1, t); // 直接在备用空間上建构元素 --start.cur; // 调整第一缓冲区的使用状态 } else // 第一缓冲区已无备用空間 push_front_aux(t);}// 只有当start.cur == start.first時才会被呼叫。// 也就是说只有当第一个缓冲区沒有任何备用元素時才会被呼叫。template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::push_front_aux(const value_type&amp; t) { value_type t_copy = t; reserve_map_at_front(); // 若符合某种条件則必須重换一个map *(start.node - 1) = allocate_node(); // 配置一个新节点（缓冲区） __STL_TRY { start.set_node(start.node - 1); // 改变start，令其指向新节点 start.cur = start.last - 1; // 设定 start的状态 construct(start.cur, t_copy); // 设值 } catch(...) { // &quot;commit or rollback&quot; ：若非全部成功，就一个不留。 start.set_node(start.node + 1); start.cur = start.first; deallocate_node(*(start.node - 1)); throw; }} 其中，整治map的操作reserve_map_at_back()和reserve_map_at_front()为调用reallocate_map()： 12345678910111213void reserve_map_at_back (size_type nodes_to_add = 1) { if (nodes_to_add + 1 &gt; map_size - (finish.node - map)) // 如果 map 尾端的节点备用空间不足 // 符合以上条件則必須重换一个map（配置更大的，拷贝原來的，释放原來的） reallocate_map(nodes_to_add, false);}void reserve_map_at_front (size_type nodes_to_add = 1) { if (nodes_to_add &gt; start.node - map) // 如果 map 前端的节点备用空间不足 // 符合以上条件則必須重换一个map（配置更大的，拷贝原來的，释放原來的） reallocate_map(nodes_to_add, true);} reallocate_map()函数实现为： 12345678910111213141516171819202122232425262728293031323334template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::reallocate_map(size_type nodes_to_add, bool add_at_front) { size_type old_num_nodes = finish.node - start.node + 1; size_type new_num_nodes = old_num_nodes + nodes_to_add; map_pointer new_nstart; if (map_size &gt; 2 * new_num_nodes) { new_nstart = map + (map_size - new_num_nodes) / 2 + (add_at_front ? nodes_to_add : 0); if (new_nstart &lt; start.node) copy(start.node, finish.node + 1, new_nstart); else copy_backward(start.node, finish.node + 1, new_nstart + old_num_nodes); } else { size_type new_map_size = map_size + max(map_size, nodes_to_add) + 2; // 配置一块空間，准备给新map使用。 map_pointer new_map = map_allocator::allocate(new_map_size); new_nstart = new_map + (new_map_size - new_num_nodes) / 2 + (add_at_front ? nodes_to_add : 0); // 把原map 內容拷贝过来。 copy(start.node, finish.node + 1, new_nstart); // 释放原map map_allocator::deallocate(map, map_size); // 设定新map的起始位址与大小 map = new_map; map_size = new_map_size; } // 重新设定迭代器 start 和 finish start.set_node(new_nstart); finish.set_node(new_nstart + old_num_nodes - 1);} deque的元素操作pop_back() &amp; pop_front()pop操作和push操作相反，pop是要把元素拿掉，push需要考虑加入buffer，而pop则需要考虑释放buffer。 12345678910111213141516171819202122232425262728293031323334353637383940void pop_back() { if (finish.cur != finish.first) { // 最后缓冲区有一个（或更多）元素 --finish.cur; // 调整指标，相当于排除了最后元素 destroy(finish.cur); // 将最后元素析构 } else // 最后缓冲区没有任何元素 pop_back_aux(); // 這里将进行缓冲区的释放工作}// 只有当finish.cur == finish.first时才會被呼叫。template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::pop_back_aux() { deallocate_node(finish.first); // 释放最后一个缓冲区 finish.set_node(finish.node - 1); // 调整 finish 的状态，使指向 finish.cur = finish.last - 1; // 上一个缓冲区的最后一个元素 destroy(finish.cur); // 将该元素析构。}void pop_front() { if (start.cur != start.last - 1) { // 第一缓冲区有一个（或更多）元素 destroy(start.cur); // 将第一元素析构 ++start.cur; // 调整指标，相当于排除了第一元素 } else // 第一缓冲区僅有一个元素 pop_front_aux(); // 這里将进行缓冲区的释放工作}// 只有当start.cur == start.last - 1时才會被呼叫。template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::pop_front_aux() { destroy(start.cur); // 将第一缓冲区的第一个元素析构。 deallocate_node(start.first); // 释放第一缓冲区。 start.set_node(start.node + 1); // 调整 start 的状态，使指向 start.cur = start.first; // 下一个缓冲区的第一个元素。} clear()clear()用于清空deque，deque在初始的时候有一个buffer，因此clear之后，也应该有一个buffer。 1234567891011121314151617181920212223// 注意，最終需要保留一個緩衝區。這是deque 的策略，也是deque 的初始狀態。template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::clear() { // 以下針對頭尾以外的每一個緩衝區（它們一定都是飽滿的） for (map_pointer node = start.node + 1; node &lt; finish.node; ++node) { // 將緩衝區內的所有元素解構。注意，呼叫的是destroy() 第二版本，見2.2.3節 destroy(*node, *node + buffer_size()); // 釋放緩衝區記憶體 data_allocator::deallocate(*node, buffer_size()); } if (start.node != finish.node) { // 至少有頭尾兩個緩衝區 destroy(start.cur, start.last); // 將頭緩衝區的目前所有元素解構 destroy(finish.first, finish.cur); // 將尾緩衝區的目前所有元素解構 // 以下釋放尾緩衝區。注意，頭緩衝區保留。 data_allocator::deallocate(finish.first, buffer_size()); } else // 只有一個緩衝區 destroy(start.cur, finish.cur); // 將此唯一緩衝區內的所有元素解構 // 注意，並不釋放緩衝區空間。這唯一的緩衝區將保留。 finish = start; // 調整狀態} erase()erase()函数可以清除一个iterator的内容，也可以清除一个范围的内容。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 清除 pos 所指的元素。pos 為清除點。iterator erase(iterator pos) { iterator next = pos; ++next; difference_type index = pos - start; // 清除點之前的元素個數 if (index &lt; (size() &gt;&gt; 1)) { // 如果清除點之前的元素比較少， copy_backward(start, pos, next); // 就搬移清除點之前的元素 pop_front(); // 搬移完畢，最前一個元素贅餘，去除之 } else { // 清除點之後的元素比較少， copy(next, finish, pos); // 就搬移清除點之後的元素 pop_back(); // 搬移完畢，最後一個元素贅餘，去除之 } return start + index;}template&lt;class T, class Alloc, size_t BufSize&gt;deque&lt;T, Alloc, BufSize&gt;::iterator deque&lt;T, Alloc, BufSize&gt;::erase(iterator first, iterator last) { if (first == start &amp;&amp; last == finish) { // 如果清除區間就是整個 deque clear(); // 直接呼叫 clear() 即可 return finish; } else { difference_type n = last - first; // 清除區間的長度 difference_type elems_before = first - start; // 清除區間前方的元素個數 if (elems_before &lt; (size() - n) / 2) { // 如果前方的元素比較少， copy_backward(start, first, last); // 向後搬移前方元素（覆蓋清除區間） iterator new_start = start + n; // 標記 deque 的新起點 destroy(start, new_start); // 搬移完畢，將贅餘的元素解構// 以下將贅餘的緩衝區釋放 for (map_pointer cur = start.node; cur &lt; new_start.node; ++cur) data_allocator::deallocate(*cur, buffer_size()); start = new_start; // 設定 deque 的新起點 } else { // 如果清除區間後方的元素比較少 copy(last, finish, first); // 向前搬移後方元素（覆蓋清除區間） iterator new_finish = finish - n; // 標記 deque 的新尾點 destroy(new_finish, finish); // 搬移完畢，將贅餘的元素解構// 以下將贅餘的緩衝區釋放 for (map_pointer cur = new_finish.node + 1; cur &lt;= finish.node; ++cur) data_allocator::deallocate(*cur, buffer_size()); finish = new_finish; // 設定 deque 的新尾點 } return start + elems_before; }} insert()insert()功能：在某一点之前插入一个元素，并设定其值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 在position 處安插一個元素，其值為 xiterator insert(iterator position, const value_type &amp;x) { if (position.cur == start.cur) { // 如果安插點是deque 最前端 push_front(x); // 交給push_front 去做 return start; } else if (position.cur == finish.cur) { // 如果安插點是deque 最尾端 push_back(x); // 交給push_back 去做 iterator tmp = finish; --tmp; return tmp; } else { return insert_aux(position, x); // 交給 insert_aux 去做 }}template&lt;class T, class Alloc, size_t BufSize&gt;typename deque&lt;T, Alloc, BufSize&gt;::iteratordeque&lt;T, Alloc, BufSize&gt;::insert_aux(iterator pos, const value_type &amp;x) { difference_type index = pos - start; // 安插點之前的元素個數 value_type x_copy = x; if (index &lt; size() / 2) { // 如果安插點之前的元素個數比較少 push_front(front()); // 在最前端加入與第一元素同值的元素。 iterator front1 = start; // 以下標示記號，然後進行元素搬移... ++front1; iterator front2 = front1; ++front2; pos = start + index; iterator pos1 = pos; ++pos1; copy(front2, pos1, front1); // 元素搬移 } else { // 安插點之後的元素個數比較少 push_back(back()); // 在最尾端加入與最後元素同值的元素。 iterator back1 = finish; // 以下標示記號，然後進行元素搬移... --back1; iterator back2 = back1; --back2; pos = start + index; copy_backward(pos, back2, back1); // 元素搬移 } *pos = x_copy; // 在安插點上設定新值 return pos;}","link":"/2023/03/05/stl-deque/"},{"title":"STL - array源码分析","text":"array底层就是一个定长数组，给定长数组加上迭代器相关的东西，就可以让他像一个容器，符合容器的性质。 12345678910111213141516171819202122232425262728293031323334#define _NOEXCEPT noexcepttemplate&lt;class _Tp, size_t _Size&gt;struct array { // types: typedef _Tp value_type; typedef value_type &amp;reference; typedef value_type *pointer; typedef value_type *iterator; typedef ptrdiff_t difference_type; typedef size_t size_type; _Tp __elems_[_Size]; const value_type *data() const _NOEXCEPT { return __elems_; } // iterators: iterator begin() _NOEXCEPT { return iterator(data()); } iterator end() _NOEXCEPT { return iterator(data() + _Size); } reference operator[](size_type __n) _NOEXCEPT { return __elems_[__n]; } reference at(size_type __n);}template&lt;class _Tp, size_t _Size&gt;typename array&lt;_Tp, _Size&gt;::referencearray&lt;_Tp, _Size&gt;::at(size_type __n) { if (__n &gt;= _Size) __throw_out_of_range(&quot;array::at&quot;); return __elems_[__n];} 偏特化版本：(对size为0情况进行处理) 123456789101112131415161718192021template&lt;class _Tp&gt;struct array&lt;_Tp, 0&gt; { // types: typedef _Tp value_type; typedef value_type &amp;reference; typedef value_type *iterator; typedef value_type *pointer; typedef ptrdiff_t difference_type; typedef size_t size_type; typedef typename conditional&lt;is_const&lt;_Tp&gt;::value, const char, char&gt;::type _CharType; struct _ArrayInStructT { _Tp __data_[1]; }; _ALIGNAS_TYPE(_ArrayInStructT) _CharType __elems_[sizeof(_ArrayInStructT)]; value_type *data() _NOEXCEPT { return reinterpret_cast&lt;value_type *&gt;(__elems_); }}","link":"/2023/03/05/stl-array/"},{"title":"STL - 番外1 什么？sizeof(list&lt;int&gt;)竟然是24","text":"之前写了这样一段代码， 1234printf(&quot;%d | %d \\n&quot;, sizeof(std::list&lt;int&gt;), sizeof(std::list&lt;long long&gt;));/*24 | 24 */ 首先我们需要知道list是个什么东东： 点进std::list，可以看到以下代码，可以看出list这玩意貌似没有成员？但他继承了一个 __list_imp&lt;_Tp, _Alloc&gt;： 123456template &lt;class _Tp, class _Alloc /*= allocator&lt;_Tp&gt;*/&gt;class _LIBCPP_TEMPLATE_VIS list : private __list_imp&lt;_Tp, _Alloc&gt;{ ...} 点进__list_imp可以看到这个代码，有一个__end_，我们离真相又近了一点了，__end_是__node_base类型的，可以看到前边有个typedef： 1234567891011template &lt;class _Tp, class _Alloc&gt;class __list_imp{protected: typedef _Tp value_type; typedef typename __alloc_traits::void_pointer __void_pointer; typedef __list_node_base&lt;value_type, __void_pointer&gt; __node_base; __node_base __end_; ...} 点进__list_node_base，看看这是个啥玩意。哦豁，发现了两个指针！ 12345678910struct __list_node_base{ typedef __list_node_pointer_traits&lt;_Tp, _VoidPtr&gt; _NodeTraits; typedef typename _NodeTraits::__node_pointer __node_pointer; typedef typename _NodeTraits::__base_pointer __base_pointer; typedef typename _NodeTraits::__link_pointer __link_pointer; __link_pointer __prev_; __link_pointer __next_;}; 注意，这是个父结构体，再看看他子结构体的实现，如下： 1234567891011121314template &lt;class _Tp, class _VoidPtr&gt;struct __list_node : public __list_node_base&lt;_Tp, _VoidPtr&gt;{ _Tp __value_; typedef __list_node_base&lt;_Tp, _VoidPtr&gt; __base; typedef typename __base::__link_pointer __link_pointer; _LIBCPP_INLINE_VISIBILITY __link_pointer __as_link() { return static_cast&lt;__link_pointer&gt;(__base::__self()); }}; 好啊，终于找到了list的数据成员了，两根指针，一个数据，类似于以下形式： 123456template&lt;class T&gt;struct test { T* prev; T* next; T t;} 但是回到正题，为什么std::list是24呢？ 我的机子是64位机，指针是8bytes，int是4个字节，8*2+4 = 20，没毛病，20。 但是输出为什么是24呢？ 遇到这种问题，我们一般就需要从编译器角度考虑了（首先可以肯定，这肯定不是我的问题！） 结构体对齐，嗯结构体对齐，这是编译器考虑的范畴。 内存对齐的作用： 字节对齐主要是为了提高内存的访问效率，比如intel 32位cpu，每个总线周期都是从偶地址开始读取32位的内存数据，如果数据存放地址不是从偶数开始，则可能出现需要两个总线周期才能读取到想要的数据，因此需要在内存中存放数据时进行对齐。 结论1：一般情况下，结构体所占的内存大小并非元素本身大小之和。 结论2：结构体内存大小应按最大元素大小对齐，如果最大元素大小超过模数，应按模数大小对齐。 这里的模数就需要编译器来操作啦！ 我们试试取消内存对齐试试： 12345678910111213141516171819#include &lt;list&gt;template&lt;class T&gt;struct test { T* prev; T* next; T t;}__attribute__((__packed__)) ;int main(){ printf(&quot;%d | %d \\n&quot;, sizeof(int), sizeof(long long)); printf(&quot;%d | %d \\n&quot;, sizeof(std::list&lt;int&gt;), sizeof(std::list&lt;long long&gt;)); printf(&quot;%d | %d \\n&quot;, sizeof(test&lt;int&gt;), sizeof(test&lt;long long&gt;));}/*4 | 8 24 | 24 20 | 24*/ 可以发现，test已经是20了，说明list为24的原因就是因为内存对齐所致。 内存对齐的相关知识可以参考：https://www.zhihu.com/question/27862634 详细的内存对齐内容，将在以后探讨….","link":"/2023/03/05/stl-memory-question/"},{"title":"STL - list源码分析","text":"list概述list底层为非连续区间，即链表（实质上是一个双向循环链表） list每次插入或者删除一个元素，就配置和释放一个元素空间，对于任何位置的原属插入或原属移除，list永远为常数时间。 list的节点首先要知道，list本身和list的节点是不同的，如果我们声明一个list，里面放了100W个元素，然后执行sizeof，会发现sizeof的结果并不是100W。这就是因为容器所管理的内存空间大小和容器本身的大小是不一样的。 又如下测试代码： 1234567#include &lt;list&gt;int main(){ std::list&lt;int&gt; test (100); printf(&quot;sizeof: %d | size: %d | sizeof(int *) : %d\\n&quot;, sizeof(test), test.size(), sizeof(int*)); // ans: sizeof: 24 | size: 100 | sizeof(int *) : 8} 我的电脑为64位机，指针大小为8，可以看出，对list进行sizeof操作，其为24，而不是100，这也就能映衬上文所说的“容器所管理的内存空间大小和容器本身的大小是不一样的”。那么这24个byte是什么呢？这就得慢慢分析源代码了。 list的节点（node）定义如下，由一个指向前一个节点的指针，指向后一个节点的指针，和数据三个部分构成： 1234567template &lt;class T&gt;struct __list_node { typedef void* void_pointer; void_pointer next; void_pointer prev; T data;}; list的迭代器list的底层节点不能保证其在内存中连续存在，因此list的迭代器是不可能实现随机访问的，只能靠next和prev两根指针的移动来进行操作。这样的迭代器是双向迭代器（bidirectional_iterator），即只能向前和向后移动。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152template&lt;class T, class Ref, class Ptr&gt;struct __list_iterator { // 定义相应型别 typedef __list_iterator&lt;T, T&amp;, T*&gt; iterator; typedef __list_iterator&lt;T, Ref, Ptr&gt; self; typedef bidirectional_iterator_tag iterator_category; typedef T value_type; typedef Ptr pointer; typedef Ref reference; typedef __list_node&lt;T&gt;* link_type; typedef size_t size_type; typedef ptrdiff_t difference_type; // 拥有一个指向对应结点的指针 link_type node; // 构造函数 __list_iterator() {} __list_iterator(link_type x) : node(x) {} __list_iterator(const iterator&amp; x) : node(x.node) {} // 重载了iterator必须的操作符 // 解引用，取数据 reference operator*() const { return (*node).data; } // 指针使用-&gt;访问数据成员 pointer operator-&gt;() const { return &amp;(operator*()); } // ++iter，iter通过next指向下一个元素 self&amp; operator++() { node = (link_type)((*node).next); return *this; } self operator++(int){ self tmp = *this; ++*this; return tmp; } // --iter，iter通过prev指向上一个元素 self&amp; operator--() { node = (link_type)((*node).prev); return *this; } self operator--(int){ self tmp = *this; --*this; return tmp; } bool operator==(const self&amp; x) const { return node == x.node; } bool operator!=(const self&amp; x) const { return node != x.node; }}; list有一个重要的性质：插入（insert）和接合（splice）操作不回造成原有的list迭代器失效，这在vector是不成立的。list的元素删除操作（erase）也只会让指向“被删除元素”的迭代器失效，其他迭代器不受影响。 list的数据结构list的底层数据结构就是一个双向循环链表，要表示这个双向循环链表十分的简单，就用一个节点（node）即可（这样可以说明为什么上面sizeof(list)=24了，一个指针8字节（64位机），prev、next2个指针和一个，这里有个坑，以后再补呜呜呜）。我们在数据结构中学过，一般链表有一个头节点，在list中也是一样的，只不过为了满足STL迭代器前闭后开这个特性，使得begin()为node-&gt;next，end()为node。可结合代码与图一起理解。 1234567891011121314151617181920template &lt;class T, class Alloc = alloc&gt;class list {protected: typedef void* void_pointer; typedef __list_node&lt;T&gt; list_node; typedef simple_alloc&lt;list_node, Alloc&gt; list_node_allocator;public: typedef T value_type; typedef value_type* pointer; typedef value_type&amp; reference; typedef list_node* link_type; typedef size_t size_type; typedef ptrdiff_t difference_type;public: // 定义迭代器类型 typedef __list_iterator&lt;T, T&amp;, T*&gt; iterator;protected: link_type node; // 空白结点 链表尾结点 // ...}; 根据上图，不难得出关于迭代器的几个操作如下： 1234567891011121314// node 指向尾节点的下一位置，因此 node 符合STL对 end 的定义。iterator begin() { return (link_type)((*node).next); }iterator end() { return node; } bool empty() const { return node-&gt;next == node; }size_type size() const { size_type result = 0; distance(begin(), end(), result); // 全局函数，求begin()和end()之间的距离，有对于bidirectional_iterator的特化版本 return result;}// 取头节点的内容reference front() { return *begin(); } // 取尾节点的内容reference back() { return *(--end()); } list的构造与析构直接上构造函数和析构函数吧，看代码就能说明问题！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354template &lt;class T, class Alloc = alloc&gt;class list {public: // 默认构造函数，产生一个空链表 list() { empty_initialize(); }protected: // 初始化 void empty_initialize() { node = get_node(); // 配置一個节点空间，令 node 指向它。 node-&gt;next = node; // 令node 头尾都指向自己，不设元素值。 node-&gt;prev = node; } // 析构函数 ~list() { clear(); // 清楚所有节点 put_node(node); // 把list里边的node释放掉 } // 实现在下面，清除所有节点 void clear(); // 为结点分配内存 link_type get_node() { return list_node_allocator::allocate(); } // 回收内存 void put_node(link_type p) { list_node_allocator::deallocate(p); } // 构造node link_type create_node(const T&amp; x) { link_type p = get_node(); construct(&amp;p-&gt;data, x); return p; } // 销毁node void destroy_node(link_type p) { destroy(&amp;p-&gt;data); put_node(p); }};// 清除所有节点template &lt;class T, class Alloc&gt; void list&lt;T, Alloc&gt;::clear(){ link_type cur = (link_type) node-&gt;next; // begin() while (cur != node) { // 访问每一个节点 link_type tmp = cur; cur = (link_type) cur-&gt;next; destroy_node(tmp); // 摧毁（析构并释放）一个节点 } // 恢复 node 原始状态 node-&gt;next = node; node-&gt;prev = node;} list的其他操作list成员函数的实现其实就是对环状双向链表的操作。 首先是insert、erase、transfer的实现，关于插入删除大部分都调用这三个函数，实际上就是改变结点pre跟next指针的指向。 123456789101112131415161718192021222324252627282930313233iterator insert(iterator position, const T&amp; x) { link_type tmp = create_node(x); // 改变四个指针的指向 实际就是双向链表元素的插入 tmp-&gt;next = position.node; tmp-&gt;prev = position.node-&gt;prev; (link_type(position.node-&gt;prev))-&gt;next = tmp; position.node-&gt;prev = tmp; return tmp;}iterator erase(iterator position) { // 改变四个指针的指向 实际就是双向链表的元素删除 link_type next_node = link_type(position.node-&gt;next); link_type prev_node = link_type(position.node-&gt;prev); prev_node-&gt;next = next_node; next_node-&gt;prev = prev_node; destroy_node(position.node); return iterator(next_node);}// 将[first, last)插入到position位置(可以是同一个链表)void transfer(iterator position, iterator first, iterator last) { if (position != last) { // 实际上也是改变双向链表结点指针的指向 具体操作看下图 (*(link_type((*last.node).prev))).next = position.node; (*(link_type((*first.node).prev))).next = last.node; (*(link_type((*position.node).prev))).next = first.node; link_type tmp = link_type((*position.node).prev); (*position.node).prev = (*last.node).prev; (*last.node).prev = (*first.node).prev; (*first.node).prev = tmp; }} list的对外接口： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091void push_front(const T&amp; x) { insert(begin(), x); }void push_back(const T&amp; x) { insert(end(), x); }void pop_front() { erase(begin()); }void pop_back() { iterator tmp = end(); erase(--tmp);}void swap(list&lt;T, Alloc&gt;&amp; x) { __STD::swap(node, x.node); }// splice有很多重载版本// 將 x 接合於 position 所指位置之前。x 必須不同於 *this。void splice(iterator position, list&amp; x) { if (!x.empty()) transfer(position, x.begin(), x.end());}// 將 i 所指元素接合於 position 所指位置之前。position 和i 可指向同一個list。void splice(iterator position, list&amp;, iterator i) { iterator j = i; ++j; if (position == i || position == j) return; transfer(position, i, j);}// 將 [first,last) 內的所有元素接合於 position 所指位置之前。// position 和[first,last)可指向同一個list，// 但position不能位於[first,last)之內。void splice(iterator position, list&amp;, iterator first, iterator last) { if (first != last) transfer(position, first, last);}// merge函数实现跟归并排序中合并的操作类似template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::merge(list&lt;T, Alloc&gt;&amp; x) { iterator first1 = begin(); iterator last1 = end(); iterator first2 = x.begin(); iterator last2 = x.end(); // 注意：前提是，两个list都递增排列 while (first1 != last1 &amp;&amp; first2 != last2) if (*first2 &lt; *first1) { iterator next = first2; transfer(first1, first2, ++next); first2 = next; } else ++first1; if (first2 != last2) transfer(last1, first2, last2);}// reserse函数每次都调用transfer将结点插入到begin()之前template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::reverse() { if (node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) return; iterator first = begin(); ++first; while (first != end()) { iterator old = first; ++first; transfer(begin(), old, first); }}// list必须使用自己的sort()成员函数 因为STL算法中的sort()只接受RamdonAccessIterator// 该函数采用的是quick sorttemplate &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::sort() { // 空串和长度为1的 不用排序 if (node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) return; // 一些新的 lists，暂存 list&lt;T, Alloc&gt; carry; list&lt;T, Alloc&gt; counter[64]; int fill = 0; while (!empty()) { carry.splice(carry.begin(), *this, begin()); int i = 0; while(i &lt; fill &amp;&amp; !counter[i].empty()) { counter[i].merge(carry); carry.swap(counter[i++]); } carry.swap(counter[i]); if (i == fill) ++fill; } for (int i = 1; i &lt; fill; ++i) counter[i].merge(counter[i-1]); swap(counter[fill-1]);}","link":"/2023/03/05/stl-list/"},{"title":"STL - vector源码分析","text":"vector概述向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。 vector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率，即“配置新空间/数据移动/释放旧空间”的这个过程。 vector的主要定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// alloc 是SGI STL的空间配置器template&lt;class T,class Alloc=alloc&gt;class vector{ public: //vector的嵌套型别定义 typedef T value_type; typedef value_type* pointer; typedef value_type* iterator; typedef value_type* reference; typedef size_t size_type; typedef ptrdiff_t difference_type; protected: //simple_alloc 是SGI STL的空间配置器 typedef simple_alloc&lt;value_type,Alloc&gt; data_allocator; iterator start;//表示目前使用空间的头 iterator finish;//表示目前使用空间的尾 iterator end_of_storage;//表示目前可用空间的尾 void insert_aux(iterator position,const T&amp; x); void deallocate(){ if(start) data_allocator::deallocate(start,end_of_storage-start); } void fill_initialize(size_type n,const T&amp; value) { start=allocate_and_fill(n,value); finish=start+n; end_of_storage=finsih; } public: iterator begin(){return start;} iterator end(){return finish;} size_type size() const {return size_type(end()-begin());} size_type capacity() const {return size_type(end_of_storage-begin());} bool empty() const {return begin()==end();} reference operator[](size_type n) {return *(begin()+n);} vector():start(0),finish(0),end_of_storage(0){} vector(size_type n,const T&amp; value){fill_initialize(n,value);} vector(int n,const T&amp; value){fill_initialize(n,value);} vector(long n,const T&amp; value){fill_initialize(n,value);} explicit vector(size_type n){fill_initialize(n,T());} ~vector(){ destroy(start,finish); deallocate(); } reference front(){return *begin();}//第一个元素 reference back() {return *(end()-1);}//最后一个元素 void push_back(const T&amp; x){//将元素插入至最尾端 if(finish!=end_of_storage){ construct(finish,x); ++finish; } else insert_aux(end(),x); } void pop_back(){//将最尾端元素取出 --finish; destroy(finish);//全局函数 } iterator erase(iterator position){//清除某位置上的元素 if(position+1 !=end) { copy(position+1,finish,position);//后续元素往前移动 } --finish; destroy(finish); return position; } void resize(size_type new_size,const T&amp; x) { if(new_size&lt;size()) erase(begin()+new_size,end()); else insert(end(),new_size-size(),x); } void resize(size_type new_size){resize(new_size,T());} void clear() {erase(begin(),end());} protected: //配置空间并填满内容 iterator allocate_and_fill(size_type n,const T&amp; x) { iterator result=data_allocator::allocate(n); uninitialized_fill_n(result,n,x); return result; }}; 这么大一串代码看着头有点晕，那就上个图来表示吧： vector的迭代器vector维护的是一个连续的线性空间,由于是连续线性空间,所以其迭代器所要进行的一些操作比如:operator*,operator-&gt;,operator+,operator-,operator++,operator–等等普通的指针都可以满足所以vector的迭代器就是普通指针。通过普通指针也可让vector随机存取(所以vector的迭代器是Random Access Iterator). 迭代器的类型有5种： 123456输入迭代器input_iterator： 只读，且只能一次读操作，支持操作：++p,p++,!=,==,=*p,p-&gt;；输出迭代器output_iterator： 只写，且只能一次写操作，支持操作：++p,p++；正向迭代器forward_iterator： 可多次读写，支持输入输出迭代器的所有操作；双向迭代器bidirectional_iterator： 支持正向迭代器的所有操作，且支持操作：--p,--p；随机访问迭代器random_access_iterator： 除了支持双向迭代器操作外，还支持：p[n],p+n,n+p,p-n,p+=n,p-=n,p1-p2,p1&lt;p2,p1&gt;p2,p1&gt;=p2,p1&lt;=p2； vector源码中迭代器的定义如下： 123456template&lt;class T,class Alloc=alloc&gt;class vector{ public: typedef T value_type; typedef value_type* iterator;//vector的迭代器是普通指针}; 其实，iterator就是一个指针，即有以下代码。 12vector&lt;int&gt;::iterator ivite; // int*vector&lt;Shape&gt;::iterator svite; //Shape* vector的数据结构正如上面看到的，vector的数据结构如下代码，就是三根指针。vector所表示的是一片线形的连续空间，就相当于一个array，它以start和finish分别指向头和尾（左闭右开），表示连续区间内目前已经使用的范围，并以迭代器end_of_storage指向整块连续空间的尾端。 12345678template&lt;class T,class Alloc=alloc&gt;class vector{...protected: iterator start; iterator finish; iterator end_of_storage;}; 还是上面那张图：结合图像，我们可以看到，[start,finish)这块区域，就是已经放了元素的区域;而[finish,end_of_storage)这块区域则是没有放元素的备用空间。此时vector的大小是size，也就是finish-start，end_of_storage-start则是vector目前总共能放的元素个数。如果finish==end_of_storage，则说明现在这个vector是满了的，我们需要对其扩充空间。即：“配置新空间-&gt;数据移动-&gt;释放旧空间”这个动作，参考下图。 通过这三个迭代器,就可以实现很多操作,比如提供首尾标示,大小,容量,空容器判断,[ ]运算符,最前端元素,最后端元素等。 1234567891011121314template &lt;class T,class Alloc=alloc&gt;class vector{...public: iterator begin(){return start;} iterator end(){return finish;} size_type size() const {return size_type(end()-begin());} size_type capacity() const {return size_type(end_of_storage-begin());} bool empty() const {return begin()==end();} reference operator[](size_type n){return *(begin()+n);} reference front(){return *begin();} reference back() {return *(end()-1);}...}; vector的构造与析构vector提供了许多构造函数： 12345678910111213141516171819202122//默认构造函数vector():start(0),finish(0),end_of_storage(0){}//指定大小和初值vector(size_type n,const T&amp; value){fill_initialize(n,value);}vector(int n,const T&amp; value){fill_initialize(n,value);}vector(long n,const T&amp; value){fill_initialize(n,value);}explicit vector(size_type n){fill_initialize(n,T());} void fill_initialize(size_type n,const T&amp; value){ start=allocate_and_fill(n,value); finish=start+n; end_of_storage=finsih;}//配置空间并填满内容iterator allocate_and_fill(size_type n,const T&amp; x){ iterator result=data_allocator::allocate(n); uninitialized_fill_n(result,n,x); return result;} 对于指定大小和初值的构造方式，其是调用了fill_initialize()，fill_initialize()又调用了uninitialized_fill_n()，uninitialized_fill_n()会根据第一个参数的类别来判断是采用fill_n()还是反复调用construct()来完成vector的构造。 析构函数为：实现了调用析构函数和释放内存空间两个步骤。 1234~vector(){ destroy(start,finish); //全局函数，如果不是trival destructor，则一个个调用析构函数 deallocate(); // deallocate() is a member function of vector class} vector的扩容机制”配置新空间-&gt;数据移动-&gt;释放旧空间“这个动作一般发生于push_back()元素时，push_back()函数的作用为：将新元素插入到vector的尾端。该函数首先检查是否还有备用空间，如果有，则直接在备用空间上构造，并调整迭代器finish，使vector增大；如果没有备用空间了，则去扩充空间（配置新空间-&gt;数据移动-&gt;释放旧空间）。 push_back()的源码如下（此为GNU）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void push_back(const T&amp; x) { if (finish != end_of_storage) { //若当前还有备用空间 construct(finish, x); //将当前水位的值设为x ++finish; //提升水位 } else insert_aux(end(), x); }template &lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert_aux(iterator position, const T&amp; x) { if (finish != end_of_storage) { construct(finish, *(finish - 1)); ++finish; T x_copy = x; copy_backward(position, finish - 2, finish - 1); *position = x_copy; } else { const size_type old_size = size(); //获取之前数组的大小 //以上原则，如果原大小为0，则配置1（个元素） //如果原大小不为0，则配置原大小的两倍 //前半段用来放置原数据，后半段用来放置新数据 const size_type len = old_size != 0 ? 2 * old_size : 1; iterator new_start = data_allocator::allocate(len); //重新分配新数组的起始迭代器 iterator new_finish = new_start; __STL_TRY { new_finish = uninitialized_copy(start, position, new_start); //将旧数组的值重新分配给当前的新数组 construct(new_finish, x); //将当前数组的水位的值设为x ++new_finish; //提升新数组的水位 new_finish = uninitialized_copy(position, finish, new_finish); //这语句感觉可有可无，因为它根本就不会执行，position即last，而finish也是last } # ifdef __STL_USE_EXCEPTIONS catch(...) { //如果重新构造的新数组出现异常，则销毁当前新创建的数组，并释放内存空间 destroy(new_start, new_finish); data_allocator::deallocate(new_start, len); throw; }# endif /* __STL_USE_EXCEPTIONS */ destroy(begin(), end()); //将旧数组的空间释放掉 deallocate(); start = new_start; //new_start记录新数组的起始位置 finish = new_finish; //重新设置当前水位的指针 end_of_storage = new_start + len; //设置新数组的容量 }} 所谓动态增加大小，并不是在原空间之后接续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。 因此，对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了。 需要注意的是：不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。 vector的一些其他操作：pop_back,erase,clear,insert pop_back()源码:即finish回退一步，然后调用析构函数即可。 12345//将尾端元素拿掉，并调整大小void pop_back(){ --finish;//将尾端标记往前移动一格，表示将放弃尾端元素 destroy(finish);} erase()与clear()源码：要注意这里第一个erase的last并不会删除，制定first和last，删除的区间为[first,last)，因为stl的迭代器都是左闭右开的。 12345678910111213141516171819202122//清除[first,last)中的所有元素iterator erase(iterator first,iterator last){ //将[last,finish)前移动到[first,finish-(last-first)） iterator i=copy(last,finish,first); //析构之 destroy(i,finish); //调整水位 finish=finish-(last-first); return first;}//清除某位置上的元素iterator erase(iterator position){ if(position+1 !=end){ copy(position+1,finish,position);//后续元素往前移动 } --finish; destroy(finish); return position;}void clear() {erase(begin(),end());} erase()左闭右开测试程序，由此例可得出ed所指向内容不会被erase()，也可以这么想：如果传入end()为last，end()是不可以被析构的，所以last也不会被析构。 12345678910int main(){ vector&lt;int&gt; a = {0,1,2,3,4,5,6}; auto bg = ++a.begin(); // bg指向1 auto ed = --a.end(); --ed; // ed指向5 a.erase(bg,ed); for(auto &amp;i : a){ // ans : 0 5 6 cout &lt;&lt; i &lt;&lt; &quot; &quot;; }} insert()源码：和erase()类似，就是中间断开增加元素，需要拷贝很多值，效率较低。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//下面是vector::insert()实现内容//从position开始，插入n个元素，元素初值为xtemplate&lt;class T,class Alloc&gt;void vector&lt;T,Alloc&gt;::insert(iterator position,size_type n,const T&amp; x){ if(n!=0) { //当n！=0才进行以下操作 if(size_type(end_of_storage-finish)&gt;=n) { //备用空间大于等于“新增元素个数” T x_copy=x; //以下计算插入点之后的现有元素个数 const size_type elems_after=finish-position; iterator old_finish=finish; if(elems_after&gt;n) { //“插入点之后的现有元素个数”大于“新增元素个数” uninitialized_copy(finish-n,finish,finish); finish+=n;//将vector尾端标记后移 copy_backward(position,old_finish-n,old_finish); fill(position,position+n,x_copy);//从插入点开始填入新值 } else{ //“插入点之后的现有元素个数”小于等于“新增元素个数” uninitialized_fill_n(finish,n-eles_after,x_copy); finish+=n-elems_after; uninitialized_copy(position,old_finish,finish); finish+=elems_after; fill(position,old_finish,x_copy); } } else{ //备用空间小于“新增元素个数”（那就必须配置额外的内存） //首先决定新长度：旧长度的两倍，或旧长度+新增元素个数 const size_type old_size=size(); const size_type len=old_size+max(old_size,n); //配置新的vector空间 iterator new_start=data_allocator::allocate(n); iterator new_finish=new_start; __STL_TRY{ //以下首先将旧vector的插入点之前的元素复制到新空间 new_finish=uninitialized_copy(start,position,new_start); //以下再将新增元素（初值皆为n）填入新空间 new_finish=uninitialized_fill_n(new_finish,n,x); //以下再将旧vector的插入点之后的元素复制到新空间 new_finish=uninitialized_copy(position,finish,new_finish); } #ifdef __STL_USE_EXCEPTIONS catch(...){ //如有异常发生，实现“commit or rollback” semantics destroy(new_start,new_finish); data_allocator::deallocate(new_start,len); throw; } #endif /*__STL_USE_EXCEPTIONS*/ //以下清除并释放旧的vector destroy(start,finish); deallocate(); //以下调整水位标记 start=new_start; finish=new_finish; end_of_storage=new_start+len; } }} vector常见question： 为什么要成倍的扩容而不是一次增加一个固定大小的容量呢？ 可参考：https://www.drdobbs.com/c-made-easier-how-vectors-grow/184401375 1234567891011121314以成倍方式增长 假定有 n 个元素,倍增因子为 m；完成这 n 个元素往一个 vector 中的 push_back 操作，需要重新分配内存的次数大约为 logm(n)；第 i 次重新分配将会导致复制 m^(i) (也就是当前的vector.size() 大小)个旧空间中元素;n 次 push_back 操作所花费的时间复制度为O(n): m / (m - 1)，这是一个常量，均摊分析的方法可知，vector 中 push_back 操作的时间复杂度为常量时间.一次增加固定值大小 假定有 n 个元素,每次增加k个；第i次增加复制的数量为为：100in 次 push_back 操作所花费的时间复杂度为O(n^2): 均摊下来每次push_back 操作的时间复杂度为O(n)；总结：对比可以发现采用采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容 为什么是以两倍的方式扩容而不是三倍四倍，或者其他方式呢？ 可参考：https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md 其实VC的1.5倍扩容是更佳的。 It is well known that std::vector grows exponentially (at a constant factor) in order to avoid quadratic growth performance. The trick is choosing a good factor. Any factor greater than 1 ensures O(1) amortized append complexity towards infinity. But a factor that’s too small (say, 1.1) causes frequent vector reallocation, and one that’s too large (say, 3 or 4) forces the vector to consume much more memory than needed. The initial HP implementation by Stepanov used a growth factor of 2; i.e., whenever you’d push_back into a vector without there being room, it would double the current capacity. This was not a good choice: it can be mathematically proven that a growth factor of 2 is rigorously the worst possible because it never allows the vector to reuse any of its previously-allocated memory. Despite other compilers reducing the growth factor to 1.5, gcc has staunchly maintained its factor of 2. This makes std::vector cache- unfriendly and memory manager unfriendly. ​ 当使用2作为倍数增长时，每次扩展的尺寸的刚好大于之前所分配的总和。换而言之，之前分配的内存空间不可以被使用，对缓存不友好。 1.5倍增长和2倍增长对比： 3. vector与list的区别与应用？区别：应用：vector 拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在 乎插入和删除的效率，使用 vector。list 拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用 list。 resize和reserve区别？ 参考：https://www.cnblogs.com/cxl-/p/14482639.html vector？ vector是vector的一个特化版本，之前一个byte存一个bool，在vector的设计中一个byte存8个bool，用一个bit来表示true和false。 详细的以后再说。 参考文献： [1] https://blog.csdn.net/vjhghjghj/article/details/88713401 [2] https://blog.csdn.net/sinat_33442459/article/details/75142672 [3] https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md [4] https://www.drdobbs.com/c-made-easier-how-vectors-grow/184401375 [5] 侯捷.STL源码剖析[M].武汉：华中科技大学出版社，2002.6：115-128.","link":"/2023/03/05/stl-vector/"},{"title":"STL - 分配器 allocators","text":"1 C++ 内存配置操作和释放操作123class FOO{};FOO *pf = new FOO; delete pf; 对于上述代码，其在底层执行内容为： line 2：new操作，首先调用::operator new分配内存 （2）调用Foo::Foo() 构造对象内容; ::operator new底层调用malloc分配内存。 line 3：delete操作，首先调用Foo::~Foo()将对象析构 （2）调用::operator delete释放内存; ::operator delete底层调用free释放内存。 出于分工的考量，STL 的allocators决定将这两个阶段分开。分别用 4 个函数来实现： 内存的配置：alloc::allocate(); 对象的构造：::construct(); 对象的析构：::destroy(); 内存的释放：alloc::deallocate(); 2 construct()和destroy()construct()和destroy()主要负责对象的构造与析构。 construct()的源码为： 1234template &lt;class T1, class T2&gt;inline void construct(T1* p, const T2&amp; value) { new (p) T1(value); //用placement new在 p 所指的对象上创建一个对象，value是初始化对象的值。} destory()的源码为： 1234567891011121314151617181920212223242526272829template &lt;class T&gt;inline void destroy(T* pointer) { pointer-&gt;~T(); //只是做了一层包装，将指针所指的对象析构---通过直接调用类的析构函数}template &lt;class ForwardIterator&gt; //destory的泛化版，接受两个迭代器为参数inline void destroy(ForwardIterator first, ForwardIterator last) { __destroy(first, last, value_type(first)); //调用内置的 __destory(),value_type()萃取迭代器所指元素的型别}template &lt;class ForwardIterator, class T&gt;inline void __destroy(ForwardIterator first, ForwardIterator last, T*) { typedef typename __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor; __destroy_aux(first, last, trivial_destructor()); //trival_destructor()相当于用来判断迭代器所指型别是否有 trival destructor}template &lt;class ForwardIterator&gt;inline void //如果无 trival destructor ，那就要调用destroy()函数对两个迭代器之间的对象元素进行一个个析构__destroy_aux(ForwardIterator first, ForwardIterator last, __false_type) { for ( ; first &lt; last; ++first) destroy(&amp;*first);}template &lt;class ForwardIterator&gt; //如果有 trival destructor ，则什么也不用做。这更省时间inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type) {}inline void destroy(char*, char*) {} //针对 char * 的特化版inline void destroy(wchar_t*, wchar_t*) {} //针对 wchar_t*的特化版 construct()比较好理解，就是直接调用new操作。 destory()的话就比较复杂，主要在于其有很多的特化版本（泛化、特化、偏特化可以百度了解），主要有以下版本： 泛化版本 __destroy() （ForwardIterator, ForwardIterator）: 根据是否是trival destructor（无关痛痒的析构函数）来进行选择 1.1 特化版本（false）：__destroy_aux(ForwardIterator first, ForwardIterator last, __false_type)，即for循环一个个调用析构函数来析构。 1.2 特化版本（true）：__destroy_aux(ForwardIterator, ForwardIterator, __true_type) {}，无关痛痒，什么都不做 特化版本：（T *）对于传入一个对象的指针，直接调用析构函数 特化版本：（char *, char *）char*型，什么都不做 特化版本：（wchar_t *,wchar_t *）wchar_t *型，什么都不做 有这么多特化版本的原因还是因为trival destructor，对于trival destructor执行和不执行都一样，因此去执行那些trival destructor是很吃力不讨好的。 3 allocate()和deallocate()allocate()和deallocate()主要负责与内存分配与释放相关的动作。 在STL源码中，allocate转调用::operator new实现，deallocate转调用::operator delete实现。 调用链路可理解为： 调用allocate分配内存-&gt;调用::operator new分配内存-&gt;调用malloc分配内存 调用deallocate释放内存-&gt;调用::operator delete释放内存-&gt;调用free释放内存 SGI对空间的配置和释放的设计哲学为： 向 system heap 要求空间 考虑多线程状态 考虑内存不足时的应变措施 考虑过多“小型区块”可能造成的内存碎片问题。 考虑到小型区块会导致内存破碎问题，SGI STL设计了一个双层级配置器。 其代码如下： 123456# ifdef __USE_MALLOCtypedef __malloc_alloc_template&lt;0&gt; malloc_alloc;typedef malloc_alloc alloc; //使用第一级配置器# elsetypedef __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, 0&gt; alloc; // 使用第二级配置器# endif 因为SGI使用了双层级配置器，因此需要对外提供一个接口，从而符合标准： 12345678910111213template&lt;class T, class Alloc&gt;class simple_alloc {public: static T *allocate(size_t n) { return 0 == n? 0 : (T*) Alloc::allocate(n * sizeof (T)); } static T *allocate(void) { return (T*) Alloc::allocate(sizeof (T)); } static void deallocate(T *p, size_t n) { if (0 != n) Alloc::deallocate(p, n * sizeof (T)); } static void deallocate(T *p) { Alloc::deallocate(p, sizeof (T)); }}; 对于足够大和足够小的定义决定了应该使用哪一级配置器，对于SGI STL而言，小于等于128bytes视为足够小。当配置区块超过 128 bytes时，调用第一级配置器。当配置区块小于 128 bytes时，采取第二级配置器。 第一层配置器直接使用malloc()和free()。 第二层配置器则使用 memory pool 的方式。 3.1 第一级配置器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//以下是第一级配置器template &lt;int inst&gt;class __malloc_alloc_template {private://以下函数用来处理内存不足的情况static void *oom_malloc(size_t);static void *oom_realloc(void *, size_t);static void (* __malloc_alloc_oom_handler)();public:static void * allocate(size_t n){ void *result = malloc(n); //第一级配置器，直接使用malloc() //如果内存不足，则调用内存不足处理函数oom_alloc()来申请内存 if (0 == result) result = oom_malloc(n); return result;}static void deallocate(void *p, size_t /* n */){ free(p); //第一级配置器直接使用 free()}static void * reallocate(void *p, size_t /* old_sz */, size_t new_sz){ void * result = realloc(p, new_sz); //第一级配置器直接使用realloc() //当内存不足时，则调用内存不足处理函数oom_realloc()来申请内存 if (0 == result) result = oom_realloc(p, new_sz); return result;}//设置自定义的out-of-memory handle就像set_new_handle()函数static void (* set_malloc_handler(void (*f)()))(){ void (* old)() = __malloc_alloc_oom_handler; __malloc_alloc_oom_handler = f; return(old);}};template &lt;int inst&gt;void (* __malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)() = 0; //内存处理函数指针为空，等待客户端赋值template &lt;int inst&gt;void * __malloc_alloc_template&lt;inst&gt;::oom_malloc(size_t n){ void (* my_malloc_handler)(); void *result; for (;;) { //不断尝试释放、配置、再释放、再配置 my_malloc_handler = __malloc_alloc_oom_handler; //设定自己的oom(out of memory)处理函数 if (0 == my_malloc_handler) { __THROW_BAD_ALLOC; } //如果没有设定自己的oom处理函数，毫不客气的抛出异常 (*my_malloc_handler)(); //设定了就调用oom处理函数 result = malloc(n); //再次尝试申请 if (result) return(result); }}template &lt;int inst&gt;void * __malloc_alloc_template&lt;inst&gt;::oom_realloc(void *p, size_t n){ void (* my_malloc_handler)(); void *result; for (;;) { my_malloc_handler = __malloc_alloc_oom_handler; if (0 == my_malloc_handler) { __THROW_BAD_ALLOC; } //如果自己没有定义oom处理函数，则编译器毫不客气的抛出异常 (*my_malloc_handler)(); //执行自定义的oom处理函数 result = realloc(p, n); //重新分配空间 if (result) return(result); //如果分配到了，返回指向内存的指针 }} 上述代码的流程为： 通过allocate()申请内存，通过deallocate()来释放内存，通过reallocate()重新分配内存。 当allocate()或reallocate()分配内存不足时会调用oom_malloc()或oom_remalloc()来处理。 当oom_malloc() 或 oom_remalloc()还是没能分配到申请的内存时，会转入以下两步中的一步： 3.1 调用用户自定义的内存分配不足处理函数(这个函数通过set_malloc_handler() 来设定)，然后继续申请内存。 3.2 如果用户未定义内存分配不足处理函数，程序就会抛出bad_alloc异常或利用exit(1)终止程序。 3.2 第二级配置器在第二级配置器中，SGI 第二层配置器定义了一个 free-lists，这个free-list是一个数组，各自管理大小分别为8,16,24,32,40….128bytes的小额区块。 free-list节点结构为： 1234union obj{ union obj * free_list_link; char client_date[1]; }; 第二级配置器的部分实现源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192template &lt;bool threads, int inst&gt;class __default_alloc_template {private: // Really we should use static const int x = N // instead of enum { x = N }, but few compilers accept the former.# ifndef __SUNPRO_CC enum {__ALIGN = 8}; //小型区块上调边界 enum {__MAX_BYTES = 128}; // 小型区块的上界 enum {__NFREELISTS = __MAX_BYTES/__ALIGN}; // free-list的节点个数# endif // 将bytes上调至8的倍数 static size_t ROUND_UP(size_t bytes) { return (((bytes) + __ALIGN-1) &amp; ~(__ALIGN - 1)); }__PRIVATE: union obj { union obj * free_list_link; char client_data[1]; /* The client sees this. */ };private: //16个free-list static obj * __VOLATILE free_list[__NFREELISTS]; //根据大小计算该用哪个区块，32-&gt;3 static size_t FREELIST_INDEX(size_t bytes) { return (((bytes) + __ALIGN-1)/__ALIGN - 1); } // Returns an object of size n, and optionally adds to size n free list. static void *refill(size_t n); // Allocates a chunk for nobjs of size &quot;size&quot;. nobjs may be reduced // if it is inconvenient to allocate the requested number. static char *chunk_alloc(size_t size, int &amp;nobjs); // Chunk allocation state. static char *start_free; //内存池起始位置，只在chunk_alloc()中变化。 static char *end_free; //内存池结束位置，只在chunk_alloc()中变化。 static size_t heap_size;public: /* n must be &gt; 0 */ static void * allocate(size_t n) { obj * __VOLATILE * my_free_list; obj * __RESTRICT result; if (n &gt; (size_t) __MAX_BYTES) { return(malloc_alloc::allocate(n)); } my_free_list = free_list + FREELIST_INDEX(n); // Acquire the lock here with a constructor call. // This ensures that it is released in exit or during stack // unwinding.# ifndef _NOTHREADS /*REFERENCED*/ lock lock_instance;# endif result = *my_free_list; if (result == 0) { void *r = refill(ROUND_UP(n)); return r; } *my_free_list = result -&gt; free_list_link; return (result); }; /* p may not be 0 */ static void deallocate(void *p, size_t n) { obj *q = (obj *)p; obj * __VOLATILE * my_free_list; if (n &gt; (size_t) __MAX_BYTES) { malloc_alloc::deallocate(p, n); return; } my_free_list = free_list + FREELIST_INDEX(n); // acquire lock# ifndef _NOTHREADS /*REFERENCED*/ lock lock_instance;# endif /* _NOTHREADS */ q -&gt; free_list_link = *my_free_list; *my_free_list = q; // lock is released here } static void * reallocate(void *p, size_t old_sz, size_t new_sz);} ; 第二级配置器的结构： 3.2.1 allocate()allocate()的源码： 1234567891011121314151617181920static void * allocate(size_t n){ obj * __VOLATILE * my_free_list; obj * __RESTRICT result; //要申请的空间大于128bytes就调用第一级配置 if (n &gt; (size_t) __MAX_BYTES) { return(malloc_alloc::allocate(n)); } //寻找 16 个free lists中恰当的一个 my_free_list = free_list + FREELIST_INDEX(n); result = *my_free_list; if (result == 0) { //没找到可用的free list，准备新填充free list void *r = refill(ROUND_UP(n)); return r; } *my_free_list = result -&gt; free_list_link; return (result);}; ROUND_UP函数源码如下，其作用为：将要申请的内存字节数上调为8的倍数。 123static size_t ROUND_UP(size_t bytes) { return (((bytes) + __ALIGN-1) &amp; ~(__ALIGN - 1));} refill函数源码如下，其作用为：向内存池申请20块大小为n的一大块内存，将其挂在free-list上，并返回之。这个refill函数如allocate中所描述，就是在没找到可用的free-list时使用的，即我想要一块大小为32bytes的内存，然而发现没有了，此时就调用refill，去申请20个32bytes的内存以供使用。 12345678910111213141516171819202122232425262728293031/* Returns an object of size n, and optionally adds to size n free list.*//* We assume that n is properly aligned. *//* We hold the allocation lock. */template &lt;bool threads, int inst&gt;void* __default_alloc_template&lt;threads, inst&gt;::refill(size_t n){ int nobjs = 20; char * chunk = chunk_alloc(n, nobjs); obj * __VOLATILE * my_free_list; obj * result; obj * current_obj, * next_obj; int i; if (1 == nobjs) return(chunk); my_free_list = free_list + FREELIST_INDEX(n); /* Build free list in chunk */ result = (obj *)chunk; *my_free_list = next_obj = (obj *)(chunk + n); for (i = 1; ; i++) { current_obj = next_obj; next_obj = (obj *)((char *)next_obj + n); if (nobjs - 1 == i) { current_obj -&gt; free_list_link = 0; break; } else { current_obj -&gt; free_list_link = next_obj; } } return(result);} 3.2.2 deallocate()deallocate()的实现则较为简单，等同于一个链表插入操作，源码如下： 12345678910111213141516static void deallocate(void *p, size_t n){ obj *q = (obj *)p; obj * __VOLATILE * my_free_list; //如果要释放的字节数大于128，则调第一级配置器 if (n &gt; (size_t) __MAX_BYTES) { malloc_alloc::deallocate(p, n); return; } //寻找对应的位置 my_free_list = free_list + FREELIST_INDEX(n); //以下两步将待释放的块加到链表上 q -&gt; free_list_link = *my_free_list; *my_free_list = q;} 参考文献： [1] 侯捷.STL源码剖析[M].武汉：华中科技大学出版社，2002.6：43-69. [2] https://www.cnblogs.com/zhuwbox/p/3699977.html","link":"/2023/03/05/stl-allocators/"},{"title":"CPP - const限定符","text":"const修饰的变量，它的值不能被改变。只能执行不改变其内容的操作。const修饰的变量一样能进行算数运算等操作。 1const int bufSize = 512; 如果对其进行修改，则会引发错误。 1bufSize = 1024; //error const对象必须初始化 const修饰不具有传递性 1234567const int j = get_size(); //correctconst int j = 42; //correctconst int k; // errorint i = 1024;const int ci = i; //correctint j = ci; //correct 默认状态下，const对象仅在文件内有效 编译时，编译器将变量替换成对应的值（类似于define），因为const对象仅在文件内有效，如果要让其他文件访问到，需要添加extern关键字。 1234//file1.cc 定义并初始化一个常量，它可以被其他文件访问extern const int bufSize = fcn();//file1.h 头文件extern const int bufSize; // 与file1.cc的相同 对常量的引用（reference to const）：把引用绑定到const对象上。对常量的引用不可以修改它所绑定的对象。 1234const int ci =1024;const int &amp;r1 = ci; //correctr1 = 41; //errorint &amp;r2 = ci; //correct,r2非常量引用 对const的引用的初始化： 初始化常量引用可以用任何表达式作为初始值 1234int i = 42;const int &amp;r1 = i; //correctconst int &amp;r2 = r1*2; //correctint &amp;r3 = r1*2; //error，结合下文，error原因为绑定的为一个临时量对象， 解释： 假设有如下代码： 12double dval = 3.14;const int &amp;ri = dval; dval为双精度浮点数，为了确保让ri绑定上一个整数，编译器将上述代码变成如下形式： 12const int temp = dval; //由浮点数生产一个临时的整形变量const int &amp;ri = temp; ri绑定了一个临时量对象。这个临时量对象是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。 对const的引用可能引用一个并非const的对象 12345int i = 42;int &amp;r1 = i;const int &amp;r2 = i;r1 = 0; //correctr2 = 0; //error 指向常量的指针（pointer to const） 要想存放常量对象的地址，必须使用指向常量的指针。 1234const double pi = 3.14;double *ptr = &amp;pi; //errorconst double *cptr = &amp;pi; //correct*cptr = 1; //error 对象的值能不能改变，还得看自身是不是const，引用和指针的const是保证自己不去改变变量的值。 const指针：指针是一个对象，因此可以将指针定义为const。 常量指针（const pointer）必须初始化，一旦初始化完成，他的值（指向的地址）就不能改变。 *放const之前，说明指针是一个常量（另一层意思：指针本身的值不变，指向的值可以变） 12345int errNum = 0;int *const curErr = &amp;errNum; //curErr一直指向errNumconst double pi = 3.14;const double *const pop = &amp;pi; // pop是一个指向常量对象的常量指针//阅读方法：从右往左读 顶层const 顶层const：指针本身是个常量（靠近变量） 底层const：指针所指对象是一个常量","link":"/2023/03/05/cpp-const/"},{"title":"CPP - 操作符重载！看这篇就够了！","text":"实现一个操作符重载的方式通常有两种情况： 将操作符重载实现为类的成员函数。 操作符重载实现为非类的成员函数（即全局函数）。 将操作符重载实现为类的成员函数 在类体中声明（定义）需要重载的操作符，声明方式跟普通的成员函数一样，只不过操作符重载函数的名字是“关键字operator +以及紧跟其后的一个C++预定义的操作符”。参数则需要传入除自己以外的别的参数（比如==需要两个参数，即自身和另一个对象，因此传入另一个对象即可，自身就是this）。 形式即如下(Student为自定义类)： 1bool operator==(const Student &amp;student){} 此处要注意输入输出操作（&lt;&lt; and &gt;&gt;）的重载方式有所不同，需要使用友元函数，形式如下： 1friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Student &amp;student) 操作符重载实现为非类的成员函数 对于全局重载操作符，代表左操作数的参数必须被显式指定。 形式如下： 1bool operator&gt;(Student &amp;student, Student &amp;student1) 可以根据以下因素，确定把一个操作符重载为类的成员函数还是全局函数： 如果一个重载操作符是类成员，那么只有当与它一起使用的左操作数是该类的对象时，该操作符才会被调用；而如果该操作符的左操作数确定为其他的类型，则操作符必须被重载为全局函数； C++要求’=’、’[]’、’()’、’-&gt;’操作符必须被定义为类的成员操作符，把这些操作符通过全局函数进行重载时会出现编译错误 如果有一个操作数是类类型（如string类），那么对于对称操作符（比如==操作符），最好通过全局函数的方式进行重载。 实现操作符重载时，需要注意有如下限制： 重载后操作符的操作数至少有一个是用户定义类型； 不能违反原来操作数的语法规则； 不能创建新的操作符； 不能重载的操作符包括（以空格分隔）：sizeof . .* :: ?: RTTI类型运算符 =、()、[]、以及 -&gt;操作符只能被类的成员函数重载 下面给出示例代码，其中使用全局函数的为重载&gt;。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;using namespace std;class Student {public: int sno; string name; Student(int s = 0, string n = &quot;&quot;) : sno(s), name(n) {} bool operator==(const Student &amp;student) { if (sno == student.sno) return true; return false; } // 将操作符重载实现为类的成员函数 bool operator&lt;(const Student &amp;student) { if (sno &lt; student.sno) return true; return false; } // ++student 前缀形式 Student &amp;operator++() { sno++; return *this; } // student++ 后缀形式 Student operator++(int) { Student student(sno, name); sno++; return student; } friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Student &amp;student) { os &lt;&lt; student.sno &lt;&lt; &quot; &quot; &lt;&lt; student.name; return os; } friend istream &amp;operator&gt;&gt;(istream &amp;is, Student &amp;student) { cout &lt;&lt; &quot;input sno:&quot;; is &gt;&gt; student.sno; cout &lt;&lt; &quot;input name:&quot;; is &gt;&gt; student.name; return is; }};// 操作符重载实现为非类的成员函数bool operator&gt;(Student &amp;student, Student &amp;student1) { if (student.sno &gt; student1.sno) return true; return false;}int main() { Student student_a; cin &gt;&gt; student_a; cout &lt;&lt; &quot;your input: &quot; &lt;&lt; student_a &lt;&lt; endl; Student student_b = student_a++; cout &lt;&lt; &quot;student_a: &quot; &lt;&lt; student_a &lt;&lt; endl; cout &lt;&lt; &quot;student_b: &quot; &lt;&lt; student_b &lt;&lt; endl; cout &lt;&lt; &quot;student_a &lt; student_b: &quot; &lt;&lt; (student_a &lt; student_b) &lt;&lt; endl; cout &lt;&lt; &quot;student_a &gt; student_b: &quot; &lt;&lt; (student_a &gt; student_b) &lt;&lt; endl; cout &lt;&lt; &quot;student_a == student_b: &quot; &lt;&lt; (student_a == student_b) &lt;&lt; endl; cout &lt;&lt; endl; Student student_c = ++student_a; cout &lt;&lt; &quot;student_a: &quot; &lt;&lt; student_a &lt;&lt; endl; cout &lt;&lt; &quot;student_c: &quot; &lt;&lt; student_c &lt;&lt; endl; cout &lt;&lt; &quot;student_a &lt; student_c: &quot; &lt;&lt; (student_a &lt; student_c) &lt;&lt; endl; cout &lt;&lt; &quot;student_a &gt; student_c: &quot; &lt;&lt; (student_a &gt; student_c) &lt;&lt; endl; cout &lt;&lt; &quot;student_a == student_c: &quot; &lt;&lt; (student_a == student_c) &lt;&lt; endl;} 结果如下：","link":"/2023/03/05/cpp-operator-override/"},{"title":"CPP - 处理类型","text":"类型别名类型别名是一个名字，是某种类型的同义词。使用类型别名可以使复杂的类型名字变得简单明了。 12typedef double wages;typedef wages base, *p; //base=double,p=double* C++11中支持新方法： 1using wages = double; auto类型说明符C++11标准，编译器通过初始值推算变量的类型。（auto定义的变量必须具有初始值） 12auto i = 0, *p = &amp;i; //correctauto sz = 0, pi = 3.14; //error decltype类型指示符希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。 1decltype(f()) sum = x; //sum的类型就是函数f的返回类型","link":"/2023/03/05/cpp-type/"},{"title":"CPP - 引用&amp;指针","text":"引用 引用(reference)为对象起了另外一个名字，引用类型引用(refers to)另外一种类型。通过将声明符写成 &amp;d 的形式来定义引用类型型,其中 d 是声明的变量名。在初始化变量时，会出现初始值拷贝现象，定义引用则将引用与初始值对象绑定在一起。 引用必须初始化（类型必须严格匹配） 引用并不是对象，而是给一个已经存在的对象起另一个名字（这个对象必须存在，不可为字面值[10,”10”…]） 1234int &amp;refVal = 0; //errordouble dval = 3.14;int &amp;refVal2 = dval; //error 指针 指针(pointer)是’”指向(point to)“另外一种类型型的复合类型。定义指针类型的方法将声明符写成d的形式,其中d是变量名。 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。 指针无须在定义时赋初值。 使用取地址符（ &amp; ）可以取得存放某个对象的地址。 类型必须严格匹配 12double dval = 3.14;int *p = &amp;dval; 指针的值(即地址)应属下列4种状态之一: 指向一个对象。 指向紧邻对象所占空间的下一个位置。 空指针,意味着指针没有指向任何对象。 无效指针,也就是上述情况之外的其他值。 利用指针访问对象 如果指针指向了一个对象，则可以用解引用符（*）来访问该对象。 12345int ival = 42;int *p = &amp;ival; //声明指针*p = 0; //改变对象内容cout&lt;&lt; *p; //输出0 解引用符只适用于确指向了某个对象的有效指针 空指针 空指针不指向任何对象，在试图使用一个指针之前可以检查其是否为空。 123int *p1 = nullptr; //C++11int *p2 = 0;int *p3 = NULL; //cstdlib void* 指针 void *是一种特殊的指针类型，可用于存放任意对象的地址。存放的也仅仅就是一个地址。 12double obj = 3.14;void *pv = &amp;obj; 不能直接操作相关void *所指向的对象。 指向指针的指针 通过*的个数区分指针的级别。 123int ival = 1024;int *pi = &amp;ival; //指向intint **ppi = &amp;pi; //指向一个int指针 指向指针的引用 引用不是对象，指针是对象，因此不存在指向引用的指针，只存在指向指针的引用。 123456int i = 42;int *p;int *&amp;r = p; //对int指针的引用r = &amp;i; //r是一个int指针，即r指向i*r = 0; //解引用r得到i 如何理解r的类型是什么？ 从右往左阅读，越靠近r的对r有最直接影响（*&amp;r -&gt; &amp; -&gt; r为一个指针）","link":"/2023/03/05/cpp-reference-pointer/"},{"title":"STL - STL概述","text":"1 STL概述 容器 Containers：STL内部封装好的数据结构，一种class template，常用的包括vector、list、deque、set、map、multiset、multimap等 分配器 Allocators：负责空间配置与管理。是一个实现了动态空间配置、空间管理、空间释放的class template。一般SGI STL为每一个容器都指定其缺省的空间配置器为alloc（SGI配置器） 算法 Algorithms：一种function template，常用的有sort、search、copy、erase等 迭代器 Iterators：泛型指针，是一种智能指针，是一种将operator*，operator-&gt;，operator++，operator–等指针相关操作予以重载的class template。所有STL容器都附带自己的迭代器 适配器 Adapters：一种用来修饰容器(container)或仿函数(functor)或迭代器(iterator)接口的东西。如queue和stack。它们的底部完全借助deque，所有操作都由底层的deque供应。改变functor接口者，称为functor adapter，改变container接口者，称为container adapter；改变iterator接口者，称为iterator adapter。 仿函数 Functors：行为类似函数，就是使一个类的使用看上去象一个函数，具有可配接性。它的具体实现就是通过在类中重载了operator()，使这个类具有了类似函数的行为，就是一个仿函数类了。一般函数指针、回调函数可视为狭义的仿函数。分为算术运算、关系运算、逻辑运算三大类。这部分内建的仿函数，均放在头文件里，使用时需引入头文件。 给出如下示例，在例子中，对应上述六大组件有： 容器：vector 分配器：allocator 迭代器：begin(),end() 算法：count_if 适配器：not1,bind2nd 仿函数：less 123456789void test_all_components(){ int ia[7] = { 27, 210, 12, 47, 109, 83, 40 }; vector&lt;int,allocator&lt;int&gt;&gt; vi(ia,ia+7); cout &lt;&lt; count_if(vi.begin(), vi.end(), not1(bind2nd(less&lt;int&gt;(), 40)));//5 cout &lt;&lt; endl; }","link":"/2023/03/05/stl-intro/"},{"title":"STL - STL的编程范式","text":"2 STL的编程范式OOP(Object-Oriented Programming)：面向对象 数据和操作在同一个类;OOP企图将datas和methods关联在一起 12345template&lt;class T, class Alloc = alloc&gt;class list{ ... void sort();} GP(Generic Programming)：泛型编程 datas和methods分隔开，即algorithm和contains分隔开，通过iterator交互。 12template&lt;typename _RandomAccessIterator&gt;inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __end) STL采用GP的原因： Containers和Algorithms团队刻个字闭门造车，Iterators团队沟通。 Algorithms通过Iterators确定操作范围，并通过Iterators取用Containers元素。 例子： 有算法（Algorithms）如下： 1234template&lt;class T&gt;inline const min T&amp;(const T&amp; a, const T&amp; b){ return b &lt; a ? b : a;} 如果要对一个自定义类进行大小比较，则可以重载**&lt;**，或者写个Compare函数。这样，算法就有了其通用性，而无需关心容器是什么。 泛化、特化、偏特化特化即特殊化，即设计者认为对于制定类型，使用特定版本更好。 全特化就是限定死模板实现的具体类型。 偏特化就是如果这个模板有多个类型，那么只限定其中的一部分。 优先级：全特化类&gt;偏特化类&gt;主版本模板类 123456789101112131415161718192021222324252627//泛化Template &lt;class type&gt; Struct __type_traits{typedef __true_type this_dummy_member_must_be_first; };//特化1Template &lt; &gt; Struct __type_traits&lt;int&gt;{typedef __true_type this_dummy_member_must_be_first; };//特化2Template &lt; &gt; Struct __type_traits&lt;double&gt;{typedef __true_type this_dummy_member_must_be_first; };//__type_traits&lt;FOO&gt;:: this_dummy_member_must_be_first; 使用的是泛化的内容//泛化Template &lt;class T, class Alloc = alloc&gt; Class vecor{};//偏特化(个数偏特化，第一个特化，第二个不特化)Template &lt;class Alloc&gt;Class vector&lt;bool, Alloc&gt;{};//泛化Template &lt;class Iterator&gt;Struct iterator_traits {};//偏特化1（范围偏特化，只能是传入指针）Template &lt;class T&gt;Struct iterator_traits&lt;T*&gt;{};//偏特化2Template &lt;class T&gt;Struct iterator_traits&lt;const T*&gt;{}; 为什么list不能使用::sort函数 list底层数据结构为链表，不支持随机访问（random access），所以list这个Containers中，有自带的sort方法。 ::sort接口为： 12345sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp){ typedef typename __comp_ref_type&lt;_Compare&gt;::type _Comp_ref; _VSTD::__sort&lt;_Comp_ref&gt;(__first, __last, _Comp_ref(__comp));} list.sort为，可以看到为链表的归并排序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162template &lt;class _Tp, class _Alloc&gt;template &lt;class _Comp&gt;typename list&lt;_Tp, _Alloc&gt;::iteratorlist&lt;_Tp, _Alloc&gt;::__sort(iterator __f1, iterator __e2, size_type __n, _Comp&amp; __comp){ switch (__n) { case 0: case 1: return __f1; case 2: if (__comp(*--__e2, *__f1)) { __link_pointer __f = __e2.__ptr_; base::__unlink_nodes(__f, __f); __link_nodes(__f1.__ptr_, __f, __f); return __e2; } return __f1; } size_type __n2 = __n / 2; iterator __e1 = _VSTD::next(__f1, __n2); iterator __r = __f1 = __sort(__f1, __e1, __n2, __comp); iterator __f2 = __e1 = __sort(__e1, __e2, __n - __n2, __comp); if (__comp(*__f2, *__f1)) { iterator __m2 = _VSTD::next(__f2); for (; __m2 != __e2 &amp;&amp; __comp(*__m2, *__f1); ++__m2) ; __link_pointer __f = __f2.__ptr_; __link_pointer __l = __m2.__ptr_-&gt;__prev_; __r = __f2; __e1 = __f2 = __m2; base::__unlink_nodes(__f, __l); __m2 = _VSTD::next(__f1); __link_nodes(__f1.__ptr_, __f, __l); __f1 = __m2; } else ++__f1; while (__f1 != __e1 &amp;&amp; __f2 != __e2) { if (__comp(*__f2, *__f1)) { iterator __m2 = _VSTD::next(__f2); for (; __m2 != __e2 &amp;&amp; __comp(*__m2, *__f1); ++__m2) ; __link_pointer __f = __f2.__ptr_; __link_pointer __l = __m2.__ptr_-&gt;__prev_; if (__e1 == __f2) __e1 = __m2; __f2 = __m2; base::__unlink_nodes(__f, __l); __m2 = _VSTD::next(__f1); __link_nodes(__f1.__ptr_, __f, __l); __f1 = __m2; } else ++__f1; } return __r;}","link":"/2023/03/05/stl-programming-style/"},{"title":"STL - 番外0 vector resize reserve比较","text":"vector resize reserve比较size：Returns the number of elements in the vector 目前存在的元素数。即： 元素个数 capacity：Return size of allocated storage capacity 容器能存储数据的个数。 即：容器容量 reserve原型： 1void reserve (size_type n); 作用： Request a change in capacity Requests that the vector capacity be at least enough to contain n elements. If n is greater than the current vector capacity, the function causes the container to reallocate its storage increasing its capacity to n (or greater). In all other cases, the function call does not cause a reallocation and the vector capacity is not affected. This function has no effect on the vector size and cannot alter its elements. resize原型： 12void resize (size_type n);void resize (size_type n, const value_type&amp; val); 作用： Change size Resizes the container so that it contains n elements. If n is smaller than the current container size, the content is reduced to its first n elements, removing those beyond (and destroying them). If n is greater than the current container size, the content is expanded by inserting at the end as many elements as needed to reach a size of n. If val is specified, the new elements are initialized as copies of val, otherwise, they are value-initialized. If n is also greater than the current container capacity, an automatic reallocation of the allocated storage space takes place. Notice that this function changes the actual content of the container by inserting or erasing elements from it. 通过以上说明我们可以得知： resize改变的是容器的大小（包括capacity和size），reserve则是改变的capacity，size没有改变。 reserve是容器预留空间，但在空间内不真正创建元素对象，所以在没有添加新的对象之前，不能引用容器内的元素。 resize了以后，容器中就有了相关的元素（对象），是可以引用容器内的元素的。 我们通过以下的一个测试函数，来探讨下我们为什么要使用reserve： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void growPushBack(vector&lt;int&gt; &amp;vec){ int size = 0, cap = 0; for(int i = 0; i &lt; 600; i++){ cap = vec.capacity(); size = vec.size(); if(cap == size){ cout &lt;&lt; endl; cout &lt;&lt; &quot;after push, capacity will mul 2&quot; &lt;&lt; endl; cout &lt;&lt; &quot;before: &quot; &lt;&lt; vec.capacity() &lt;&lt; &quot; address: &quot; &lt;&lt; &amp;*(vec.begin()) &lt;&lt; endl; } vec.push_back(i); if(cap == size){ cout &lt;&lt; &quot;after: &quot; &lt;&lt; vec.capacity() &lt;&lt; &quot; address: &quot; &lt;&lt; &amp;*(vec.begin()) &lt;&lt; endl; } }}int main(){ vector&lt;int&gt; vecIntA; //声明vector后未使用reserve，直接进行push_back操作 cout &lt;&lt; &quot;Making vecIntA growing:(empty opt)&quot; &lt;&lt; endl; cout &lt;&lt; &quot;size: &quot; &lt;&lt; vecIntA.size() &lt;&lt; endl; cout &lt;&lt; &quot;capacity: &quot; &lt;&lt; vecIntA.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;begin:&quot; &lt;&lt;&amp;*(vecIntA.begin()) &lt;&lt; endl; growPushBack(vecIntA); cout &lt;&lt; &quot;\\n\\n-----\\n\\n&quot; &lt;&lt; endl; vector&lt;int&gt; vecIntB; //声明vecIntB后用reserve来执行其容量为50 vecIntB.reserve(50); cout &lt;&lt; &quot;Making vecIntB growing:(reserve) &quot; &lt;&lt; endl; cout &lt;&lt; &quot;size: &quot; &lt;&lt; vecIntB.size() &lt;&lt; endl; cout &lt;&lt; &quot;capacity: &quot; &lt;&lt; vecIntB.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;begin:&quot; &lt;&lt;&amp;*(vecIntB.begin()) &lt;&lt; endl; growPushBack(vecIntB); cout &lt;&lt; &quot;\\n\\n-----\\n\\n&quot; &lt;&lt; endl; vector&lt;int&gt; vecIntC; //声明vecIntC后用resize来执行其容量为50 vecIntC.resize(50); cout &lt;&lt; &quot;Making vecIntC growing: (resize)&quot; &lt;&lt; endl; cout &lt;&lt; &quot;size: &quot; &lt;&lt; vecIntC.size() &lt;&lt; endl; cout &lt;&lt; &quot;capacity: &quot; &lt;&lt; vecIntC.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;begin:&quot; &lt;&lt;&amp;*(vecIntC.begin()) &lt;&lt; endl; growPushBack(vecIntC); return 0;} 输出结果为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677Making vecIntA growing:(empty opt)size: 0capacity: 0begin:0x0after push, capacity will mul 2before: 0 address: 0x0after: 1 address: 0x7fb4a4604080after push, capacity will mul 2before: 1 address: 0x7fb4a4604080after: 2 address: 0x7fb4a4604090after push, capacity will mul 2before: 2 address: 0x7fb4a4604090after: 4 address: 0x7fb4a4604080after push, capacity will mul 2before: 4 address: 0x7fb4a4604080after: 8 address: 0x7fb4a46040a0after push, capacity will mul 2before: 8 address: 0x7fb4a46040a0after: 16 address: 0x7fb4a46040c0after push, capacity will mul 2before: 16 address: 0x7fb4a46040c0after: 32 address: 0x7fb4a4604100after push, capacity will mul 2before: 32 address: 0x7fb4a4604100after: 64 address: 0x7fb4a4604180after push, capacity will mul 2before: 64 address: 0x7fb4a4604180after: 128 address: 0x7fb4a4604280after push, capacity will mul 2before: 128 address: 0x7fb4a4604280after: 256 address: 0x7fb4a5808200-----Making vecIntB growing:(reserve) size: 0capacity: 50begin:0x7fb4a4604180after push, capacity will mul 2before: 50 address: 0x7fb4a4604180after: 100 address: 0x7fb4a4704080after push, capacity will mul 2before: 100 address: 0x7fb4a4704080after: 200 address: 0x7fb4a4704210-----Making vecIntC growing: (resize)size: 50capacity: 50begin:0x7fb4a4704080after push, capacity will mul 2before: 50 address: 0x7fb4a4704080after: 100 address: 0x7fb4a4704530after push, capacity will mul 2before: 100 address: 0x7fb4a4704530after: 200 address: 0x7fb4a47046c0Process finished with exit code 0 由运行结果可知，通过push_back操作，容器中的元素数量（size）一直在增加，当容器中的元素个数（size）达到了capacity值时，capacity是呈指数级增大的（2^n）（注意：此处不同编译器是不一样的，有的编译器是增加目前capacity的一半，即乘以1.5；有的是增加目前capacity，即乘以2），当发生扩容操作时，系统会发生以下操作： 开辟2*capacity的新空间 将原vector中的元素拷贝至新地址 释放原vector的capacity空间 根据输出容器的begin迭代器在内存中的地址，可以知道，容器是换了位置的（在内存中的位置发生了变化）。 为了支持快速的随机访问，vector容器的元素以连续方式存放，每一个元素都紧挨着前一个元素存储。设想一下，当vector添加一个元素时，为了满足连续存放这个特性，都需要重新分配空间、拷贝元素、撤销旧空间，这样性能难以接受。因此STL实现者在对vector进行内存分配时，其实际分配的容量要比当前所需的空间多一些。就是说，vector容器预留了一些额外的存储区，用于存放新添加的元素，这样就不必为每个新元素重新分配整个容器的内存空间。 push_back的具体实现： 当数组中增加一个元素x的时候，先判断是否还有备用空间；如果还有备用空间，则将当前指针的值设为x，并将当前的指针加1；若备用空间已经用完，如果之前的空间为0，则重新分配大小为1的空间，否则将空间扩容为之前的两倍，然后将旧容器中的值重新拷贝到新空间中，并重新分配起始指针和当前指针。所以使用vector需要注意的一点就是尽量不要动态给它分配空间。而且空间重新分配之后，之前的所有指针都会失效（特别要注意）。两倍扩容的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243void push_back(const T&amp; x) { if (finish != end_of_storage) { //若当前还有备用空间 construct(finish, x); //将当前水位的值设为x ++finish; //提升水位 } else insert_aux(end(), x); }template &lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert_aux(iterator position, const T&amp; x) { if (finish != end_of_storage) { construct(finish, *(finish - 1)); ++finish; T x_copy = x; copy_backward(position, finish - 2, finish - 1); *position = x_copy; } else { const size_type old_size = size(); //获取之前数组的大小 const size_type len = old_size != 0 ? 2 * old_size : 1; //将当前数组的容量扩大为原来的两倍 iterator new_start = data_allocator::allocate(len); //重新分配新数组的起始迭代器 iterator new_finish = new_start; __STL_TRY { new_finish = uninitialized_copy(start, position, new_start); //将旧数组的值重新分配给当前的新数组 construct(new_finish, x); //将当前数组的水位的值设为x ++new_finish; //提升新数组的水位 new_finish = uninitialized_copy(position, finish, new_finish); //这语句感觉可有可无，因为它根本就不会执行，position即last，而finish也是last } # ifdef __STL_USE_EXCEPTIONS catch(...) { //如果重新构造的新数组出现异常，则销毁当前新创建的数组，并释放内存空间 destroy(new_start, new_finish); data_allocator::deallocate(new_start, len); throw; }# endif /* __STL_USE_EXCEPTIONS */ destroy(begin(), end()); //将旧数组的空间释放掉 deallocate(); start = new_start; //new_start记录新数组的起始位置 finish = new_finish; //重新设置当前水位的指针 end_of_storage = new_start + len; //设置新数组的容量 }} 综上，出于性能的考虑，我们在提前可以知道vector size的情况下，可以提前resize或reserve，这样可以减少扩容时拷贝所付出的时间。","link":"/2023/03/05/stl-resize-or-reserve/"},{"title":"CPP - memset与for循环赋初值比较","text":"写代码的时候思考了一会儿memset初始化快还是for循环初始化快。看了大量的文献资料，结论如下： 如果对于一个数组进行赋初值操作，memset肯定比for循环快 memset赋初值是按字节为单位的，如果要赋一些比较难的值（33，22等），就比较难 接上，因为memset是按字节为单位赋初值，当变量所占字节数越大，速度越慢（int的数组比char慢） 测试代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;chrono&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;numeric&gt;using namespace std;using namespace std::chrono;const int MAXROWNUM = 5e3;const int MAXCOLNUM = 5e3;const int loopTimes = 10;const int loop = 10;int arr[MAXROWNUM][MAXCOLNUM];int arr0[MAXROWNUM][MAXCOLNUM];int arr1[MAXROWNUM][MAXCOLNUM];int arr2[MAXROWNUM][MAXCOLNUM];int arr3[MAXROWNUM][MAXCOLNUM];int arr4[MAXROWNUM][MAXCOLNUM];int arr5[MAXROWNUM][MAXCOLNUM];int arr6[MAXROWNUM][MAXCOLNUM];int arr7[MAXROWNUM][MAXCOLNUM];int arr8[MAXROWNUM][MAXCOLNUM];int arr9[MAXROWNUM][MAXCOLNUM];char str0[MAXROWNUM][MAXCOLNUM];char str1[MAXROWNUM][MAXCOLNUM];char str2[MAXROWNUM][MAXCOLNUM];char str3[MAXROWNUM][MAXCOLNUM];char str4[MAXROWNUM][MAXCOLNUM];char str5[MAXROWNUM][MAXCOLNUM];char str6[MAXROWNUM][MAXCOLNUM];char str7[MAXROWNUM][MAXCOLNUM];char str8[MAXROWNUM][MAXCOLNUM];char str9[MAXROWNUM][MAXCOLNUM];char str[MAXROWNUM][MAXCOLNUM];long long memsetfunc_i(){ auto start = system_clock::now(); int len =MAXROWNUM*MAXCOLNUM*sizeof(int); memset(arr,0, len); auto end = system_clock::now(); auto tt = duration_cast&lt;microseconds&gt;(end - start);// printf(&quot;memset cost %.3f us\\n&quot;,tt.count()); return tt.count();}long long memsettenfunc_i(){ auto start = system_clock::now(); int len =MAXROWNUM*MAXCOLNUM*sizeof(int); for (int i = 0; i &lt; loopTimes; ++i) { memset(arr,0, len); } auto end = system_clock::now(); auto tt = duration_cast&lt;microseconds&gt;(end - start); return tt.count();}long long forfunc_i(){ auto start1 = system_clock::now(); for (int i = 0; i &lt; MAXROWNUM; ++i) { for (int j = 0; j &lt; MAXCOLNUM; ++j) { arr[i][j] = 0; } } auto end1 = system_clock::now(); auto tt1 = duration_cast&lt;microseconds&gt;(end1 - start1); return tt1.count();}long long fortenfunc_i(){ auto start1 = system_clock::now(); for (int k = 0; k &lt; loopTimes; ++k) { for (int i = 0; i &lt; MAXROWNUM; ++i) { for (int j = 0; j &lt; MAXCOLNUM; ++j) { arr[i][j] = 0; } } } auto end1 = system_clock::now(); auto tt1 = duration_cast&lt;microseconds&gt;(end1 - start1); return tt1.count();}long long memsetfunc_c(){ auto start = system_clock::now(); int len =MAXROWNUM*MAXCOLNUM*sizeof(char); memset(str,'0', len); auto end = system_clock::now(); auto tt = duration_cast&lt;microseconds&gt;(end - start);// printf(&quot;memset cost %.3f us\\n&quot;,tt.count()); return tt.count();}long long memsettenfunc_c(){ auto start = system_clock::now(); int len =MAXROWNUM*MAXCOLNUM*sizeof(char); for (int i = 0; i &lt; loopTimes; ++i) { memset(str,'0', len); } auto end = system_clock::now(); auto tt = duration_cast&lt;microseconds&gt;(end - start); return tt.count();}long long forfunc_c(){ auto start1 = system_clock::now(); for (int i = 0; i &lt; MAXROWNUM; ++i) { for (int j = 0; j &lt; MAXCOLNUM; ++j) { str[i][j] = '0'; } } auto end1 = system_clock::now(); auto tt1 = duration_cast&lt;microseconds&gt;(end1 - start1); return tt1.count();}long long fortenfunc_c(){ auto start1 = system_clock::now(); for (int k = 0; k &lt; loopTimes; ++k) { for (int i = 0; i &lt; MAXROWNUM; ++i) { for (int j = 0; j &lt; MAXCOLNUM; ++j) { str[i][j] = '0'; } } } auto end1 = system_clock::now(); auto tt1 = duration_cast&lt;microseconds&gt;(end1 - start1); return tt1.count();}long long memsettendifffunc_c(){ auto start = system_clock::now(); int len =MAXROWNUM*MAXCOLNUM*sizeof(char); memset(str0,'0', len); memset(str1,'0', len); memset(str2,'0', len); memset(str3,'0', len); memset(str4,'0', len); memset(str5,'0', len); memset(str6,'0', len); memset(str7,'0', len); memset(str8,'0', len); memset(str9,'0', len); auto end = system_clock::now(); auto tt = duration_cast&lt;microseconds&gt;(end - start); return tt.count();}long long fortendifffunc_c(){ auto start1 = system_clock::now(); for (int i = 0; i &lt; MAXROWNUM; ++i) { for (int j = 0; j &lt; MAXCOLNUM; ++j) { str0[i][j] = '0'; str1[i][j] = '0'; str2[i][j] = '0'; str3[i][j] = '0'; str4[i][j] = '0'; str5[i][j] = '0'; str6[i][j] = '0'; str7[i][j] = '0'; str8[i][j] = '0'; str9[i][j] = '0'; } } auto end1 = system_clock::now(); auto tt1 = duration_cast&lt;microseconds&gt;(end1 - start1); return tt1.count();}long long memsettendifffunc(){ auto start = system_clock::now(); int len =MAXROWNUM*MAXCOLNUM*sizeof(char); memset(arr0,0, len); memset(arr1,0, len); memset(arr2,0, len); memset(arr3,0, len); memset(arr4,0, len); memset(arr5,0, len); memset(arr6,0, len); memset(arr7,0, len); memset(arr8,0, len); memset(arr9,0, len); auto end = system_clock::now(); auto tt = duration_cast&lt;microseconds&gt;(end - start); return tt.count();}long long fortendifffunc(){ auto start1 = system_clock::now(); for (int i = 0; i &lt; MAXROWNUM; ++i) { for (int j = 0; j &lt; MAXCOLNUM; ++j) { arr0[i][j] = 0; arr1[i][j] = 0; arr2[i][j] = 0; arr3[i][j] = 0; arr4[i][j] = 0; arr5[i][j] = 0; arr6[i][j] = 0; arr7[i][j] = 0; arr8[i][j] = 0; arr9[i][j] = 0; } } auto end1 = system_clock::now(); auto tt1 = duration_cast&lt;microseconds&gt;(end1 - start1); return tt1.count();}vector&lt;long long&gt; ans;double getAns(long long(*p)()){ ans.clear(); for (int i = 0; i &lt; loop; ++i) { ans.push_back((*p)()); } sort(ans.begin(),ans.end()); double cost = accumulate(ans.begin()+2, ans.end()-2, 0.0) / static_cast&lt;double&gt;(ans.size()-6); cost = cost/1000; return cost;}int main() { double m1,m10,f1,f10,cm1,cm10,cf1,cf10,cmd10,cfd10,md10,fd10; m1 = getAns(memsetfunc_i); m10 = getAns(memsettenfunc_i); f1 = getAns(forfunc_i); f10 = getAns(fortenfunc_i); cm1 = getAns(memsetfunc_c); cm10 = getAns(memsettenfunc_c); cf1 = getAns(forfunc_c); cf10 = getAns(fortenfunc_c); cmd10 = getAns(memsettendifffunc_c); cfd10 = getAns(fortendifffunc_c); md10 = getAns(memsettendifffunc); fd10 = getAns(fortendifffunc); printf(&quot;int数组memset一次耗时:%.3fms\\tint数组for循环一次耗时:%.3fms\\n&quot;,m1,f1); printf(&quot;int数组memset十次耗时:%.3fms\\tint数组for循环十次耗时:%.3fms\\n&quot;,m10,f10); printf(&quot;不同的十个int数组memset耗时:%.3fms\\t不同的十个int数组for循环耗时:%.3fms\\n&quot;,md10,fd10); printf(&quot;\\n&quot;); printf(&quot;char数组memset一次耗时:%.3fms\\tchar数组for循环一次耗时:%.3fms\\n&quot;,cm1,cf1); printf(&quot;char数组memset十次耗时:%.3fms\\tchar数组for循环十次耗时:%.3fms\\n&quot;,cm10,cf10); printf(&quot;不同的十个char数组memset耗时:%.3fms\\t不同的十个char数组for循环耗时:%.3fms\\n&quot;,cmd10,cfd10);} 数组都开在的栈区，因此数组不能设的太大。。。运行结果如下：可以佐证上诉的结论。运行结果 memset具体的实现可以看一下下面这个博客，写的很仔细：https://www.cnblogs.com/hoodlum1980/p/3505802.html。 以大佬的总结作为我的总结： 对数组使用初始化列表，或 memset 两者在底层上可能等效。（msvc编译器将前者处理为后者）。对数组用循环初始化，和使用 memset 初始化相比，很有可能等效。即使不等效（memset 调用了 SSE2 扩展），也不可能达到成为一个优化命题和关注点。如果一定要说有点区别，那就是如果是对一个整数数组用初始化列表或者循环初始化，那么编译器不需要考虑地址对齐的问题（因为编译器必然把数组分配到对齐的地址），而 memset 则需要考虑传入的地址是否已对齐到某个基本粒度，并对此未对齐部分作处理。当对一个随机数据组成的内存块进行清零操作，memset 看起来仿佛是唯一正确的可选方式（如果所在平台无此函数，则可以用手写循环替代）。声明数组时提供初始化列表，声明后再调用 memset 或者使用循环初始化（显然，在能够使用 memset 时，循环写法在高级语言层面不如前者简洁），无论是代码规范还是性能层面，这些写法都不存在值得强调的绝对优劣关系。","link":"/2023/03/05/cpp-memset/"},{"title":"mit6.824 - MapReduce极简实现","text":"0 概述MapReduce是一种广泛运用的分布式-大数据计算编程模型，最初由Google发表，其开源实现为Hadoop。 MapReduce 的编程模型非常简单，正如名字一样，用户仅仅需要实现一个 Map 函数，一个 Reduce 函数。 Map 函数，即映射函数：它会接受一个 key-value 对，然后把这个 key-value 对转换成 0 到多个新的 key-value 对并输出出去。 1map (k1, v1) -&gt; list (k2, v2) Reduce 函数，即化简函数：它接受一个 Key，以及这个 Key 下的一组 Value，然后化简成一组新的值 Value 输出出去。 1reduce (k2, list(v2)) -&gt; list(v3) 可以解决的任务例子： 分布式 grep； 统计 URL 的访问频次； 反转网页 - 链接图； 分域名的词向量； 生成倒排索引； 分布式排序。 1 MapReduce结构一图胜千言： 2 总体设计以完成6.8242021Spring的lab1为目标。 可以通过以下git命令：clone代码： 1git clone git://g.csail.mit.edu/6.824-golabs-2021 6.824 master采用lazy分配任务方法，由worker主动去触发任务分配、任务结束等操作。master分配不同的块给不同的worker执行。 因此worker需要实现获取任务，任务结束等RPC，代码如下： 12345678910111213141516171819type GetTaskArgs struct {}type GetTaskReply struct { Type TaskType Filenames []string Task_no int NReduce int Err Errno}type FinishTaskArgs struct { Type TaskType Task_no int}type FinishTaskReply struct { Err Errno} 3 worker设计worker的工作就是不断获取任务，若任务完成则提交之。 其主要代码为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354func Worker(mapf func(string, string) []KeyValue, reducef func(string, []string) string) { // Your worker implementation here. for { args := GetTaskArgs{} reply := GetTaskReply{} log.Printf(&quot;get task request: %v\\n&quot;, args) ok := CallGetTask(&amp;args, &amp;reply) log.Printf(&quot;recv get task reply: %v\\n&quot;, reply) if !ok || reply.Type == STOP { break } // handle map fynction switch reply.Type { case MAP: if len(reply.Filenames) &lt; 1 { log.Fatalf(&quot;don't have filename&quot;) } DoMAP(reply.Filenames[0], reply.Task_no, reply.NReduce, mapf) // map complete, send msg to master finish_args := FinishTaskArgs{ Type: MAP, Task_no: reply.Task_no, } finish_reply := FinishTaskReply{} log.Printf(&quot;finish request: %v\\n&quot;, finish_args) CallFinishTask(&amp;finish_args, &amp;finish_reply) log.Printf(&quot;recv finish reply: %v\\n&quot;, finish_reply) // time.Sleep(time.Second) case REDUCE: if len(reply.Filenames) &lt; 1 { log.Fatalf(&quot;don't have filenames&quot;) } DoReduce(reply.Filenames, reply.Task_no, reducef) // reduce complete, send msg to master finish_args := FinishTaskArgs{ Type: REDUCE, Task_no: reply.Task_no, } finish_reply := FinishTaskReply{} log.Printf(&quot;finish request: %v\\n&quot;, finish_args) CallFinishTask(&amp;finish_args, &amp;finish_reply) log.Printf(&quot;recv finish reply: %v\\n&quot;, finish_reply) // time.Sleep(time.Second) case WAIT: log.Printf(&quot;wait task\\n&quot;) time.Sleep(time.Second) default: time.Sleep(time.Second) } }} 其中分MAP、REDUCE、WAIT和STOP四个状态： MAP：进行MAP操作 REDUCE：进行REDECE操作 WAIT：等待其他worker完成任务（比如等待在总体MAP任务的收尾上，以及没有更多的MAP任务可以分配了） STOP：worker停止、退出 其中最重要的为map和reduce任务的执行。 map任务的执行实现代码如下：（对应上图中的2、3、4步） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func DoMAP(filename string, task_no int, nReduce int, mapf func(string, string) []KeyValue) { file, err := os.Open(filename) if err != nil { log.Fatalf(&quot;cannot open %v&quot;, filename) } content, err := ioutil.ReadAll(file) if err != nil { log.Fatalf(&quot;cannot read %v&quot;, filename) } file.Close() kva := mapf(filename, string(content)) sort.Sort(ByKey(kva)) log.Println(&quot;encode to json&quot;) files := make([]*os.File, nReduce) encoders := make([]*json.Encoder, nReduce) for i := 0; i &lt; nReduce; i++ { ofile, err := ioutil.TempFile(&quot;&quot;, &quot;mr-tmp*&quot;) if err != nil { log.Fatalf(&quot;cannot create temp file&quot;) } defer ofile.Close() encoder := json.NewEncoder(ofile) encoders[i] = encoder files[i] = ofile } var index int for _, kv := range kva { index = ihash(kv.Key) % nReduce err = encoders[index].Encode(&amp;kv) if err != nil { log.Fatalf(&quot;cannot encode %v&quot;, kv) } } // atomically rename for i := 0; i &lt; nReduce; i++ { filename_tmp := fmt.Sprintf(&quot;mr-%d-%d&quot;, task_no, i) err := os.Rename(files[i].Name(), filename_tmp) if err != nil { log.Fatalf(&quot;cannot rename %v to %v&quot;, files[i].Name(), filename_tmp) } }} 比较有意思的是map需要通过一个hash函数将相同的条目分布在同一输出文件中： 1234567891011121314func ihash(key string) int { h := fnv.New32a() h.Write([]byte(key)) return int(h.Sum32() &amp; 0x7fffffff)}var index intfor _, kv := range kva { index = ihash(kv.Key) % nReduce err = encoders[index].Encode(&amp;kv) if err != nil { log.Fatalf(&quot;cannot encode %v&quot;, kv) }} reduce任务的执行实现代码如下：（对应上图中的5、6步） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354func DoReduce(filenames []string, task_no int, reducef func(string, []string) string) { // read data from mid-file kva := make([]KeyValue, 0) for _, filename := range filenames { file, err := os.Open(filename) if err != nil { log.Fatalf(&quot;cannot open %v&quot;, filename) } defer file.Close() dec := json.NewDecoder(file) for { var kv KeyValue if err := dec.Decode(&amp;kv); err != nil { break } kva = append(kva, kv) } } sort.Sort(ByKey(kva)) // call Reduce on each distinct key in kva[], // and print the result to mr-out-0. ofile, err := ioutil.TempFile(&quot;&quot;, &quot;mr-out-tmp*&quot;) if err != nil { log.Fatalf(&quot;cannot create temp file&quot;) } defer ofile.Close() i := 0 for i &lt; len(kva) { j := i + 1 for j &lt; len(kva) &amp;&amp; kva[j].Key == kva[i].Key { j++ } values := []string{} for k := i; k &lt; j; k++ { values = append(values, kva[k].Value) } output := reducef(kva[i].Key, values) // this is the correct format for each line of Reduce output. fmt.Fprintf(ofile, &quot;%v %v\\n&quot;, kva[i].Key, output) i = j } output_filename := fmt.Sprintf(&quot;mr-out-%d&quot;, task_no) err = os.Rename(ofile.Name(), output_filename) if err != nil { log.Fatalf(&quot;cannot rename %v to %v&quot;, ofile.Name(), output_filename) }} 按道理应该是要在GFS上读写文件的，条件不允许，就直接采用UNIX的文件系统了。 4 master设计master的设计还是比较简单的，只包含很少的信息： 1234567type Coordinator struct { tasks []Task nReduce int nMap int status CoordinatorStatus mu sync.Mutex} 对所需要进行的任务信息进行定义，如下： 1234567891011121314type TaskStatus intconst ( idle TaskStatus = iota in_progress completed)type Task struct { tno int filenames []string status TaskStatus startTime time.Time} 其主要就是接受worker的两个RPC请求。 获取任务的RPC handler实现如下： 对于长时间（10s）未完成的任务，重新制定一个worker执行此任务。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051func (c *Coordinator) GetTask(args *GetTaskArgs, reply *GetTaskReply) error { c.mu.Lock() defer c.mu.Unlock() finish_flag := c.IsAllFinish() if finish_flag { c.NextPhase() } for i := 0; i &lt; len(c.tasks); i++ { if c.tasks[i].status == idle { log.Printf(&quot;send task %d to worker\\n&quot;, i) reply.Err = SuccessCode reply.Task_no = i reply.Filenames = c.tasks[i].filenames if c.status == MAP_PHASE { reply.Type = MAP reply.NReduce = c.nReduce } else if c.status == REDUCE_PHASE { reply.NReduce = 0 reply.Type = REDUCE } else { log.Fatal(&quot;unexpected status&quot;) } c.tasks[i].startTime = time.Now() c.tasks[i].status = in_progress return nil } else if c.tasks[i].status == in_progress { curr := time.Now() if curr.Sub(c.tasks[i].startTime) &gt; time.Second*10 { log.Printf(&quot;resend task %d to worker\\n&quot;, i) reply.Err = SuccessCode reply.Task_no = i reply.Filenames = c.tasks[i].filenames if c.status == MAP_PHASE { reply.Type = MAP reply.NReduce = c.nReduce } else if c.status == REDUCE_PHASE { reply.NReduce = 0 reply.Type = REDUCE } else { log.Fatal(&quot;unexpected status&quot;) } c.tasks[i].startTime = time.Now() return nil } } } reply.Err = SuccessCode reply.Type = WAIT return nil} 完成任务的RPC handler实现如下： 12345678910111213func (c *Coordinator) FinishTask(args *FinishTaskArgs, reply *FinishTaskReply) error { c.mu.Lock() defer c.mu.Unlock() if args.Task_no &gt;= len(c.tasks) || args.Task_no &lt; 0 { reply.Err = ParaErrCode return nil } c.tasks[args.Task_no].status = completed if c.IsAllFinish() { c.NextPhase() } return nil} 检查全部任务是否完成，完成就进入下一个阶段： 123456789101112131415161718192021func (c *Coordinator) IsAllFinish() bool { for i := len(c.tasks) - 1; i &gt;= 0; i-- { if c.tasks[i].status != completed { return false } } return true}func (c *Coordinator) NextPhase() { if c.status == MAP_PHASE { log.Println(&quot;change to REDUCE_PHASE&quot;) c.MakeReduceTasks() c.status = REDUCE_PHASE } else if c.status == REDUCE_PHASE { log.Println(&quot;change to FINISH_PHASE&quot;) c.status = FINISH_PHASE } else { log.Println(&quot;unexpected status change!&quot;) }} 客户端查看MapReduce任务是否完成： 12345678func (c *Coordinator) Done() bool { c.mu.Lock() defer c.mu.Unlock() if c.status == FINISH_PHASE { return true } return false} 5 客户端如何使用呢？写两个函数（Map和Reduce）就行啦： 1234567891011121314151617181920212223242526272829303132//// The map function is called once for each file of input. The first// argument is the name of the input file, and the second is the// file's complete contents. You should ignore the input file name,// and look only at the contents argument. The return value is a slice// of key/value pairs.//func Map(filename string, contents string) []mr.KeyValue { // function to detect word separators. ff := func(r rune) bool { return !unicode.IsLetter(r) } // split contents into an array of words. words := strings.FieldsFunc(contents, ff) kva := []mr.KeyValue{} for _, w := range words { kv := mr.KeyValue{w, &quot;1&quot;} kva = append(kva, kv) } return kva}//// The reduce function is called once for each key generated by the// map tasks, with a list of all the values created for that key by// any map task.//func Reduce(key string, values []string) string { // return the number of occurrences of this word. return strconv.Itoa(len(values))} 6 附录详细代码可以参考： 仓库 commit","link":"/2023/03/06/mit6-824-mapreduce/"},{"title":"mit6.S081 - Xv6 and Unix utilities","text":"sleep Implement the UNIX program sleep for xv6; your sleep should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file user/sleep.c. 描述：实现一个提供sleep功能的unix程序。 解决思路：系统已经实现了sleep函数，直接调用即可。 代码： 12345678910111213141516171819#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;intmain(int argc, char *argv[]){ int ticks_num; if(argc != 2){ fprintf(2, &quot;Usage: sleep times\\n&quot;); exit(1); } ticks_num = atoi(argv[1]); sleep(ticks_num); exit(0);} pingpong Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “: received ping”, where is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “: received pong”, and exit. Your solution should be in the file user/pingpong.c. 描述：使用管道（pipe）实现ping-pong（即使用pipe实现父进程子进程之间的通信） 解决思路：fork + pipe + write/read即可，比较简单，要注意pipe会创建两个fd（读/写），fork后子进程会继承文件描述符。 代码： 12345678910111213141516171819202122232425262728#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;intmain(int argc, char *argv[]){ int p[2]; // read, write char buf[2]; if(argc != 1){ fprintf(2, &quot;Usage: pingpong\\n&quot;); exit(1); } pipe(p); if (fork() == 0) { // child read(p[0], buf, 1); fprintf(1, &quot;%d: received ping\\n&quot;, getpid()); write(p[1], &quot;c&quot;, 1); exit(0); } else { // father write(p[1], &quot;c&quot;, 1); read(p[0], buf, 1); fprintf(1, &quot;%d: received pong\\n&quot;, getpid()); } exit(0);} primes Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down this page and the surrounding text explain how to do it. Your solution should be in the file user/primes.c. 描述：使用pipe实现素数筛。 解决思路：父进程产生2-35的数，然后子进程按以下算法进行筛选即可。 123456p = get a number from left neighborprint ploop: n = get a number from left neighbor if (p does not divide n) send n to right neighbor 代码：（若BUFSIZE过大会panic，排查后发现是stack只有一页。。。） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#define MAX_SEQ 35#define BUFSIZE 100int getline(int fd, char *buf, int max){ int i, cc; char c; for (i = 0; i + 1 &lt; max;) { cc = read(fd, &amp;c, 1); if (cc &lt; 1) { return 0; } if (c == '\\n' || c == '\\r') break; buf[i++] = c; } buf[i] = '\\0'; return i;}int getnum(char *buf, int *pos){ int num = 0, i = *pos; while(buf[i] &gt;= '0' &amp;&amp; buf[i] &lt;= '9') { num = num * 10 + buf[i] - '0'; i++; } *pos = i - 1; return num;}int primer(int read_fd){ char buf[BUFSIZE]; int len = getline(read_fd, buf, BUFSIZE); // printf(&quot;%s\\n&quot;, buf); close(read_fd); int pipe_fd[2]; pipe(pipe_fd); int i = 0, first_print_flag = 1; int is_have = 0; int first_num = getnum(buf, &amp;i), num_tmp; printf(&quot;prime %d\\n&quot;, first_num); for (i = 0; i &lt; len; ++i) { if (buf[i] &gt;= '0' &amp;&amp; buf[i] &lt;= '9') { num_tmp = getnum(buf, &amp;i); if (num_tmp % first_num == 0) { continue; } is_have = 1; break; } } if (is_have) { if (fork() == 0) { // child close(pipe_fd[1]); primer(pipe_fd[0]); exit(0); } else { close(pipe_fd[0]); for (i = 0; i &lt; len; ++i) { if (buf[i] &gt;= '0' &amp;&amp; buf[i] &lt;= '9') { num_tmp = getnum(buf, &amp;i); if (num_tmp % first_num == 0) { continue; } if (first_print_flag) { fprintf(pipe_fd[1], &quot;%d&quot;, num_tmp); first_print_flag = 0; } else { fprintf(pipe_fd[1], &quot; %d&quot;, num_tmp); } } } fprintf(pipe_fd[1], &quot;\\n&quot;, num_tmp); close(pipe_fd[1]); wait(0); } } else { close(pipe_fd[0]); close(pipe_fd[1]); } return 0;}int main(int argc, char *argv[]){ int pipe_fd[2]; // read, write if (argc != 1) { fprintf(2, &quot;Usage: primes\\n&quot;); exit(1); } pipe(pipe_fd); if (fork() == 0) { // child close(pipe_fd[1]); primer(pipe_fd[0]); exit(0); } else { // father close(pipe_fd[0]); for (int i = 2; i &lt;= MAX_SEQ; ++i) { fprintf(pipe_fd[1], &quot;%d&quot;, i); if (i != MAX_SEQ) { fprintf(pipe_fd[1], &quot; &quot;, i); } else { fprintf(pipe_fd[1], &quot;\\n&quot;, i); } } close(pipe_fd[1]); wait(0); } exit(0);} find Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file user/find.c. 描述：实现find。 解决思路：魔改ls即可，改成dfs实现。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/fs.h&quot;char*fmtname(char *path){ char *p; // Find first character after last slash. for(p=path+strlen(path); p &gt;= path &amp;&amp; *p != '/'; p--) ; p++; return p;}voidfind(char *path, char *target){ struct stat st; char buf[512], *p; int fd; struct dirent de; if (stat(path, &amp;st) &lt; 0) { fprintf(2, &quot;find: cannot stat %s\\n&quot;, path); return; } switch(st.type){ case T_FILE: if (strcmp(fmtname(path), target) == 0) { printf(&quot;%s\\n&quot;, path); } break; case T_DIR: if((fd = open(path, 0)) &lt; 0){ fprintf(2, &quot;find: cannot open %s\\n&quot;, path); return; } strcpy(buf, path); p = buf+strlen(buf); *p++ = '/'; // many records while(read(fd, &amp;de, sizeof(de)) == sizeof(de)){ if(de.inum == 0) continue; if (!strcmp(&quot;.&quot;, de.name) || !strcmp(&quot;..&quot;, de.name)) { continue; } memmove(p, de.name, strlen(de.name)); p[strlen(de.name)] = 0; find(buf, target); } close(fd); break; }}intmain(int argc, char *argv[]){ if(argc != 3){ fprintf(2, &quot;Usage: find path keyword\\n&quot;); exit(1); } find(argv[1], argv[2]); exit(0);} xargs Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file user/xargs.c. 描述：实现xargs。 解决思路：对每行进行处理，因此加上上面的getline函数然后搭配上fork和exec就行（和shell类似）。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/param.h&quot;#define MAX_LEN 512int getline(char *buf, int max){ int i, cc; char c; for(i=0; i+1 &lt; max; ){ cc = read(0, &amp;c, 1); if(cc &lt; 1) { return 0; } if(c == '\\n' || c == '\\r') break; buf[i++] = c; } buf[i] = '\\0'; printf(&quot;str: %s\\n&quot;, buf); return 1;}intmain(int argc, char *argv[]){ // echo hello too | xargs echo bye char buffer[MAX_LEN]; char* argv_tmp[MAXARG]; // minus &quot;xargs&quot; memcpy(argv_tmp, argv + 1, (argc - 1) * sizeof(char*)); while (getline(buffer, MAX_LEN)) { if (fork() == 0) { argv_tmp[argc - 1] = buffer; exec(argv_tmp[0], argv_tmp); exit(0); } else { wait(0); } } exit(0);}","link":"/2023/03/06/mit6-s081-lab1/"},{"title":"mit6.S081 - xv6-debug","text":"窗口1作为xv6的运行窗口。 1make CPUS=1 qemu-gdb 窗口2作为gdb调试窗口。 1234567gdb-multiarch kernel/kernel# 进入gdb后执行set confirm offset architecture riscv:rv64set riscv use-compressed-breakpoints yestarget remote localhost:25000 一些tips： 12345678910111213141516171819202122232425262728293031323334# 调试用户态程序file user/_ls# 打开汇编/c源代码窗口，退出ctrl+x alayout split# 查看某地址对应指令x/i 0x630# 16进制打印p/x 1536# 打印寄存器的值p $a0i r a0# 查看栈帧bti f num# 单步执行（不进函数）n# 单步执行（进函数）s# 汇编单步执行（不进函数）ni# 汇编单步执行（进函数）si# 打断点b label# 删除断点delete breakpointsdelete num 一些不错的资料：gdb技巧。","link":"/2023/03/06/mit6-s081-xv6-debug/"},{"title":"UNIX环境高级编程 - 共享内存","text":"0. 概述共享内存允许两个或多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会成为一个进程用户空间内存的一部分，因此这种IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。 为使用一个共享内存段通常需要执行下面的步骤。 调用 shmget()创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。 使用 shmat()来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。 此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 shmat()调用返回的 addr 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。 1. System V 共享内存相关API12345678#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int semget(key_t key, int size, int flag);void *shmat(int shmid, void *addr, int flag);int shmdt(void *addr);int shmctl(int shmid, int cmd, struct shmid_ds *buf); shmget获得或创建一个共享内存标识符。 12int semget(key_t key, size_t size, int shmflag);// 成功返回一个共享内存标识符，失败返回－1； 第一个参数key为共享内存段命名； 第二个参数size为需要共享的内存容量。（如果共享内存已存在时，不能不大于该共享内存段的大小）； 第三个参数设置访问权限(低9位）与IPC_CREAT, IPC_EXCL 的按位或。 shmat将共享内存段连接到一个进程的地址空间中。 12void *shmat(int shm_id, const void *addr, int shmflg) ;// 成功返回共享存储段连接的实际地址，失败返回-1 第一个参数shm_id为shmget返回的共享内存标识符。 第二个参数addr指明共享内存段要连接到的地址（进程空间内部地址），通常指定为空指针(NULL)，表示让系统来选择共享内存在进程地址空间中出现的地址。 第三个参数shmflg可以设置为两个标志位（通常设置为0） SHM_RND（ 表示第二个参数指定的地址应被向下靠拢到内存页面大小的整数倍） SHM_RDONLY，要连接的共享内存段是只读的。 shmdt将共享内存从当前进程中分离。 1int shmdt(const void *shmaddr) ; //其中shmaddr为shmat返回的地址。 shmctl查看及修改共享内存段的shmid_ds结构，删除该结构以及相连的共享存储段标识。 12int shmctl(int shm_id, int command, struct shmid_ds *buf) ; // 成功返回0，失败返回-1 第一个参数shm_id为shmget返回的共享内存标识符。 第二个参数commad取值： IPC_STAT 获取当前共享内存段的shmid_ds结构 IPC_SET 把共享内存段的当前关联值设置为shmid_ds结构给出的值 IPC_RMID 从系统中删除该共享存储段。 第三个参数buf是一个结构指针，它指向共享内存模式和访问权限的结构 123456struct shmid_ds { uid_t shm_perm.uid; uid_t shm_perm.gid; mode_t shm_perm.mode; }; 2. 例子-生产者-消费者问题使用共享内存充当生产者-消费者问题的缓冲区。 生产者：producer.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;semaphore.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;stdlib.h&gt;#define NUMBER 300#define BUFSIZE 10// critical resourceint* buffer;// semaphoresem_t* empty;sem_t* full;sem_t* mutex;void producer() { int buf_in = 0; for (int i = 0 ; i &lt; NUMBER; i++) { sem_wait(empty); sem_wait(mutex); buffer[buf_in] = i; buf_in = (buf_in + 1) % BUFSIZE; printf(&quot;produce %d\\n&quot;, i); fflush(stdout); sem_post(mutex); sem_post(full); }}void quitHandler(int i) { sem_unlink(&quot;empty&quot;); sem_unlink(&quot;full&quot;); sem_unlink(&quot;mutex&quot;); exit(-1);}int main() { signal(SIGINT, quitHandler); mutex = sem_open(&quot;mutex&quot;, O_CREAT , 0644, 1); full = sem_open(&quot;full&quot;, O_CREAT, 0644, 0); empty = sem_open(&quot;empty&quot;, O_CREAT, 0644, BUFSIZE); if (mutex == NULL || full == NULL || empty == NULL) { printf(&quot;error in sem_open %p %p %p\\n&quot;, mutex, full, empty); return -1; } int shmid = shmget((key_t)1121, sizeof(int) * BUFSIZE, 0666 | IPC_CREAT); void* shm = shmat(shmid, 0, 0); buffer = (int*)shm; producer(); sem_unlink(&quot;empty&quot;); sem_unlink(&quot;full&quot;); sem_unlink(&quot;mutex&quot;); return 0;} 消费者：consumer.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;stdio.h&gt;#include &lt;semaphore.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;stdlib.h&gt;#define NUMBER 300#define BUFSIZE 10// critical resourceint* buffer = NULL;// semaphoresem_t* empty;sem_t* full;sem_t* mutex;void consumer() { int buf_out = 0; int data = 0; for (int k = 0; k &lt; NUMBER; k++) { sem_wait(full); sem_wait(mutex); data = buffer[buf_out]; printf(&quot;comsume %d\\n&quot;, data); buf_out = (buf_out + 1) % BUFSIZE; fflush(stdout); sem_post(mutex); sem_post(empty); }}void quitHandler(int i) { sem_unlink(&quot;empty&quot;); sem_unlink(&quot;full&quot;); sem_unlink(&quot;mutex&quot;); exit(-1);}int main() { signal(SIGINT, quitHandler); mutex = sem_open(&quot;mutex&quot;, O_CREAT, 0644, 1); full = sem_open(&quot;full&quot;, O_CREAT, 0644, 0); empty = sem_open(&quot;empty&quot;, O_CREAT , 0644, BUFSIZE); if (mutex == NULL || full == NULL || empty == NULL) { printf(&quot;error in sem_open %p %p %p\\n&quot;, mutex, full, empty); return -1; } int shmid = shmget((key_t)1121, sizeof(int) * BUFSIZE, 0666 | IPC_CREAT); if (shmid == -1) { exit(-1); } void* shm = shmat(shmid, 0, 0); buffer = (int*)shm; consumer(); sem_unlink(&quot;empty&quot;); sem_unlink(&quot;full&quot;); sem_unlink(&quot;mutex&quot;); return 0;} 编译命令： 12gcc consumer.c -o comsumer -lpthreadgcc consumer.c -o consumer -lpthread 让消费者先在后台执行，执行命令： 12./consumer &amp;./producer 如何杀后台任务？ 12jobs -lkill -9 pid","link":"/2023/03/06/linux-shared-memory/"},{"title":"linux0.11 - 地址映射过程","text":"0. 概述linux0.11对内存的管理是段页式的，所以其地址映射过程是将逻辑地址先通过分段机制变换得到线性地址，然后再通过分页机制变换为实际的物理地址。 1. 分段linux除了启动时运行在实模式下，其他时间运行在保护模式下。 保护模式下寻址和实模式有所不同： 实模式即DS：SI的形式去寻址。 保护模式通过段选择子的方式来寻址。（计算机科学中经典的加一层设计） 在保护模式下，段寄存器中存放的是一个段描述符表(Segment Descriptor Table)中某描述符项在表中的索引值。索引值指定的段描述符项中含有需要寻址的内存段的基地址、段的长度值和段的访问特权级别等信息。 在Linux0.11中，程序逻辑地址到线性地址的变换过程使用了CPU的全局段描述符表GDT和局部段描述符表LDT。 由GDT映射的地址空间称为全局地址空间，由LDT映射的地址空间则称为局部地址空间，而这两者构成了虚拟地址的空间。 2. 分页采用多级页表的形式进行分页。 控制寄存器CR3保存着是当前页目录表在物理内存中的基地址（因此CR3也被称为页目录基地址寄存器PDBR）。 32位的线性地址被分成三个部分： 页目录表中偏移。 页表中偏移。 页内偏移。 4. 例子以下边这段程序为例子，跟踪 i 的地址翻译过程。（即从逻辑地址怎么映射到物理地址的） 1234567891011121314#include &lt;stdio.h&gt;int i = 0x12345678;int main(void){ printf(&quot;The logical/virtual address of i is 0x%08x&quot;, &amp;i); fflush(stdout); while (i) ; return 0;} 运行以上程序，结果为： 1The logical/virtual address of i is 0x00003004 可知 i 的逻辑地址为0x00003004。 4.1 分段（逻辑地址 =&gt; 线性地址）ctrl+c 使Bochs暂停运行，进入调试状态： 1(0) [0x000000fa7063] 000f:00000063 (unk. ctxt): cmp dword ptr ds:0x00003004, 0x00000000 ; 833d0430000000 ds:0x3004是虚拟地址，ds表明这个地址属于ds段。 在GDT（全局描述符表）中找到LDT的基地址 1234567891011121314151617&lt;bochs:49&gt; sreges:0x0017, dh=0x10c0f300, dl=0x00003fff, valid=1 Data segment, base=0x10000000, limit=0x03ffffff, Read/Write, Accessedcs:0x000f, dh=0x10c0fb00, dl=0x00000002, valid=1 Code segment, base=0x10000000, limit=0x00002fff, Execute/Read, Non-Conforming, Accessed, 32-bitss:0x0017, dh=0x10c0f300, dl=0x00003fff, valid=1 Data segment, base=0x10000000, limit=0x03ffffff, Read/Write, Accessedds:0x0017, dh=0x10c0f300, dl=0x00003fff, valid=3 Data segment, base=0x10000000, limit=0x03ffffff, Read/Write, Accessedfs:0x0017, dh=0x10c0f300, dl=0x00003fff, valid=1 Data segment, base=0x10000000, limit=0x03ffffff, Read/Write, Accessedgs:0x0017, dh=0x10c0f300, dl=0x00003fff, valid=1 Data segment, base=0x10000000, limit=0x03ffffff, Read/Write, Accessedldtr:0x0068, dh=0x000082fa, dl=0xa2d00068, valid=1tr:0x0060, dh=0x00008bfa, dl=0xa2e80068, valid=1gdtr:base=0x00005cb8, limit=0x7ffidtr:base=0x000054b8, limit=0x7ff GDT的位置由gdtr明确给出，在物理地址的0x00005cb8。 ldtr是GDT的段选择子。0x0068=0000000001101000（二进制），表示LDT表存放在GDT表的1101(二进制)=13（十进制）号位置。 123&lt;bochs:50&gt; xp /2w 0x5cb8 + 13 * 8[bochs]:0x00005d20 &lt;bogus+ 0&gt;: 0xa2d00068 0x000082fa 段描述符定义如下： 组合出LDT的基地址：0x00faa2d0 在LDT中找到段描述符，将逻辑地址映射为线性地址 查看LDT： 1234&lt;bochs:51&gt; xp /8w 0xfaa2d0[bochs]:0x00faa2d0 &lt;bogus+ 0&gt;: 0x00000000 0x00000000 0x00000002 0x10c0fb000x00faa2e0 &lt;bogus+ 16&gt;: 0x00003fff 0x10c0f300 0x00000000 0x00fab000 根据ds为0x0017（0x0017=0000000000010111（二进制）），由段选择子的概念，得出是LDT中的第10（二进制）项。 LDT[2]的内容为0x00003fff 0x10c0f300，根据段描述符的概念可知：ds所代表的段的基址为0x10000000； 由：线性地址 = 段基址 + 段内偏移 所以ds:0x3004的线性地址就是：0x10000000 + 0x3004 = 0x10003004。 4.2 分页（线性地址 =&gt; 物理地址）从线性地址计算物理地址，需要查找页表。线性地址变成物理地址的过程如下： 0x10003004的页目录号是64，页号3，页内偏移是4。 IA-32下，页目录表的位置由CR3寄存器指引。查看CR3寄存器内容。 12345678&lt;bochs:52&gt; cregCR0=0x8000001b: PG cd nw ac wp ne ET TS em MP PECR2=page fault laddr=0x10002facCR3=0x000000000000 PCD=page-level cache disable=0 PWT=page-level write-through=0CR4=0x00000000: pke smap smep osxsave pcid fsgsbase smx vmx osxmmexcpt umip osfxsr pce pge mce pae pse de tsd pvi vmeEFER=0x00000000: ffxsr nxe lma lme sce 由上可知：页目录表的起始地址（CR3）为0x000000000000。 页目录表中的第64项为： 123&lt;bochs:54&gt; xp /w 0 + 64 * 4[bochs]:0x00000100 &lt;bogus+ 0&gt;: 0x00fa3027 ‘ 所以页表所在物理页框号为0x00fa3，即页表在物理内存的0x00fa3000位置。 查看页表0x00fa3000的第三页，有 123&lt;bochs:57&gt; xp /w 0x00fa3000 + 3 * 4[bochs]:0x00fa300c &lt;bogus+ 0&gt;: 0x00f9c067 组合上页内偏移，物理地址为0x00f9c004。 验证下： 123&lt;bochs:58&gt; xp /w 0x00f9c004[bochs]:0x00f9c004 &lt;bogus+ 0&gt;: 0x12345678 5. 总结 参考资料[1] linux内核完全注释 [2] 哈工大操作系统实验指导书","link":"/2023/03/06/linux-linux0-11-memory-map/"},{"title":"hitos - lab4 信号量的实现和应用解答","text":"所需数据结构（定义在头文件中，用户也需要知道）： 123456789101112131415161718#define SEM_FAILED (void*) 0#define SEM_NAME_MAX_LEN 16#define SEM_QUEUE_LEN 16struct semaphore_queue { int front; int rear; struct task_struct* wait_tasks[SEM_QUEUE_LEN];};typedef struct semaphore_queue sem_queue;struct semaphore_t { int val; int open_flag; char name[SEM_NAME_MAX_LEN]; sem_queue wait_queue;};typedef struct semaphore_t sem_t; 对上述数据结构的一些基本操作（实现了一个循环队列）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#define __LIBRARY__ #include &lt;unistd.h&gt; /* type def */#include &lt;linux/sched.h&gt; /* schedule */#include &lt;linux/kernel.h&gt; /* printk */#include &lt;asm/segment.h&gt; /* get_fs_byte */#include &lt;asm/system.h&gt; /* sti cli */#define SEM_COUNT 32sem_t semaphores[SEM_COUNT];void init_queue(sem_queue* q) { q-&gt;front = q-&gt;rear = 0;}int empty(sem_queue* q) { return q-&gt;front == q-&gt;rear ? 1 : 0;}int full(sem_queue* q) { return (q-&gt;rear + 1) % SEM_QUEUE_LEN == q-&gt;front ? 1 : 0;} struct task_struct* front(sem_queue* q) { if(empty(q)) { printk(&quot;front fail! no task in queue\\n&quot;); return NULL; } struct task_struct *tmp = q-&gt;wait_tasks[q-&gt;front]; return tmp;}void pop(sem_queue* q) { if (empty(q)) { printk(&quot;pop fail! no task in queue!\\n&quot;); return; } q-&gt;front = (q-&gt;front + 1) % SEM_QUEUE_LEN;}void push(sem_queue* q, struct task_struct* p) { if (full(q)) { printk(&quot;push fail! queue is full!\\n&quot;); return; } q-&gt;wait_tasks[q-&gt;rear] = p; q-&gt;rear = (q-&gt;rear + 1) % SEM_QUEUE_LEN;}int sem_exit(const char* name) { int i = 0; for (i = 0; i &lt; SEM_COUNT; ++i) { if (semaphores[i].open_flag == 1 &amp;&amp; strcmp(name, semaphores[i].name) == 0) { return i; } } return -1;} sem_open实现: 12345678910111213141516171819202122232425262728293031sem_t* sys_sem_open(const char* name, unsigned int value) { char buffer[SEM_NAME_MAX_LEN]; int i = 0; for (i = 0; i &lt; SEM_NAME_MAX_LEN; ++i) { buffer[i] = get_fs_byte(name + i); if (buffer[i] == '\\0') { break; } } if (i &gt;= SEM_NAME_MAX_LEN) { printk(&quot;name too long!\\n&quot;); return NULL; } int idx = sem_exit(buffer); if (idx != -1) { // exits return &amp;semaphores[idx]; } // not exits for (i = 0; i &lt; SEM_COUNT; ++i) { if (semaphores[i].open_flag == 0) { strcpy(semaphores[i].name, buffer); semaphores[i].open_flag = 1; semaphores[i].val = value; init_queue(&amp;(semaphores[i].wait_queue)); return &amp;semaphores[i]; } } // can't find a slot printk(&quot;MAX SEMAPHORE's NUMBER IS %d, NOW FULL!\\n&quot;, SEM_COUNT); return NULL;} sem_unlink实现: 1234567891011121314151617181920212223int sys_sem_unlink(const char *name) { char buffer[SEM_NAME_MAX_LEN]; int i = 0; for (i = 0; i &lt; SEM_NAME_MAX_LEN; ++i) { buffer[i] = get_fs_byte(name + i); if (buffer[i] == '\\0') { break; } } if (i &gt;= SEM_NAME_MAX_LEN) { printk(&quot;name too long!\\n&quot;); return -1; } int idx = sem_exit(buffer); if (idx == -1) { // not exits printk(&quot;SEM %s NOT EXIT\\n&quot;, buffer); return -1; } semaphores[idx].val = 0; semaphores[idx].open_flag = 0; strcpy(semaphores[idx].name, &quot;\\0&quot;); return 0;} sem_wait实现: 12345678910111213int sys_sem_wait(sem_t* sem) { if (sem == NULL) { return -1; } cli(); if (--sem-&gt;val &lt; 0) { current-&gt;state = TASK_UNINTERRUPTIBLE; push(&amp;(sem-&gt;wait_queue), current); schedule(); } sti(); return 0;} sem_wait实现: 123456789101112131415int sys_sem_post(sem_t* sem) { if (sem == NULL) { return -1; } cli(); if (++sem-&gt;val &lt;= 0) { struct task_struct* p = front(&amp;(sem-&gt;wait_queue)); if (p != NULL) { pop(&amp;(sem-&gt;wait_queue)); p-&gt;state = TASK_RUNNING; } } sti(); return 0;} 然后按添加系统调用的流程添加上系统调用即可。 有一个比较坑的地方是，添加的系统调用可能没用，编译不过去（拷贝个unistd.h到linux0.11即可）。","link":"/2023/03/06/linux-hitos-lab4/"},{"title":"POSIX信号量的使用","text":"1. 概述信号量分为有名信号量(named semaphore)，无名信号量(unnamed semaphore)。 (这里说的信号量主要是指semaphore.h中的信号量) 有名信号量由sem_open打开，无名信号量由sem_init打开. 有名信号量通过sem_unlink删除, 无名信号量通过sem_destroy删除信号量 有名信号量由内核持续，正是因此多个进程间才能利用它；无名信号量一般是线程之间使用，也可以搭配共享内存在多进程之间使用。 2. 函数原型12345678910111213141516171819#include &lt;semaphore.h&gt;// 有名信号量的操作sem_t *sem_open(const char *, int, ...);int sem_unlink(const char *);int sem_close(sem_t *);// 无名信号量的操作int sem_init(sem_t *, int, unsigned int);int sem_destroy(sem_t *);// 获取信号量值int sem_getvalue(sem_t *, int *);// 发出信号，即释放拥有权int sem_post(sem_t *);// 等待信号，即获取拥有权int sem_trywait(sem_t *);int sem_wait(sem_t *); 3. 用信号量解生产者-消费者问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;stdio.h&gt;#include &lt;semaphore.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#define NUMBER 50000#define CHILD 5#define BUFSIZE 10// critical resourceint fd;// semaphoresem_t* empty;sem_t* full;sem_t* mutex;void comsumer() { int buf_out = 0; int data = 0; int cnt = 0; for (int k = 0; k &lt; NUMBER / CHILD; k++) { sem_wait(full); sem_wait(mutex); // fetch buf_out lseek(fd, BUFSIZE * sizeof(int), SEEK_SET); read(fd, (char*)&amp;buf_out, sizeof(int)); cnt++; lseek(fd, sizeof(int) * buf_out, SEEK_SET); read(fd, (char*)&amp;data, sizeof(int)); printf(&quot;%d comsume %d %d\\n&quot;, getpid(), data, cnt); fflush(stdout); // write back buf_out = (buf_out + 1) % BUFSIZE; lseek(fd, BUFSIZE * sizeof(int), SEEK_SET); write(fd, (char *)&amp;buf_out, sizeof(int)); sem_post(mutex); sem_post(empty); } printf(&quot;%d total consume %d\\n&quot;, getpid(), cnt);}void producer() { int buf_in = 0; for (int i = 0 ; i &lt; NUMBER; i++) { sem_wait(empty); sem_wait(mutex); lseek(fd, buf_in * sizeof(int), SEEK_SET); write(fd, (char*)&amp;i, sizeof(int)); buf_in = (buf_in + 1) % BUFSIZE; printf(&quot;produce %d\\n&quot;, i); fflush(stdout); sem_post(mutex); sem_post(full); }}int main() { mutex = sem_open(&quot;mutex&quot;, O_CREAT | O_EXCL, 0644, 1); full = sem_open(&quot;full&quot;, O_CREAT | O_EXCL, 0644, 0); empty = sem_open(&quot;empty&quot;, O_CREAT | O_EXCL, 0644, BUFSIZE); int out_index = 0; fd = open(&quot;buffer.dat&quot;, O_CREAT | O_RDWR | O_TRUNC, 0666); lseek(fd, BUFSIZE * sizeof(int), SEEK_SET); write(fd, (char *)&amp;(out_index), sizeof(int)); pid_t p; // create producer if ((p = fork()) == 0) { producer(); return 0; } else if (p &lt; 0){ printf(&quot;Fail to fork!\\n&quot;); return -1; } // create comsumer for (int j = 0; j &lt; CHILD ; j++) { if ((p = fork()) == 0) { comsumer(); return 0; } else if (p &lt; 0) { printf(&quot;Fail to fork!\\n&quot;); return -1; } } int cnt = 0; printf(&quot;wait children!\\n&quot;); pid_t pid; while (pid = waitpid(-1, NULL, 0)) { if (errno == ECHILD) { break; } cnt ++; printf(&quot;pid: %d end | sum: %d\\n&quot;, pid, cnt); } sem_unlink(&quot;empty&quot;); sem_unlink(&quot;full&quot;); sem_unlink(&quot;mutex&quot;); return 0;} 编译命令： 1g++ pcc.c -o test -lpthread 参考资料[1] 信号量 [2] semaphore.h","link":"/2023/03/06/linux-posix-semaphore/"},{"title":"UNIX环境高级编程 - 信号量","text":"1. 概述信号量一个计数器，用于多进程对共享数据对象的存取。 P操作： 为了获得共享资源，进程需要执行下列操作: 测试控制该资源的信号量。 若此信号量的值为正，则进程可以使用该资源。进程将信号量值减1，表示它使用了一个资源单位。 若此信号量的值为0，则进程进入睡眠状态，直至信号量值大于0。若进程被唤醒后，它返回至第1步。 V操作： 当进程不再使用由一个信息量控制的共享资源时，该信号量值增1。如果有进程正在睡眠等待此信号量，则唤醒它们。 为了正确地实现信息量，信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的。 2. 获取信号量当使用XSI信号量时，首先需要通过调用函数 semget 来获得一个信号量ID。 123456#include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/sem.h&gt;int semget(key_t key, int nsems, int flag); 返回值：若成功，返回信号量ID；若出错，返回-1 nsems是该集合中的信号量数。如果是创建新集合(一般在服务器中)，则必须指定nsems。如果引用一个现存的集合(一个客户机)，则将nsems指定为0。 3. 信号量基本操作semctl 函数包含了多种信号量操作。 123456789101112#include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/sem.h&gt;int semctl(int semid, int semum, int cmd, . . . /* union semun arg */);union semun { int val; /* value for SETVAL */ struct semid_ds *buf; /* buffer for IPC_STAT &amp; IPC_SET */ u_short *array; /* array for GETALL &amp; SETALL */}; 对于除GETALL以外的所有GET命令，semctl函数都返回相应值。其他命令的返回值为0。 宏定义 作用 IPC_STAT 对此集合取semid_ds结构，并存储在由arg.buf指向的结构中。 IPC_SET 按arg.buf指向的结构中的值设置集合相关结构体中的相关成员。 IPC_RMID 从系统中删除该信号量集合。 GETVAL 返回成员semnum的semval值。 SETVAL 设置成员semnum的semval值。该值由arg.val指定。 GETPID 返回成员semnum的sempid的值。 GETNCNT 返回成员semnum的semncnt值 GETZCNT 返回成员semnum的semzcnt值。 GETALL 返回该集合中的所有的信号量值。 SETALL 将该集合中的所有的信号量设置成arg.array指向的数组中的值。 4. 信号量PV操作函数semop自动执行信号量集合上的操作数组。 123456789101112#include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/sem.h&gt;int semop(int semid, struct sembuf semoparray[ ], size_t nops); 返回值：若成功，返回信号量ID；若出错，返回-1 struct sembuf { unsigned short sem_num; /* member # in set (0, 1, …, nsems-1) */ short sem_op; /* operation (negative, 0, or positive) */ short sem_flg; /* IPC_NOWAIT, SEM_UNDO */}; 参数nops规定该数组中操作的数量（元素数）。 对集合中的每个成员的操作由相应的sem_op值规定。此值可以是负值、0或者是正值。 若sem_op为正值，则对应于进程释放占用的资源数。 若sem_op为负值，则表示要获得由该信号量控制的资源。 5. 包装（warp function）对相关api包装一下可以更加通用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748bool sem_get(const key_t key, int *sem_id) { *sem_id = semget((key_t)key, 1, 0666 | IPC_CREAT); if (*sem_id == -1) { printf(&quot;sem_get fail!\\n&quot;); return false; } return true;}bool sem_init(const int sem_id, const int val) { if (semctl(sem_id, 0, SETVAL, val) == -1) { printf(&quot;sem_init fail!\\n&quot;); return false; } return true;}bool sem_unlink(const int sem_id) { if (semctl(sem_id, 0, IPC_RMID, sem_id) == -1) { printf(&quot;sem_unlink fail!\\n&quot;); return false; } return true;}bool sem_wait(int sem_id) { struct sembuf buf; buf.sem_num = 0; buf.sem_op = -1; buf.sem_flg = 0; if(semop(sem_id, &amp;buf, 1) == -1) { printf(&quot;sem_wait fail! %d\\n&quot;, errno); return false; } return true;}bool sem_post(int sem_id) { struct sembuf buf; buf.sem_num = 0; buf.sem_op = +1; buf.sem_flg = 0; if(semop(sem_id, &amp;buf, 1) == -1) { printf(&quot;sem_post fail! %d\\n&quot;, errno); return false; } return true;} 6. 例子：用信号量解生产者-消费者模型生产者-消费者问题可以用信号量如下解决： 例子使用上述的warp函数，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195#include &lt;stdbool.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/wait.h&gt; #include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#define NUMBER 50000#define CHILD 5#define BUFSIZE 10bool sem_get(const key_t key, int* sem_id);bool sem_init(const int sem_id, const int val);bool sem_unlink(const int sem_id);bool sem_wait(const int semid); // Pbool sem_post(const int semid); // V#define IS_ERROR(ret) \\ do { \\ if (!ret) { \\ exit(0); \\ } \\ } while(0); \\// critical resourceint fd;// semaphoreint empty = -1;int full = -1;int mutex = -1;void comsumer() { int buf_out = 0; int data = 0; int cnt = 0; for (int k = 0; k &lt; NUMBER / CHILD; k++) { sem_wait(full); sem_wait(mutex); // fetch buf_out lseek(fd, BUFSIZE * sizeof(int), SEEK_SET); read(fd, (char*)&amp;buf_out, sizeof(int)); cnt++; lseek(fd, sizeof(int) * buf_out, SEEK_SET); read(fd, (char*)&amp;data, sizeof(int)); printf(&quot;%d comsume %d %d\\n&quot;, getpid(), data, cnt); fflush(stdout); // write back buf_out = (buf_out + 1) % BUFSIZE; lseek(fd, BUFSIZE * sizeof(int), SEEK_SET); write(fd, (char *)&amp;buf_out, sizeof(int)); sem_post(mutex); sem_post(empty); } printf(&quot;%d total consume %d\\n&quot;, getpid(), cnt);}void producer() { int buf_in = 0; for (int i = 0 ; i &lt; NUMBER; i++) { sem_wait(empty); sem_wait(mutex); lseek(fd, buf_in * sizeof(int), SEEK_SET); write(fd, (char*)&amp;i, sizeof(int)); buf_in = (buf_in + 1) % BUFSIZE; printf(&quot;produce %d\\n&quot;, i); fflush(stdout); sem_post(mutex); sem_post(full); }}int main() { int ret = sem_get(123, &amp;empty); IS_ERROR(ret); ret = sem_get(234, &amp;full); IS_ERROR(ret); ret = sem_get(345, &amp;mutex); IS_ERROR(ret); ret = sem_init(empty, BUFSIZE); IS_ERROR(ret); ret = sem_init(full, 0); IS_ERROR(ret); ret = sem_init(mutex, 1); IS_ERROR(ret); int out_index = 0; fd = open(&quot;buffer.dat&quot;, O_CREAT | O_RDWR | O_TRUNC, 0666); lseek(fd, BUFSIZE * sizeof(int), SEEK_SET); write(fd, (char *)&amp;(out_index), sizeof(int)); pid_t p; // create producer if((p = fork()) == 0) { producer(); return 0; } else if(p &lt; 0){ printf(&quot;Fail to fork!\\n&quot;); return -1; } // create comsumer for(int j = 0; j &lt; CHILD ; j++) { if((p = fork()) == 0) { comsumer(); return 0; } else if(p &lt; 0) { printf(&quot;Fail to fork!\\n&quot;); return -1; } } int cnt = 0; printf(&quot;wait children!\\n&quot;); pid_t pid; while (pid = waitpid(-1, NULL, 0)) { if (errno == ECHILD) { break; } cnt ++; printf(&quot;pid: %d end | sum: %d\\n&quot;, pid, cnt); } ret = sem_unlink(empty); IS_ERROR(ret); ret = sem_unlink(full); IS_ERROR(ret); ret = sem_unlink(mutex); IS_ERROR(ret); return 0;}bool sem_get(const key_t key, int *sem_id) { *sem_id = semget((key_t)key, 1, 0666 | IPC_CREAT); if (*sem_id == -1) { printf(&quot;sem_get fail!\\n&quot;); return false; } return true;}bool sem_init(const int sem_id, const int val) { if (semctl(sem_id, 0, SETVAL, val) == -1) { printf(&quot;sem_init fail!\\n&quot;); return false; } return true;}bool sem_unlink(const int sem_id) { if (semctl(sem_id, 0, IPC_RMID, sem_id) == -1) { printf(&quot;sem_unlink fail!\\n&quot;); return false; } return true;}bool sem_wait(int sem_id) { struct sembuf buf; buf.sem_num = 0; buf.sem_op = -1; buf.sem_flg = 0; if(semop(sem_id, &amp;buf, 1) == -1) { printf(&quot;sem_wait fail! %d\\n&quot;, errno); return false; } return true;}bool sem_post(int sem_id) { struct sembuf buf; buf.sem_num = 0; buf.sem_op = +1; buf.sem_flg = 0; if(semop(sem_id, &amp;buf, 1) == -1) { printf(&quot;sem_post fail! %d\\n&quot;, errno); return false; } return true;}","link":"/2023/03/06/linux-semaphore/"},{"title":"Ubuntu18.04 静态IP","text":"查看本机的网关(重要，涉及到连接互联网问题) 1route -n 查看本机IP信息 1ifconfig 修改配置文件 1sudo vim /etc/netplan/01-network-manager-all.yaml 按照上文查询到的信息进行修改： 1234567891011# Let NetworkManager manage all devices on this systemnetwork: version: 2 renderer: networkd ethernets: ens33: dhcp4: no addresses: [192.168.48.130/24] gateway4: 192.168.48.2 nameservers: addresses: [8.8.8.8, 114.114.114.114] 重启网络服务： 1sudo netplan apply","link":"/2023/03/06/ubuntu-static-ip/"},{"title":"Ubuntu18.04 ssh免密码登陆","text":"Ubuntu18.04 ssh免密码登陆： 客户端（发起ssh端）配置好ssh公私钥。 12# 连按三个回车即可，生成的key在~/.ssh下ssh-keygen -t rsa -C &quot;your mail&quot; 服务器端（ssh服务器端）启动ssh。 12345678# 未安装ssh server则先安装之sudo apt install openssh-server# 启动sshdsudo service ssh start# 查看sshd启动与否ps -aux | grep ssh 将客户端的key复制到服务器端。 1ssh-copy-id ubuntu@192.168.48.130","link":"/2023/03/06/ubuntu-ssh-login/"},{"title":"yum安装报错No package xxx available","text":"Cent OS7使用yum安装软件出现 No package xxx available. [chenxinlong@localhost Documents]$ sudo yum install tldr[sudo] password for chenxinlong:Loaded plugins: fastestmirror, langpacksLoading mirror speeds from cached hostfile base: mirrors.cn99.com centos-sclo-rh: mirrors.nju.edu.cn centos-sclo-sclo: mirrors.nju.edu.cn extras: mirrors.nju.edu.cn updates: mirrors.nju.edu.cnNo package tldr available.Error: Nothing to do 使用 1sudo yum install epel-release 使用yum搜索某些rpm包，找不到包是因为CentOS是RedHat企业版编译过来的，去掉了所有关于版权问题的东西。 安装EPEL后可以很好的解决这个问题。EPEL(Extra Packages for Enterprise Linux )即企业版Linux的扩展包，提供了很多可共Centos使用的组件，安装完这个以后基本常用的rpm都可以找到[1]。 [1] yum安装时提示No package xxx available的解决方案","link":"/2023/03/06/debug-yum-install-error/"},{"title":"git push问题：Connection reset by peer","text":"在git push时遇到如下问题： kex_exchange_identification: read: Connection reset by peerfatal: Could not read from remote repository. Please make sure you have the correct access rightsand the repository exists. 再尝试了更改rsa密钥等一系列行为后不行，看到stackoverflow上的方法，尝试下： 1git init 成功了。 原文： I had a similar issue recently, I’m not sure whether its exactly the same as I got the connected user by following command. ssh -T git@gitlab.com But when I try to push the code to remote repository I got same error. 12345kex_exchange_identification: read: Connection reset by peerfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. After trying few solutions from the internet without success, I just tried git init and it worked for me. I hope this works only if the connection user has bound correctly. Try it out Good Luck.. :)","link":"/2023/03/06/debug-git-push-error/"},{"title":"shell中的set -e &amp; set -u","text":"set -e: 表示此命令后，当某命令返回值非0时，将出错。如果是非交互环境，将直接退出，不再执行后续命令set +e: set -e的反向操作，恢复bash shell的默认行为，命令失败后继续执行后续命令 set -u: (set -o nounset), 表示此命令之后，当某命令使用了未定义变量或参数时（特殊参数“@”和“*”除外），将打印错误信息。如果是非交互环境（通常为脚本中），将直接退出，不再执行后续命令set +u: set -u的反向操作，恢复bash shell的默认行为，命令使用未定义变量或参数时，继续执行后续命令","link":"/2023/03/06/linux-shell-set/"},{"title":"linux0.11 - 进程调度函数分析","text":"0 引言进程是操作系统分配资源的最小单位；线程是程序执行的最小单位。计算机上运行着几十上百个程序，对于每个程序而言，他们都是独享CPU的，操作系统制造了这一有多个CPU的假象。这一假象得以维持的基础就在于进程之间的切换，而进程切换则需要用到进程调度，具体的进程调度内容可以看之前的博文：操作系统-进程调度。 但是空说无凭，理论还是需要结合实际，这篇博文将从linux0.11入手，看一个实际的调度函数。 1 源码分析1.1 时间片轮转在BIOS引导进入系统后，会执行系统的main函数（init/main.c）： 12345678910111213141516void main(void) /* This really IS void, no error here. */{ /* The startup routine assumes (well, ...) this *//* * Interrupts are still disabled. Do necessary setups, then * enable them */ ... sched_init(); ... move_to_user_mode(); if (!fork()) { /* we count on this going ok */ init(); } for(;;) pause();} 其中进行了很多的初始化操作，包括 sched_init，这便是内核调度程序的初始化子程序(kernel/sched.c)，其定义如下： 12345678910void sched_init(void){ ... outb_p(0x36,0x43); /* binary, mode 3, LSB/MSB, ch 0 */ outb_p(LATCH &amp; 0xff , 0x40); /* LSB */ outb(LATCH &gt;&gt; 8 , 0x40); /* MSB */ set_intr_gate(0x20,&amp;timer_interrupt); ...} sched_init 初始化了8253定时器（微机原理与接口技术学过的），8253每10ms发出一个中断请求信号。然后设置了一个中断服务程序 timer_interrupt，即每10ms中断一次，执行一次 timer_interrupt 。 timer_interrupt 在kernel/system_call.s中定义，为一段汇编程序： 1234567891011121314151617181920212223.align 2timer_interrupt: push %ds # save ds,es and put kernel data space push %es # into them. %fs is used by _system_call push %fs pushl %edx # we save %eax,%ecx,%edx as gcc doesn't pushl %ecx # save those across function calls. %ebx pushl %ebx # is saved as we use that in ret_sys_call pushl %eax movl $0x10,%eax mov %ax,%ds mov %ax,%es movl $0x17,%eax mov %ax,%fs incl jiffies movb $0x20,%al # EOI to interrupt controller #1 outb %al,$0x20 movl CS(%esp),%eax andl $3,%eax # %eax is CPL (0 or 3, 0=supervisor) pushl %eax call do_timer # 'do_timer(long CPL)' does everything from addl $4,%esp # task switching to accounting ... jmp ret_from_sys_call 可以发现，其核心为一句 call do_timer，即调用 do_timer 函数。 do_timer 函数在kernel/sched.c中定义， 123456789void do_timer(long cpl){ ... if ((--current-&gt;counter)&gt;0) return; current-&gt;counter=0; // 内核中不调度 if (!cpl) return; schedule();} 其调用了一个 schedule(), 这个 schedule() 函数选出下一个要执行的进程，并且切换到它，这是今天的主角！ 通过上面的分析可以发现，counter 扮演了时间片的角色，每一次8253产生中断会调用中断服务程序，使 counter 减1，减到0则调用调度函数 schedule()，这是一个十分明显的round robin（时间片轮转）策略。 1.2 优先级调度先看看 schedule() 函数的全貌吧，只看片段容易盲人摸象： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * 'schedule()' is the scheduler function. This is GOOD CODE! There * probably won't be any reason to change this, as it should work well * in all circumstances (ie gives IO-bound processes good response etc). * The one thing you might take a look at is the signal-handler code here. * * NOTE!! Task 0 is the 'idle' task, which gets called when no other * tasks can run. It can not be killed, and it cannot sleep. The 'state' * information in task[0] is never used. */void schedule(void){ int i,next,c; struct task_struct ** p;/* check alarm, wake up any interruptible tasks that have got a signal */ for(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p) if (*p) { if ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) { (*p)-&gt;signal |= (1&lt;&lt;(SIGALRM-1)); (*p)-&gt;alarm = 0; } if (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp; (*p)-&gt;state==TASK_INTERRUPTIBLE) { (*p)-&gt;state=TASK_RUNNING; } }/* this is the scheduler proper: */ while (1) { c = -1; next = 0; i = NR_TASKS; p = &amp;task[NR_TASKS]; while (--i) { if (!*--p) continue; if ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c) c = (*p)-&gt;counter, next = i; } if (c) break; for(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p) if (*p) (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; 1) + (*p)-&gt;priority; } switch_to(next);} schedule() 函数中，第一个for循环处理了很多信号的响应，这不是调度的重点（毕竟next代表选出的下一个要运行的进程，这一段还没有next相关的操作呢。。。）。 重点聚焦于 while (1) 循环，毕竟注释也写了，这是调度程序的主要部分。 下面的代码展示了调度策略，从任务数组的最后一个任务开始循环处理，跳过不含任务的数组槽。选择就绪任务中 counter 值最大的任务（说明），若有 counter 值不为0的结果或系统没有一个可运行任务（此时next为0）存在，则选择next对应进程进行切换。 12345678c = -1, next = 0, i = NR_TASKS, p = &amp;task[NR_TASKS];while (--i) { if (!*--p) continue; if ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c) c = (*p)-&gt;counter, next = i;}if (c) break; 若就绪任务中 counter 值全为0，则根据每个任务的优先权值更新每一个任务（全部任务，包含阻塞的）的 counter 值。 123for(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p) if (*p) (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; 1) + (*p)-&gt;priority; 从上面的式子也可以看出来，若某些任务一直执行 counter 调整，其 counter 值是趋向于 2 * (*p)-&gt;priority 的（级数，自己可以算一下）。 综上，schedule() 函数的行为为： 找 counter 值最大的任务调度， counter 表示了优先级。 counter 代表的优先级可以动态调整。 因为2的存在，阻塞的进程再就绪后，其优先级会高于非阻塞进程。阻塞是因为发生了I/O，而I/O则是前台进程的特征，所以该调度策略照顾了前台进程。 2 总结正如Linus Torvalds所说，这确实是个GOOD CODE！！！ 短短的一点代码实现的一个简单的算法，包含了优先级、时间片轮转等多种算法，解决了大多数任务的需求，大佬牛逼，给大佬打call！！！ 3 参考文献[1] Linux内核完全注释：基于0.11内核 · 赵烔 [2] 哈工大操作系统课程 · 李治军","link":"/2023/03/06/linux-linux0-11-sched/"},{"title":"hitos - lab3 进程运行轨迹的跟踪与统计解答","text":"实验内容进程从创建（Linux下调用fork()）到结束的整个过程就是进程的生命期，进程在其生命期中的运行轨迹实际上就表现为进程状态的多次切换，如进程创建以后会成为就绪态；当该进程被调度以后会切换到运行态；在运行的过程中如果启动了一个文件读写操作，操作系统会将该进程切换到阻塞态（等待态）从而让出CPU；当文件读写完毕以后，操作系统会在将其切换成就绪态，等待进程调度算法来调度该进程执行…… 本次实验包括如下内容： 基于模板“process.c”编写多进程的样本程序，实现如下功能： 所有子进程都并行运行，每个子进程的实际运行时间一般不超过30秒； 父进程向标准输出打印所有子进程的id，并在所有子进程都退出后才退出； 在Linux 0.11上实现进程运行轨迹的跟踪。基本任务是在内核中维护一个日志文件/var/process.log，把从操作系统启动到系统关机过程中所有进程的运行轨迹都记录在这一log文件中。 在修改过的0.11上运行样本程序，通过分析log文件，统计该程序建立的所有进程的等待时间、完成时间（周转时间）和运行时间，然后计算平均等待时间，平均完成时间和吞吐量。可以自己编写统计程序，也可以使用python脚本程序—— stat_log.py ——进行统计。 修改0.11进程调度的时间片，然后再运行同样的样本程序，统计同样的时间数据，和原有的情况对比，体会不同时间片带来的差异。 实验手册：参考 实验过程编写样本程序所谓样本程序，就是一个生成各种进程的程序。我们的对0.11的修改把系统对它们的调度情况都记录到log文件中。在修改调度算法或调度参数后再运行完全一样的样本程序，可以检验调度算法的优劣。理论上，此程序可以在任何Unix/Linux上运行，所以建议在Ubuntu上调试通过后，再拷贝到0.11下运行。 process.c编写： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;sys/times.h&gt;#include &lt;sys/wait.h&gt;#define HZ 100const int sum_time = 30;void cpuio_bound(int last, int cpu_time, int io_time);int main(int argc, char * argv[]){ int num = sum_time / 2; pid_t pid; int i = 0; for (i = 0; i &lt;= num; i++) { pid = fork(); if (pid == 0) { cpuio_bound(sum_time, i, sum_time - i); return 0; } else if (pid &gt; 0){ printf (&quot;the %d-th child process id: %d\\n&quot;, i, pid); } else { printf (&quot;fork error!&quot;); } } do { wait(NULL); } while (num--); return 0;}/* * 此函数按照参数占用CPU和I/O时间 * last: 函数实际占用CPU和I/O的总时间，不含在就绪队列中的时间，&gt;=0是必须的 * cpu_time: 一次连续占用CPU的时间，&gt;=0是必须的 * io_time: 一次I/O消耗的时间，&gt;=0是必须的 * 如果last &gt; cpu_time + io_time，则往复多次占用CPU和I/O * 所有时间的单位为秒 */void cpuio_bound(int last, int cpu_time, int io_time){ struct tms start_time, current_time; clock_t utime, stime; int sleep_time; while (last &gt; 0) { /* CPU Burst */ times(&amp;start_time); /** 其实只有t.tms_utime才是真正的CPU时间。但我们是在模拟一个 * 只在用户状态运行的CPU大户，就像“for(;;);”。所以把t.tms_stime * 加上很合理。*/ do { times(&amp;current_time); utime = current_time.tms_utime - start_time.tms_utime; stime = current_time.tms_stime - start_time.tms_stime; } while ( ( (utime + stime) / HZ ) &lt; cpu_time ); last -= cpu_time; if (last &lt;= 0 ) break; /* IO Burst */ /* 用sleep(1)模拟1秒钟的I/O操作 */ sleep_time=0; while (sleep_time &lt; io_time) { sleep(1); sleep_time++; } last -= sleep_time; }} log文件操作系统启动后先要打开/var/process.log，然后在每个进程发生状态切换的时候向log文件内写入一条记录，其过程和用户态的应用程序没什么两样。然而，因为内核状态的存在，使过程中的很多细节变得完全不一样。 打开log文件为了能尽早开始记录，应当在内核启动时就打开log文件。内核的入口是init/main.c中的main()。fork时会继承文件句柄，因此可以在进程0直接打开日志文件，这样子进程都拥有打开日志文件的句柄了。 123456789setup((void *) &amp;drive_info);(void) open(&quot;/dev/tty0&quot;,O_RDWR,0);(void) dup(0);(void) dup(0);(void) open(&quot;/var/process.log&quot;, O_CREAT | O_TRUNC | O_WRONLY, 0666);if (!fork()) { /* we count on this going ok */ init();} 写log文件log文件将被用来记录进程的状态转移轨迹。所有的状态转移都是在内核进行的。在内核状态下，write()功能失效，只能调用printk()。编写可在内核调用的write()的难度较大，所以这里直接给出源码。它主要参考了printk()和sys_write()而写成的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;linux/sched.h&gt;#include &lt;sys/stat.h&gt;static char logbuf[1024];int fprintk(int fd, const char *fmt, ...){ va_list args; int count; struct file * file; struct m_inode * inode; va_start(args, fmt); count=vsprintf(logbuf, fmt, args); va_end(args); if (fd &lt; 3) /* 如果输出到stdout或stderr，直接调用sys_write即可 */ { __asm__(&quot;push %%fs\\n\\t&quot; &quot;push %%ds\\n\\t&quot; &quot;pop %%fs\\n\\t&quot; &quot;pushl %0\\n\\t&quot; &quot;pushl $logbuf\\n\\t&quot; /* 注意对于Windows环境来说，是_logbuf,下同 */ &quot;pushl %1\\n\\t&quot; &quot;call sys_write\\n\\t&quot; /* 注意对于Windows环境来说，是_sys_write,下同 */ &quot;addl $8,%%esp\\n\\t&quot; &quot;popl %0\\n\\t&quot; &quot;pop %%fs&quot; ::&quot;r&quot; (count),&quot;r&quot; (fd):&quot;ax&quot;,&quot;cx&quot;,&quot;dx&quot;); } else /* 假定&gt;=3的描述符都与文件关联。事实上，还存在很多其它情况，这里并没有考虑。*/ { if (!(file=task[0]-&gt;filp[fd])) /* 从进程0的文件描述符表中得到文件句柄 */ return 0; inode=file-&gt;f_inode; __asm__(&quot;push %%fs\\n\\t&quot; &quot;push %%ds\\n\\t&quot; &quot;pop %%fs\\n\\t&quot; &quot;pushl %0\\n\\t&quot; &quot;pushl $logbuf\\n\\t&quot; &quot;pushl %1\\n\\t&quot; &quot;pushl %2\\n\\t&quot; &quot;call file_write\\n\\t&quot; &quot;addl $12,%%esp\\n\\t&quot; &quot;popl %0\\n\\t&quot; &quot;pop %%fs&quot; ::&quot;r&quot; (count),&quot;r&quot; (file),&quot;r&quot; (inode):&quot;ax&quot;,&quot;cx&quot;,&quot;dx&quot;); } return count;} 使用： 12345//向stdout打印正在运行的进程的IDfprintk(1, &quot;The ID of running process is %ld&quot;, current-&gt;pid); //向log文件输出fprintk(3, &quot;%ld\\t%c\\t%ld\\n&quot;, current-&gt;pid, 'R', jiffies); 跟踪进程运行轨迹jiffies，滴答jiffies在kernel/sched.c文件中定义为一个全局变量： 1long volatile jiffies=0; 它记录了从开机到当前时间的时钟中断发生次数。在kernel/sched.c文件中的sched_init()函数中，时钟中断处理函数被设置为： 1set_intr_gate(0x20,&amp;timer_interrupt); 而在kernel/system_call.s文件中将timer_interrupt定义为： 1234timer_interrupt: …… incl jiffies #增加jiffies计数值 …… 这说明jiffies表示从开机时到现在发生的时钟中断次数，这个数也被称为“滴答数”。 另外，在kernel/sched.c中的sched_init()中有下面的代码： 123outb_p(0x36, 0x43); //设置8253模式outb_p(LATCH&amp;0xff, 0x40);outb_p(LATCH&gt;&gt;8, 0x40); 这三条语句用来设置每次时钟中断的间隔，即为LATCH，而LATCH是定义在文件kernel/sched.c中的一个宏： 12#define LATCH (1193180/HZ)#define HZ 100 //在include/linux/sched.h中 再加上PC机8253定时芯片的输入时钟频率为1.193180MHz，即1193180/每秒，LATCH=1193180/100，时钟每跳11931.8下产生一次时钟中断，即每1/100秒（10ms）产生一次时钟中断，所以jiffies实际上记录了从开机以来共经过了多少个10ms。 寻找状态切换点有5个状态，分别是创建（N)、运行（R)、就绪（J)、睡眠（W)、退出（E)。 在 fork.c、sche.c、exit.c文件中添加相应的print语句即可。 关注state 改变的时机即可。 fork.c： 1234567891011121314151617int copy_process(int nr,long ebp,long edi,long esi,long gs,long none, long ebx,long ecx,long edx, long fs,long es,long ds, long eip,long cs,long eflags,long esp,long ss){ p = (struct task_struct *) get_free_page(); ... p-&gt;state = TASK_UNINTERRUPTIBLE; ... p-&gt;start_time = jiffies; fprintk (3, &quot;%ld\\t%c\\t%ld\\n&quot;, p-&gt;pid, 'N', jiffies); ... p-&gt;state = TASK_RUNNING; /* do this last, just in case */ fprintk (3, &quot;%ld\\t%c\\t%ld\\n&quot;, p-&gt;pid, 'J', jiffies); return last_pid;} sche.c： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394void schedule(void){ int i,next,c; struct task_struct ** p;/* check alarm, wake up any interruptible tasks that have got a signal */ for(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p) if (*p) { if ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) { (*p)-&gt;signal |= (1&lt;&lt;(SIGALRM-1)); (*p)-&gt;alarm = 0; } if (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp; (*p)-&gt;state==TASK_INTERRUPTIBLE) { (*p)-&gt;state=TASK_RUNNING; fprintk(3, &quot;%d\\t%c\\t%d\\n&quot;, (*p)-&gt;pid, 'J', jiffies); } } /* this is the scheduler proper: */ ... // NEXT IS NEXT PROCESS WILL RUN! if (task[next]-&gt;pid != current-&gt;pid) { if (current-&gt;state == TASK_RUNNING) { fprintk(3, &quot;%d\\t%c\\t%d\\n&quot;, current-&gt;pid, 'J', jiffies); } fprintk(3, &quot;%d\\t%c\\t%d\\n&quot;, task[next]-&gt;pid, 'R', jiffies); } switch_to(next);}int sys_pause(void){ current-&gt;state = TASK_INTERRUPTIBLE; if (current-&gt;pid != 0) { fprintk(3, &quot;%d\\t%c\\t%d\\n&quot;, current-&gt;pid, 'W', jiffies); } schedule(); return 0;}void sleep_on(struct task_struct **p){ struct task_struct *tmp; if (!p) return; if (current == &amp;(init_task.task)) panic(&quot;task[0] trying to sleep&quot;); tmp = *p; *p = current; current-&gt;state = TASK_UNINTERRUPTIBLE; fprintk(3, &quot;%d\\t%c\\t%d\\n&quot;, current-&gt;pid, 'W', jiffies); schedule(); if (tmp) { tmp-&gt;state=0; fprintk(3, &quot;%d\\t%c\\t%d\\n&quot;, tmp-&gt;pid, 'J', jiffies); }}void interruptible_sleep_on(struct task_struct **p){ struct task_struct *tmp; if (!p) return; if (current == &amp;(init_task.task)) panic(&quot;task[0] trying to sleep&quot;); tmp=*p; *p=current;repeat: current-&gt;state = TASK_INTERRUPTIBLE; fprintk(3, &quot;%d\\t%c\\t%d\\n&quot;, current-&gt;pid, 'W', jiffies); schedule(); if (*p &amp;&amp; *p != current) { (**p).state=0; fprintk(3, &quot;%d\\t%c\\t%d\\n&quot;, (**p).pid, 'J', jiffies); goto repeat; } *p=NULL; if (tmp) { tmp-&gt;state=0; fprintk(3, &quot;%d\\t%c\\t%d\\n&quot;, tmp-&gt;pid, 'J', jiffies); }}void wake_up(struct task_struct **p){ if (p &amp;&amp; *p) { (**p).state=0; fprintk(3, &quot;%d\\t%c\\t%d\\n&quot;, (**p).pid, 'J', jiffies); *p=NULL; }} exit.c: 1234567891011121314151617181920212223242526272829int do_exit(long code){ int i; free_page_tables(get_base(current-&gt;ldt[1]),get_limit(0x0f)); free_page_tables(get_base(current-&gt;ldt[2]),get_limit(0x17)); ... current-&gt;state = TASK_ZOMBIE; fprintk(3, &quot;%ld\\t%c\\t%ld\\n&quot;, current-&gt;pid, 'E', jiffies); schedule(); return (-1); /* just to suppress warnings */}int sys_waitpid(pid_t pid,unsigned long * stat_addr, int options){ ... if (flag) { if (options &amp; WNOHANG) return 0; current-&gt;state=TASK_INTERRUPTIBLE; fprintk(3, &quot;%ld\\t%c\\t%ld\\n&quot;, current-&gt;pid, 'W', jiffies); schedule(); if (!(current-&gt;signal &amp;= ~(1&lt;&lt;(SIGCHLD-1)))) goto repeat; else return -EINTR; } return -ECHILD;} 修改时间片对于时间片counter,由于时间片的初始化操作为：p-&gt;counter = p-&gt;priority只与优先级priority有关，所以只需要修改priority即可在定义priority宏中修改即可 123#define INIT_TASK \\ { 0,15,15,// 上述三个值分别对应 state、counter 和 priority; 实验结果把process.c放在linux0.11上编译运行，如下： 然后是获得log，把log从linux0.11中移出来即可。 使用默认的分析程序对时间片为10、15、20的情况进行分析： process-10.log: 123456789101112131415161718Process Turnaround Waiting CPU Burst I/O Burst 7 3383 88 0 3295 8 4772 1481 100 3190 9 6051 2770 200 3080 10 7230 3960 300 2970 11 8309 5049 400 2860 12 9288 6038 500 2750 13 10168 6927 600 2640 14 10947 7716 700 2530 15 11626 8406 800 2420 16 12088 8905 900 2283 17 12532 9394 1000 2137 18 12875 9783 1100 1991 19 13136 10072 1200 1863 20 13297 10262 1300 1735 21 13367 10351 1400 1616 22 13356 10340 1500 1515Average: 10151.56 6971.38 process-15.log: 12345678910111213141516171819Process Turnaround Waiting CPU Burst I/O Burst 7 3403 238 0 3165 8 4632 1481 100 3050 9 5991 2841 200 2950 10 7240 4090 300 2850 11 8199 5064 400 2735 12 9244 6108 500 2635 13 10178 7042 600 2535 14 10877 7747 700 2430 15 11601 8476 800 2325 16 12214 9095 900 2218 17 12617 9529 1000 2087 18 13014 9943 1100 1970 19 13301 10248 1200 1853 20 13442 10412 1300 1730 21 13528 10511 1400 1616 22 13516 10500 1500 1515Average: 10187.31 7082.81Throughout: 0.12/s process-20.log: 12345678910111213141516171819Process Turnaround Waiting CPU Burst I/O Burst 7 3913 313 0 3600 8 5272 1691 100 3480 9 6531 2970 200 3360 10 7690 4150 300 3240 11 8749 5229 400 3120 12 9709 6208 500 3000 13 10568 7087 600 2880 14 11327 7867 700 2760 15 11967 8546 800 2621 16 12451 9125 900 2426 17 12815 9604 1000 2210 18 13117 9983 1100 2033 19 13358 10264 1200 1894 20 13498 10443 1300 1755 21 13538 10522 1400 1616 22 13517 10501 1500 1515Average: 10501.25 7156.44Throughout: 0.12/s 可以发现，时间片为10的时候平均周转时间和平均等待时间竟然是最短的！ linux还说这是个很好的调度函数呢。。（看来也不是太好。。。 但是，对时间片为10的情况仔细分析，可以发现：父进程没有一次性创建16子进程，另外的是时间片中断后创建的。 后续的进程新建的时间晚很多，这就拉低了平均数！！ 时间片为15时，是一次性fork出的： 时间片为20时也是一样： 相较于20的时间片，15明显更优；若是考虑上时间片为10得拉到平均值效果，15的时间片其实也是更优的选择。 所以呢，时间片为15还是最佳的方案（创建少点进程，效果会更明显），linux老爷子还是做过相关实验的。。。 遇到的问题如果有自己搭建环境做实验，然后linux崩了的（kernel panic ），可以尝试使用实验楼的环境，可能自己的环境是有问题的。 reference[1] 实验指导书","link":"/2023/03/06/linux-hitos-lab3/"},{"title":"CMU15445 - lab1","text":"本文为本人完成15445 2020fall（B+树版本）时的一些记录，仅作为备忘录使用。 TASK #1 - LRU REPLACEMENT POLICY本任务为实现一个LRU页面置换策略，建立一个关于面向磁盘的数据库的基本的概念是很重要的，如下图： 从中可以看出，实际数据是持久化存储于磁盘之上的，执行引擎主要进行一些数据操作（读/写，也即对Page增删改查），而BufferPool则是介于执行引擎和磁盘之间，位于内存中，给执行引擎提供Page。由于存储器体系结构一般表现为内存容量远小于磁盘容量，因此BufferPool是无法加载整个db的所有Pages的，因此需要在合适的时机将Page写入磁盘中，LRU就决定了牺牲哪个Page（即将哪个Page写回到磁盘中），其中包含了局部性原理的思想。 在Buffer Pool中，Page是存放在frame中的，这是要注意的一个点（buffer pool就是一个能容放多个Page的vector）。 The size of the LRUReplacer is the same as buffer pool since it contains placeholders for all of the frames in the BufferPoolManager. However, not all the frames are considered as in the LRUReplacer. The LRUReplacer is initialized to have no frame in it. Then, only the newly unpinned ones will be considered in the LRUReplacer. 所要实现的接口主要是下面四个： Victim(T*) : Remove the object that was accessed the least recently compared to all the elements being tracked by the Replacer, store its contents in the output parameter and return True. If the Replacer is empty return False. Pin(T) : This method should be called after a page is pinned to a frame in the BufferPoolManager. It should remove the frame containing the pinned page from the LRUReplacer. Unpin(T) : This method should be called when the pin_count of a page becomes 0. This method should add the frame containing the unpinned page to the LRUReplacer. Size() : This method returns the number of frames that are currently in the LRUReplacer. LRU的实现十分的简单，是经典的leetcode题，用list套一个unordered_map即可实现。 下面主要讲一下我对Pin和UnPin的理解： Pin(T) : 将一个Page(frame)从LRU的list中剔除。即该Page(frame)被Buffer Pool所使用了，LRU不应该牺牲该页面。 Unpin(T) : 加入一个Page(frame)入LRU的list。即该页面Buffer Pool目前没人使用了，LRU根据策略决定该页面的去留。 Victim(T*) :意思很直接，LRU根据规则（最近最少使用）有选择性的牺牲一个页面(frame)。 并发的话，直接加大锁就好了。std::lock_guard是一种RAII的加锁方式，可以不用unlock（在析构的时候unlock），比较方便。给出Victim的实现方法，其他的应 Prof. Pavlo 要求就不放出来了。 1234567891011bool LRUReplacer::Victim(frame_id_t *frame_id) { std::lock_guard&lt;std::mutex&gt; lock(latch_); if (id2iter_.empty()) { return false; } auto deleting_id = lru_list_.back(); lru_list_.pop_back(); id2iter_.erase(deleting_id); *frame_id = deleting_id; return true;} TASK #2 - BUFFER POOL MANAGER第二个任务为构造一个Buffer Pool。 The BufferPoolManager is responsible for fetching database pages from the DiskManager and storing them in memory. The BufferPoolManager can also write dirty pages out to disk when it is either explicitly instructed to do so or when it needs to evict a page to make space for a new page. 实现以下几个接口： FetchPageImpl(page_id) NewPageImpl(page_id) UnpinPageImpl(page_id, is_dirty) FlushPageImpl(page_id) DeletePageImpl(page_id) FlushAllPagesImpl() (其实可以先通过测试程序了解这几个接口怎么用的，然后再去实现会比较好！) NewPageImpl(page_id)：新建一个Page。 FetchPageImpl(page_id)：获取一个Page。 UnpinPageImpl(page_id, is_dirty)：解除对某个Page的使用（别的进程可能还在使用，pin_count为0的时候可以删除） DeletePageImpl(page_id)：删除一个Page。 FlushPageImpl(page_id)：强制将某个Page写盘。 FlushAllPagesImpl()：将所有Page写盘。 这个task其实本质上就是考验对下面两个点的理解，根据提示看看DiskManager 的API是比较好实现的： Dirty Flag ：当该flag为真时，该页被写过了，要写回磁盘。 Pin/Reference Counter：引用计数，当该计数为0时，将对应frame加入LRU中；当该计数不为0时，将对应frame从LRU中删除（即不参与LRU的替换）。 该task有几个坑需要注意一下： 重复UnpinPageImpl，但is_dirty标志不同。 不是简单的赋值设置is_dirty标志，而是累计，即或一下。 page-&gt;is_dirty_ |= is_dirty; New完一个Page后，其pin_count为1，因此不要将这个Page放入LRU。 replacer_-&gt;Pin(fid); New完一个Page后，要立即刷盘。可能会有new完以后unpin(false)的情况，不刷盘这一页就丢失了 disk_manager_-&gt;WritePage(new_page-&gt;GetPageId(), new_page-&gt;GetData()); 获取frame时，先从free list获取，再从lru中获取。 12345678910111213141516/*** @brief get a free page from free_list or lru_list** @return frame_id_t frame id, -1 is error*/frame_id_t BufferPoolManager::get_free_frame() {frame_id_t frame_id = -1;if (!free_list_.empty()) { frame_id = free_list_.front(); free_list_.pop_front();} else { replacer_-&gt;Victim(&amp;frame_id);}return frame_id;} 删除一个Page时，要保证free list和LRU中只存在一个fid，而不是两边都有。 replacer_-&gt;Pin(fid); free_list_.emplace_back(fid); 由于是多线程的程序，可以多跑几次测试一下，通过日志排查出错的原因。 12345678910111213141516#!/usr/bin/env bashtrap 'exit 1' INTecho &quot;Running test $1 for $2 iters&quot;for i in $(seq 1 $2); do echo -ne &quot;\\r$i / $2&quot; LOG=&quot;$i.txt&quot; # Failed go test return nonzero exit codes $1 &amp;&gt; $LOG if [[ $? -eq 0 ]]; then rm $LOG else echo &quot;Failed at iter $i, saving log at $LOG&quot; fidone （gradescope上测试要是失败了可以直接偷测试文件，逃 若有概念不理解的可以翻翻课件。","link":"/2023/03/05/cmu15445-lab1/"},{"title":"QT - 多个窗口之间传递参数（低耦合实现）","text":"实现目标有一MainWindow（主窗口）、有一Dialog（新建的窗口），之间互相传递一个QList对象。 实现方案主窗口给新建的窗口传递参数主窗口会持有一个新建窗口的指针，如下： 1Waypoints_Dialog *waypoints_dlg = new Waypoints_Dialog; 因此新建窗口开一个小窗让主窗口设置即可（即使用一个public方法） 新建的窗口： 123456void Waypoints_Dialog::set_wayPointList(QList&lt;wayPoint&gt;&amp; ls) { this-&gt;wayPointList = ls; update_table(); update_waypoints_spin();} 主窗口： 123456789void MainWindow::on_menuWaypoints_triggered() { this-&gt;waypoints_dlg-&gt;set_wayPointList(wayPointList); this-&gt;waypoints_dlg-&gt;exec();}void MainWindow::set_wayPointList(QList&lt;wayPoint&gt;&amp; ls) { this-&gt;wayPointList = ls;} 新建的窗口给主窗口传递参数新建的窗口是没有主窗口的指针的，因此上面的方案不可行。 考虑使用信号与槽的方案实现（其实就是一个观察者模式，因为主窗口含有新建串口的指针，因此主窗口可以设置为观察者（槽），新建窗口为被观察者（信号））： 被观察者(新窗口)： 信号声明（不需要实现，发送即可）： 12signals: void send_wayPointList(QList&lt;wayPoint&gt;&amp; ls); 发送信号： 1234void Waypoints_Dialog::on_send_btn_clicked() { emit send_wayPointList(this-&gt;wayPointList); QDialog::accept();} 观察者（主窗口）： 声明槽： 12private slots: void set_wayPointList(QList&lt;wayPoint&gt;&amp; ls); 定义之： 123void MainWindow::set_wayPointList(QList&lt;wayPoint&gt;&amp; ls) { this-&gt;wayPointList = ls;}","link":"/2023/03/06/frontend-qt-pass-parameters-in-windows/"},{"title":"hitos - lab2 系统调用解答","text":"实验目的 建立对系统调用接口的深入认识 掌握系统调用的基本过程 能完成系统调用的全面控制 为后续实验做准备 实验内容此次实验的基本内容是：在Linux 0.11上添加两个系统调用，并编写两个简单的应用程序测试它们。 iam()第一个系统调用是iam()，其原型为： 1int iam(const char * name); 完成的功能是将字符串参数name的内容拷贝到内核中保存下来。要求name的长度不能超过23个字符。返回值是拷贝的字符数。如果name的字符个数超过了23，则返回“-1”，并置errno为EINVAL。 在kernal/who.c中实现此系统调用。 whoami()第二个系统调用是whoami()，其原型为： 1int whoami(char* name, unsigned int size); 它将内核中由iam()保存的名字拷贝到name指向的用户地址空间中，同时确保不会对name越界访存（name的大小由size说明）。返回值是拷贝的字符数。如果size小于需要的空间，则返回“-1”，并置errno为EINVAL。 也是在kernal/who.c中实现。 测试程序运行添加过新系统调用的Linux 0.11，在其环境下编写两个测试程序iam.c和whoami.c。最终的运行结果是： 123$ ./iam lizhijun$ ./whoamilizhijun 实验原理操作系统实现系统调用的基本过程是： 应用程序调用库函数（API）； API将系统调用号存入EAX，然后通过中断调用使系统进入内核态； 内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）； 系统调用完成相应功能，将返回值存入EAX，返回到中断处理函数； 中断处理函数返回到API中； API将EAX返回给应用程序。 应用程序如何调用系统调用在通常情况下，调用系统调用和调用一个普通的自定义函数在代码上并没有什么区别，但调用后发生的事情有很大不同。调用自定义函数是通过call指令直接跳转到该函数的地址，继续运行。而调用系统调用，是调用系统库中为该系统调用编写的一个接口函数，叫API（Application Programming Interface）。API并不能完成系统调用的真正功能，它要做的是去调用真正的系统调用，过程是： 把系统调用的编号存入EAX 把函数参数存入其它通用寄存器 触发0x80号中断（int 0x80） 0.11的lib目录下有一些已经实现的API。Linus编写它们的原因是在内核加载完毕后，会切换到用户模式下，做一些初始化工作，然后启动shell。而用户模式下的很多工作需要依赖一些系统调用才能完成，因此在内核中实现了这些系统调用的API。我们不妨看看lib/close.c，研究一下close()的API： 123#define __LIBRARY__#include &lt;unistd.h&gt;_syscall1(int,close,int,fd) 其中_syscall1是一个宏，在include/unistd.h中定义。将_syscall1(int,close,int,fd)进行宏展开，可以得到： 1234567891011int close(int fd) { long __res; __asm__ volatile (&quot;int $0x80&quot; : &quot;=a&quot; (__res) : &quot;0&quot; (__NR_close),&quot;b&quot; ((long)(fd))); if (__res &gt;= 0) return (int) __res; errno = -__res; return -1; } 这就是API的定义。它先将宏__NR_close存入EAX，将参数fd存入EBX，然后进行0x80中断调用。调用返回后，从EAX取出返回值，存入__res，再通过对__res的判断决定传给API的调用者什么样的返回值。其中__NR_close就是系统调用的编号，在include/unistd.h中定义： 1#define __NR_close 6 所以添加系统调用时需要修改include/unistd.h文件，使其包含__NR_whoami和__NR_iam。而在应用程序中，要有： 1234#define __LIBRARY__ /* 有它，_syscall1等才有效。详见unistd.h */#include &lt;unistd.h&gt; /* 有它，编译器才能获知自定义的系统调用的编号 */_syscall1(int, iam, const char*, name); /* iam()在用户空间的接口函数 */_syscall2(int, whoami,char*,name,unsigned int,size); /* whoami()在用户空间的接口函数 */ 在0.11环境下编译C程序，包含的头文件都在/usr/include目录下。该目录下的unistd.h是标准头文件（它和0.11源码树中的unistd.h并不是同一个文件，虽然内容可能相同），没有__NR_whoami和__NR_iam两个宏，需要手工加上它们，也可以直接从修改过的0.11源码树中拷贝新的unistd.h过来。 从“int 0x80”进入内核函数int 0x80触发后，接下来就是内核的中断处理了。先了解一下0.11处理0x80号中断的过程。 在内核初始化时，主函数（在init/main.c中，Linux实验环境下是main()，Windows下因编译器兼容性问题被换名为start()）调用了sched_init()初始化函数： 12345678910111213141516171819202122232425262728293031void main(void) { …… time_init(); sched_init(); buffer_init(buffer_memory_end); ……}sched_init()在kernel/sched.c中定义为：void sched_init(void){ …… set_system_gate(0x80,&amp;system_call);}set_system_gate是个宏，在include/asm/system.h中定义为：#define set_system_gate(n,addr) \\ _set_gate(&amp;idt[n],15,3,addr)_set_gate的定义是：#define _set_gate(gate_addr,type,dpl,addr) \\__asm__ (&quot;movw %%dx,%%ax\\n\\t&quot; \\ &quot;movw %0,%%dx\\n\\t&quot; \\ &quot;movl %%eax,%1\\n\\t&quot; \\ &quot;movl %%edx,%2&quot; \\ : \\ : &quot;i&quot; ((short) (0x8000+(dpl&lt;&lt;13)+(type&lt;&lt;8))), \\ &quot;o&quot; (*((char *) (gate_addr))), \\ &quot;o&quot; (*(4+(char *) (gate_addr))), \\ &quot;d&quot; ((char *) (addr)),&quot;a&quot; (0x00080000)) 虽然看起来挺麻烦，但实际上很简单，就是填写IDT（中断描述符表），将system_call函数地址写到0x80对应的中断描述符中，也就是在中断0x80发生后，自动调用函数system_call。具体细节请参考《注释》的第4章。 接下来看system_call。该函数纯汇编打造，定义在kernel/system_call.s中： 1234567891011121314151617181920212223242526……nr_system_calls = 72 #这是系统调用总数。如果增删了系统调用，必须做相应修改…….globl system_call.align 2system_call: cmpl $nr_system_calls-1,%eax #检查系统调用编号是否在合法范围内 ja bad_sys_call push %ds push %es push %fs pushl %edx pushl %ecx pushl %ebx # push %ebx,%ecx,%edx，是传递给系统调用的参数 movl $0x10,%edx # 让ds,es指向GDT，内核地址空间 mov %dx,%ds mov %dx,%es movl $0x17,%edx # 让fs指向LDT，用户地址空间 mov %dx,%fs call sys_call_table(,%eax,4) pushl %eax movl current,%eax cmpl $0,state(%eax) jne reschedule cmpl $0,counter(%eax) je reschedule system_call用.globl修饰为其他函数可见。Windows实验环境下会看到它有一个下划线前缀，这是不同版本编译器的特质决定的，没有实质区别。call sys_call_table(,%eax,4)之前是一些压栈保护，修改段选择子为内核段，call sys_call_table(,%eax,4)之后是看看是否需要重新调度，这些都与本实验没有直接关系，此处只关心call sys_call_table(,%eax,4)这一句。根据汇编寻址方法它实际上是： 1call sys_call_table + 4 * %eax # 其中eax中放的是系统调用号，即__NR_xxxxxx 显然，sys_call_table一定是一个函数指针数组的起始地址，它定义在include/linux/sys.h中： 1fn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, sys_read,…… 增加实验要求的系统调用，需要在这个函数表中增加两个函数引用——sys_iam和sys_whoami。当然该函数在sys_call_table数组中的位置必须和__NR_xxxxxx的值对应上。同时还要仿照此文件中前面各个系统调用的写法，加上： 12extern int sys_whoami();extern int sys_iam(); 不然，编译会出错的。 实验过程添加系统调用的流程添加一个系统调用的流程如下： 修改 include/unistd.h， 添加#define __NR_foo num，num为接下来使用的系统调用号 修改 include/linux/sys.h , 添加extern rettype sys_foo();， 在sys_call_table数组对应位置加入sys_foo 修改 kernel/system_call.s，修改 nr_system_calls = num (num为系统调用总数目) 在 kernel 中添加 foo.c （若需要支持内核态与用户态数据交互，则包含 include/asm/segment.h，其中有 put_fs_XXX 和 get_fs_XXX函数） 在 foo.c 实现系统调用sys_foo() 修改 kernel 的Makefile，将 foo.c 与内核其它代码编译链接到一起 系统调用用户需要使用 123#define __LIBRARY__#include &lt;unistd.h&gt;_syscallN宏展开系统调用，提供用户态的系统调用接口（参数数目确定具体宏） 添加whoami和iam两个系统调用： 修改 include/unistd.h， 添加#define __NR_foo num，num为接下来使用的系统调用号 12#define __NR_iam 72#define __NR_whoami 73 修改 include/linux/sys.h , 添加extern rettype sys_foo();， 在sys_call_table数组对应位置加入sys_foo 12345678910111213141516extern int sys_iam();extern int sys_whoami();fn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, sys_read,sys_write, sys_open, sys_close, sys_waitpid, sys_creat, sys_link,sys_unlink, sys_execve, sys_chdir, sys_time, sys_mknod, sys_chmod,sys_chown, sys_break, sys_stat, sys_lseek, sys_getpid, sys_mount,sys_umount, sys_setuid, sys_getuid, sys_stime, sys_ptrace, sys_alarm,sys_fstat, sys_pause, sys_utime, sys_stty, sys_gtty, sys_access,sys_nice, sys_ftime, sys_sync, sys_kill, sys_rename, sys_mkdir,sys_rmdir, sys_dup, sys_pipe, sys_times, sys_prof, sys_brk, sys_setgid,sys_getgid, sys_signal, sys_geteuid, sys_getegid, sys_acct, sys_phys,sys_lock, sys_ioctl, sys_fcntl, sys_mpx, sys_setpgid, sys_ulimit,sys_uname, sys_umask, sys_chroot, sys_ustat, sys_dup2, sys_getppid,sys_getpgrp, sys_setsid, sys_sigaction, sys_sgetmask, sys_ssetmask,sys_setreuid, sys_setregid, sys_iam, sys_whoami}; 修改 kernel/system_call.s，修改 nr_system_calls = num (num为系统调用总数目) 1nr_system_calls = 74 在 kernel 中添加 foo.c （若需要支持内核态与用户态数据交互，则包含 include/asm/segment.h，其中有 put_fs_XXX 和 get_fs_XXX函数） 在 foo.c 实现系统调用sys_foo() who.c内容如下： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;asm/segment.h&gt;char username[24];int sys_iam(const char * name) { char tmp[26]; short break_flag = 0, i = 0; for (i = 0; i &lt; 26; ++i) { tmp[i] = get_fs_byte(name + i); if (tmp[i] == '\\0') { break_flag = 1; break; } } if (!break_flag || i &gt; 23) { return -(EINVAL); } char* dest = username; strcpy(dest, tmp); return i;}int sys_whoami(char* name, unsigned int size) { short length = strlen(username); if (length &gt; size) { return -(EINVAL); } short i = 0; for (i; i &lt; size; ++i) { put_fs_byte(username[i], name + i); if (username[i] == '\\0') { break; } } return i;} 修改 kernel 的Makefile，将 foo.c 与内核其它代码编译链接到一起 123456OBJS = sched.o system_call.o traps.o asm.o fork.o \\ panic.o printk.o vsprintf.o sys.o exit.o \\ signal.o mktime.o who.o### Dependencies:who.s who.o: who.c ../include/linux/kernel.h ../include/unistd.h 用户调用系统调用：(在运行的linux0.11上编写编译运行) whoami.c: 12345678910111213#include &lt;errno.h&gt;#define __LIBRARY__#include &lt;unistd.h&gt;_syscall2(int, whoami,char*,name,unsigned int,size);int main(){ char s[30]; whoami(s,30); printf(&quot;%s&quot;,s); return 0;} iam.c: 123456789101112#include &lt;errno.h&gt;#define __LIBRARY__#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;_syscall1(int, iam, const char*, name);int main(int argc,char ** argv){ iam(argv[1]); return 0;} 如编译错误，说__NR_whoami和__NR_iam未定义，则是下面的问题： 在0.11环境下编译C程序，包含的头文件都在/usr/include目录下。该目录下的unistd.h是标准头文件（它和0.11源码树中的unistd.h并不是同一个文件，虽然内容可能相同），没有__NR_whoami和__NR_iam两个宏，需要手工加上它们，也可以直接从修改过的0.11源码树中拷贝新的unistd.h过来。 实验结果可以发现可以很好地执行！证明此次实验是成功的！ reference[1] 实验指导书 [2] 现成代码","link":"/2023/03/06/linux-hitos-lab2/"},{"title":"hitos - lab1 操作系统的引导解答","text":"实验目的 熟悉hit-oslab实验环境； 建立对操作系统引导过程的深入认识； 掌握操作系统的基本开发过程； 能对操作系统代码进行简单的控制，揭开操作系统的神秘面纱。 实验内容此次实验的基本内容是： 阅读《Linux内核完全注释》的第6章，对计算机和Linux 0.11的引导过程进行初步的了解； 按照下面的要求改写0.11的引导程序bootsect.s 有兴趣同学可以做做进入保护模式前的设置程序setup.s。 改写bootsect.s主要完成如下功能： bootsect.s能在屏幕上打印一段提示信息“XXX is booting…”，其中XXX是你给自己的操作系统起的名字，例如LZJos、Sunix等 改写setup.s主要完成如下功能： bootsect.s能完成setup.s的载入，并跳转到setup.s开始地址执行。而setup.s向屏幕输出一行”Now we are in SETUP”。 setup.s能获取至少一个基本的硬件参数（如内存参数、显卡参数、硬盘参数等），将其存放在内存的特定地址，并输出到屏幕上。 setup.s不再加载Linux内核，保持上述信息显示在屏幕上即可。 实验过程1 bootsect.s在屏幕上打印一段提示信息linux0.11源码中便有，改改即可。 核心代码如下： 12345678910111213141516171819202122! Print some inane messageok_load_setup: mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#23 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#msg1 mov ax,#0x1301 ! write string, move cursor int 0x10 msg1: .byte 13,10 .ascii &quot;COS is booting...&quot; .byte 13,10,13,10.org 508root_dev: .word ROOT_DEVboot_flag: .word 0xAA55 2 bootsect.s完成setup.s的载入，并跳转到setup.s开始地址执行首先是需要知道内存中的几个模块，比如boot、setup、system； 系统上电后各模块之间的执行顺序： 系统上电后，会将bootsec.s加载入0x7C00位置 bootsec.s将自己移动到0x90000 加载setup.s入内存，加载system入0x10000处，然后跳转至setup.s中执行 setup.s加载一些硬件参数 将系统移动至0x0000处，跳转至system中的head.s中执行 需要在bootsect.s中实现跳转到setup.s中执行： 1234567891011121314151617181920212223242526272829303132333435363738394041424344SETUPLEN = 4 ! nr of setup-sectorsBOOTSEG = 0x07c0 ! original address of boot-sectorINITSEG = 0x9000 ! we move boot here - out of the waySETUPSEG = 0x9020 ! setup starts hereSYSSEG = 0x1000 ! system loaded at 0x10000 (65536).ENDSEG = SYSSEG + SYSSIZE ! where to stop loading! ROOT_DEV: 0x000 - same type of floppy as boot.! 0x301 - first partition on first drive etcROOT_DEV = 0x306! move BOOTSEG -&gt; INITSEGentry _start_start: mov ax,#BOOTSEG mov ds,ax mov ax,#INITSEG mov es,ax mov cx,#256 sub si,si sub di,di rep movw jmpi go,INITSEGgo: mov ax,cs mov ds,ax mov es,ax! load setup.sload_setup: mov dx,#0x0000 ! drive 0, head 0 mov cx,#0x0002 ! sector 2, track 0 mov bx,#0x0200 ! address = 512, in INITSEG mov ax,#0x0200+SETUPLEN ! service 2, nr of sectors int 0x13 ! read it jnc ok_load_setup ! ok - continue mov dx,#0x0000 mov ax,#0x0000 ! reset the diskette int 0x13 j load_setup! jump to setup.s jmpi 0,SETUPSEG 然后在setup.s中显示已经跳转到setup.s中了，如下：(一定要记得重设ds数据段的寄存器，因为msg是在0x90200开始的数据段上的) 12345678910111213141516171819202122entry _start_start:init_ds_es: mov ax,cs mov ds,ax mov es,ax ! Print in begining of setup.sprint_cur: mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#28 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#msg1 mov ax,#0x1301 ! write string, move cursor int 0x10 msg1: .ascii &quot;Now we are in SETUP...&quot; .byte 13,10,13,10 3 setup.s获取硬件参数，将其存放在内存的特定地址，并输出到屏幕上3.1 获取光标位置使用bios的0x10号中断实现，ah是功能选择，结果放在dx中，最后将结果放入0x90000。 1234567! get cursor pos mov ax,#INITSEG mov ds,ax ! set ds=0x9000 mov ah,#0x03 ! get cursor pos xor bh,bh int 0x10 ! interrupt mov [0],dx ! write cursor pos to 0x90000. 打印： 1234567891011121314print_cursor_pos: mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#10 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#cursor mov ax,#0x1301 ! write string, move cursor int 0x10 mov ax,[0] call print_hex call print_nl 3.2 获取内存大小同上，利用bios的0x15号中断： 1234! get memory size mov ah,#0x88 int 0x15 mov [2],ax 打印： 12345678910111213print_memmory_size: mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#14 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#memory_size mov ax,#0x1301 ! write string, move cursor int 0x10 mov ax,[2] call print_hex 3.3 获取硬盘参数12345678910! 从0x41处拷贝16个字节（磁盘参数表） mov ax,#0x0000 mov ds,ax lds si,[4*0x41] mov ax,#INITSEG mov es,ax mov di,#0x0004 mov cx,#0x10 rep ! for i in 16: movsb 打印： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546print_hd_info:! Cylinders mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#16 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#hdinfo mov ax,#0x1301 ! write string, move cursor int 0x10 mov ax,[4] call print_hex call print_nl! head mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#10 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#head mov ax,#0x1301 ! write string, move cursor int 0x10 xor ax, ax mov al,[4+2] call print_hex call print_nl! sect mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#10 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#sect mov ax,#0x1301 ! write string, move cursor int 0x10 xor ax, ax mov al,[0x4+0x0E] call print_hex call print_nl 4 setup.s不再加载Linux内核，保持上述信息显示在屏幕上即可上述工作完成后，直接死循环即可： 12dead_loop: jmp dead_loop 5 完整代码bootsec.s: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111!! SYS_SIZE is the number of clicks (16 bytes) to be loaded.! 0x3000 is 0x30000 bytes = 196kB, more than enough for current! versions of linux!SYSSIZE = 0x3000!! bootsect.s (C) 1991 Linus Torvalds!! bootsect.s is loaded at 0x7c00 by the bios-startup routines, and moves! iself out of the way to address 0x90000, and jumps there.!! It then loads 'setup' directly after itself (0x90200), and the system! at 0x10000, using BIOS interrupts. !! NOTE! currently system is at most 8*65536 bytes long. This should be no! problem, even in the future. I want to keep it simple. This 512 kB! kernel size should be enough, especially as this doesn't contain the! buffer cache as in minix!! The loader has been made as simple as possible, and continuos! read errors will result in a unbreakable loop. Reboot by hand. It! loads pretty fast by getting whole sectors at a time whenever possible..globl begtext, begdata, begbss, endtext, enddata, endbss.textbegtext:.databegdata:.bssbegbss:.textSETUPLEN = 4 ! nr of setup-sectorsBOOTSEG = 0x07c0 ! original address of boot-sectorINITSEG = 0x9000 ! we move boot here - out of the waySETUPSEG = 0x9020 ! setup starts hereSYSSEG = 0x1000 ! system loaded at 0x10000 (65536).ENDSEG = SYSSEG + SYSSIZE ! where to stop loading! ROOT_DEV: 0x000 - same type of floppy as boot.! 0x301 - first partition on first drive etcROOT_DEV = 0x306! move BOOTSEG -&gt; INITSEGentry _start_start: mov ax,#BOOTSEG mov ds,ax mov ax,#INITSEG mov es,ax mov cx,#256 sub si,si sub di,di rep movw jmpi go,INITSEGgo: mov ax,cs mov ds,ax mov es,ax! load setup.sload_setup: mov dx,#0x0000 ! drive 0, head 0 mov cx,#0x0002 ! sector 2, track 0 mov bx,#0x0200 ! address = 512, in INITSEG mov ax,#0x0200+SETUPLEN ! service 2, nr of sectors int 0x13 ! read it jnc ok_load_setup ! ok - continue mov dx,#0x0000 mov ax,#0x0000 ! reset the diskette int 0x13 j load_setup! Print some inane messageok_load_setup: mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#23 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#msg1 mov ax,#0x1301 ! write string, move cursor int 0x10! jump to setup.s jmpi 0,SETUPSEGsectors: .word 0msg1: .byte 13,10 .ascii &quot;COS is booting...&quot; .byte 13,10,13,10.org 508root_dev: .word ROOT_DEVboot_flag: .word 0xAA55.textendtext:.dataenddata:.bssendbss: setup.s: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208.globl begtext, begdata, begbss, endtext, enddata, endbss.textbegtext:.databegdata:.bssbegbss:.textSETUPLEN = 4 ! nr of setup-sectorsBOOTSEG = 0x07c0 ! original address of boot-sectorINITSEG = 0x9000 ! we move boot here - out of the waySETUPSEG = 0x9020 ! setup starts hereSYSSEG = 0x1000 ! system loaded at 0x10000 (65536).ENDSEG = SYSSEG + SYSSIZE ! where to stop loading! ROOT_DEV: 0x000 - same type of floppy as boot.! 0x301 - first partition on first drive etcROOT_DEV = 0x306entry _start_start:init_ds_es: mov ax,cs mov ds,ax mov es,ax ! Print in begining of setup.sprint_cur: mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#28 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#msg1 mov ax,#0x1301 ! write string, move cursor int 0x10! get cursor pos mov ax,#INITSEG mov ds,ax ! set ds=0x9000 mov ah,#0x03 ! get cursor pos xor bh,bh int 0x10 ! interrupt mov [0],dx ! write cursor pos to 0x90000.! get memory size mov ah,#0x88 int 0x15 mov [2],ax! 从0x41处拷贝16个字节（磁盘参数表） mov ax,#0x0000 mov ds,ax lds si,[4*0x41] mov ax,#INITSEG mov es,ax mov di,#0x0004 mov cx,#0x10 rep ! for i in 16: movsbreset_ds_es: mov ax,#INITSEG mov ds,ax mov ax,#SETUPSEG mov es,ax print_cursor_pos: mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#10 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#cursor mov ax,#0x1301 ! write string, move cursor int 0x10 mov ax,[0] call print_hex call print_nlprint_memmory_size: mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#14 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#memory_size mov ax,#0x1301 ! write string, move cursor int 0x10 mov ax,[2] call print_hex print_hd_info:! Cylinders mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#16 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#hdinfo mov ax,#0x1301 ! write string, move cursor int 0x10 mov ax,[4] call print_hex call print_nl! head mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#10 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#head mov ax,#0x1301 ! write string, move cursor int 0x10 xor ax, ax mov al,[4+2] call print_hex call print_nl! sect mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#10 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#sect mov ax,#0x1301 ! write string, move cursor int 0x10 xor ax, ax mov al,[0x4+0x0E] call print_hex call print_nldead_loop: jmp dead_loop! 以16进制方式打印栈顶的16位数, AXprint_hex: mov cx,#4 ! 4个十六进制数字 mov dx,ax ! 将ax所指的值放入dx中print_digit: rol dx,#4 ! 循环以使低4比特用上 !! 取dx的高4比特移到低4比特处。 mov ax,#0xe0f ! ah = 请求的功能值，al = 半字节(4个比特)掩码。 and al,dl ! 取dl的低4比特值。 add al,#0x30 ! 给al数字加上十六进制0x30 cmp al,#0x3a jl outp !是一个不大于十的数字 add al,#0x07 !是a～f，要多加7outp: int 0x10 loop print_digit ret! print \\n print_nl: mov ax,#0xe0d ! CR int 0x10 mov al,#0xa ! LF int 0x10 retmsg1: .ascii &quot;Now we are in SETUP...&quot; .byte 13,10,13,10cursor: .ascii &quot;cursor: 0x&quot;memory_size: .ascii &quot;memory_size:0x &quot;hdinfo: .ascii &quot;KB&quot; .byte 13,10 .ascii &quot;Cylinders:0x&quot;head: .ascii &quot;Headers:0x&quot;sect: .ascii &quot;Secotrs:0x&quot;.org 508root_dev: .word ROOT_DEVboot_flag: .word 0xAA55.textendtext:.dataenddata:.bssendbss: 使用make BootImage编译不过去，是要改一下tools/build.c： 判断system模块有没有，没有直接跳过后边读取即可： 123if (strcmp(argv[3], &quot;none&quot;) == 0) { return 0;} 加入位置如下： 实验结果编译： 运行结果： 查看bochs配置文件： 12345678910111213romimage: file=$OSLAB_PATH/bochs/BIOS-bochs-latestmegs: 16vgaromimage: file=$OSLAB_PATH/bochs/vgabios.binfloppya: 1_44=&quot;$OSLAB_PATH/linux-0.11/Image&quot;, status=insertedata0-master: type=disk, path=&quot;$OSLAB_PATH/hdc-0.11.img&quot;, mode=flat, cylinders=204, heads=16, spt=38boot: alog: $OSLAB_PATH/bochsout.txtkeyboard: type=mf, serial_delay=200, paste_delay=100000cpu: count=1, ips=4000000mouse: enabled=0private_colormap: enabled=0fullscreen: enabled=0screenmode: name=&quot;sample&quot; 其中有cylinders=204, heads=16, spt=38，和系统输出的获取到的参数是一样的，因此本次实验是成功的！ reference[1] 实验指导书","link":"/2023/03/06/linux-hitos-lab1/"},{"title":"Mac删除讨厌的.DS_Store文件夹","text":"先设置好path，然后删除，直接写在find后也行： 12345678deletepath=/# 制定当前deletepath=$(pwd)sudo find $deletepath -name &quot;.DS_Store&quot; -depth -exec rm {} \\;zip -d file.zip __MACOSX/\\* 可以加.gitignore文件以忽略一些无关文件： 12345.gitignore*.[oa]git.idea/.DS_Store/cmake-build-debug/","link":"/2023/03/06/debug-delete-DS-Store-in-Mac/"},{"title":"UNIX环境高级编程 - 文件I&#x2F;O - 原子操作、复制、修改文件描述符","text":"原子操作 追加到一个文件 追加一个文件时，不能通过lseek到末尾然后write。要用O_APPEND选项打开文件，然后直接write。 通过lseek到末尾然后write时，如果多个进程同时执行这两个操作，则会引起竞争条件 通过 O_APPEND选项打开文件，然后直接write时，内核每一次在写操作之前，都会将进程的当前偏移量设置到文件的末尾，于是就不需要执行lseek定位操作 pread/pwrite可以执行原子性的定位读/定位写 O_CREAT|O_EXCL选项打开文件时，可以原子性的检查文件是否存在和创建文件这两个操作。 函数 pread 和 pwrite 123#include &lt;unistd.h&gt;ssize_t pread(int fd,void*buf,size_t nbytes,off_t offset);ssize_t pwrite(int fd,const void*buf,size_t nbytes,off_t offset); 参数： fd：打开的文件描述符 buf：读出数据存放的缓冲区/ 写到文件的数据的缓冲区 nbytes：预期读出/写入文件的字节数 offset：从文件指定偏移量开始执行read/write 返回： 成功：读到的字节数/已写的字节数 失败： -1 调用pread相当于先调用lseek再调用read.但是调用pread时，无法中断其定位和读操作，并且不更新当前文件偏移量；调用pwrite相当于先调用lseek再调用write.但是调用pwrite时，无法中断其定位和写操作，并且不更新当前文件偏移量 其他操作dup使用dup/dup2复制一个现有的文件描述符： 1234#include &lt;unistd.h&gt;int dup(int fd);int dup2(int fd,int fd2); 参数： fd：被复制的文件描述符（已被打开） fd2：指定的新的文件描述符（待生成） 返回值： 成功： 返回新的文件描述符 失败： 返回 -1 对于dup函数，返回的新的文件描述符一定是当前可用的文件描述符中最小的数字。 对于dup2函数： 如果 fd2已经是被打开的文件描述符且不等于fd，则先将其关闭，然后再打开（原子操作） 如果 fd2等于fd，则直接返回fd2（也等于fd），而不作任何操作 任何情况下，这个返回的新的文明描述符与参数fd共享同一个文件表项（因此文件状态标志以及文件偏移量都会共享）。任何情况下，这个返回的新的文明描述符的close-on-exec标志总是被清除。 dup后的内核数据结构如下： syncUNIX操作系统在内核中设有缓冲区，大多数磁盘 I/O 都通过缓冲区进行。当用户程序想文件写入数据时，内核通常都首先将数据复制到缓冲区中，然后排入队列，晚些时候再写入磁盘。这种方式称为延迟写。 当内核需要重用缓冲区来存方其他数据时，它会把所有延迟写的数据库写入磁盘 也可以调用下列函数来显式的将延迟写的数据库写入磁盘 12345#include &lt;unistd.h&gt;int fsync(int fd);int fdatasync(int fd);void sync(void); 参数： fd：指定的打开的文件描述符 返回值： 成功：返回 0 失败： 返回 -1 区别： sync：将所有修改过的块缓冲区排入写队列，然后返回，它并不等待时机写磁盘结束 fsync：只对由fd指定的单个文件起作用，等待写磁盘操作结束才返回 fdatasync：只对由fd指定的单个文件起作用，等待写磁盘操作结束才返回，但是它只影响文件的数据部分（fsync会同步更新文件的属性） update 守护进程会周期性的调用sync函数。命令sync也会调用sync函数","link":"/2023/03/06/linux-file-IO/"},{"title":"QT - Clion配置qt creator和uic","text":"配置qt creator（用于画ui，拖空间） Program：自己安装qt的目录，在tools中找到相关的二进制可执行文件 Arguments：$FileName$ Working directory: $FileDir$ 配置uic（自动生成C++代码） Program：自己安装qt的目录，在版本号中找到相关的二进制可执行文件 Arguments：$FileName$ -o ui_$FileNameWithoutExtension$.h Working directory: $FileDir$ 注意事项：注意 Working directory 不能是 $ProjectFileDir$， 否则在二级目录使用工具会打不开文件（路径错误）。","link":"/2023/03/06/frontend-qt-creator-uic/"},{"title":"QT - qmake - command not found","text":"安装了QT后，执行 qmake 后发现 command not found。 解决办法： 执行 updatedb 执行 locate bin/qmake， 可见如下结果： 执行 cd /usr/local/bin 执行 ln -s /opt/QT_5.9.5/5.9.5/gcc_64/bin/qmake /usr/local/bin 执行 qmake -v ，可以发现可以使用 qmake 指令了。","link":"/2023/03/06/frontend-qt-qmake-error/"},{"title":"UNIX环境高级编程 - 文件I&#x2F;O - 读写&#x2F;共享文件","text":"函数lseek使用 lseek 函数显式的为一个打开文件设置偏移量。 每个打开的文件都有一个与其关联的“当前文件偏移量”。它通常是个非负整数，用于度量从文件开始处计算的字节数。 读、写操作都从当前文件偏移量处开始，并使偏移量增加所读写的字节数。 123#include &lt;unistd.h&gt;off_t lseek(int fd, off_t offset, int whence); 参数： fd：打开的文件的文件描述符 whence：必须是 SEEK_SET、SEEK_CUR、SEEK_END 三个常量之一 offset： 若 whence 是SEEK_SET，则将该文件的偏移量设置为距离文件开始处 offset 个字节 若 whence 是 SEEK_CUR，则将该文件的偏移量设置为当前值加上 offset 个字节，offset 可正，可负 若 whence 是 SEEK_END，则将该文件的偏移量设置为文件长度加上 offset 个字节，offset 可正，可负 返回值： 成功： 返回新的文件偏移量 失败：返回 -1 一些关于 lseek 和文件偏移量的注意事项： 打开一个文件时，除非指定 O_APPEND 选项，否则系统默认将该偏移量设为0 如果文件描述符指定的是一个管道、FIFO、或者网络套接字，则无法设定当前文件偏移量，则 lseek 将返回 -1 ，并且将 errno 设置为 ESPIPE。 对于普通文件，其当前文件偏移量必须是非负值。但是某些设备运行负的偏移量出现。因此比较 lseek 的结果时，不能根据它小于0 就认为出错。要根据是否等于 -1 来判断是否出错。 lseek 并不会引起任何 I/O 操作，lseek 仅仅将当前文件的偏移量记录在内核中。 当前文件偏移量可以大于文件的当前长度。此时对该文件的下一次写操作将加长该文件，并且在文件中构成一个空洞。空洞中的内容位于文件中但是没有被写过，其字节被读取时都被读为0 文件中的空洞并不要求在磁盘上占据存储区。具体处理方式与操作系统有关 函数read调用 read 函数从打开文件中读取数据。 读操作从文件的当前偏移量开始，在成功返回之前，文件的当前偏移量会增加实际读到的字节数。 123#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t nbytes); 参数： fd：打开的文件的文件描述符 buf：存放读取内容的缓冲区的地址（由程序员手动分配） nbytes：期望读到的字节数 返回值： 成功：返回读到的字节数，若已到文件尾则返回 0 失败：返回 -1 有多种情况可能导致实际读到的字节数少于期望读到的字节数： 读普通文件时，在读到期望字节数之前到达了文件尾端 当从终端设备读时，通常一次最多读取一行（终端默认是行缓冲的） 当从网络读时，网络中的缓存机制可能造成返回值小于期望读到的字节数 当从管道或者FIFO读时，若管道包含的字节少于所需的数量，则 read只返回实际可用的字节数 当从某些面向记录的设备（如磁带）中读取时，一次最多返回一条记录 当一个信号造成中断，而已读了部分数据时。 函数write123#include &lt;unistd.h&gt;ssize_t write(int fd, const void *buf, size_t nbytes); 参数： fd：打开的文件的文件描述符 buf：存放待写的数据内容的缓冲区的地址（由程序员手动分配） nbytes：期望写入文件的字节数 返回值： 成功：返回已写的字节数 失败：返回 -1 write 的返回值通常都是与 nbytes 相同。否则表示出错。 write 出错的一个常见原因是磁盘写满，或者超过了一个给定进行的文件长度限制 对于普通文件，写操作从文件的当前偏移量处开始。如果打开文件时指定了 O_APPEND 选项，则每次写操作之前，都会将文件偏移量设置在文件的当前结尾处。在一次成功写之后，该文件偏移量增加实际写的字节数。 I/O效率下图显示了用 20 种不同的缓冲区长度，读 516,581,760 字节的文件所得到的结果: 此测试所用的文件系统是 Linux ext4 文件系统，其磁盘块长度为 4096 字节（4K)。 系统 CPU 时间的几个最小值差不多出现在 BUFFSIZE 为 4096 及以后的位置，继续增加缓冲区长度对此时间几乎没有影响。 缓冲区长度小至 32 字节时的时钟时间与拥有较大缓冲区长度时的时钟时间几乎一样。 Why? 大多数文件系统为改善性能都采用某种预读（read ahead）技术。当检测到正进行顺序读取时，系统就试图读入比应用所要求的更多数据，并假想应用很快就会读这些数据。（利用了局部性原理） 文件共享UNIX 系统支持在不同进程间共享打开文件。 内核使用三种数据结构描述打开文件。它们之间的关系决定了一个进程与另一个进程在打开的文件之间的相互影响。 内核为每个进程分配一个进程表项（所有进程表项构成进程表），进程表中都有一个打开的文件描述符表。每个文件描述符占用一项，其内容为： 文件描述符标志 指向一个文件表项的指针 内核为每个打开的文件分配一个文件表项（所有的文件表项构成文件表）。每个文件表项的内容包括： 文件状态标志（读、写、添写、同步和阻塞等） 当前文件偏移量 指向该文件 v 结点表项的指针 每个打开的文件或者设备都有一个 v 结点结构（v-node）。 v 结点结构的内容包括： 文件类型和对此文件进行各种操作函数的指针。 对于大多数文件， v 结点还包含了该文件的 i 结点。 这些信息都是在打开文件时从磁盘读入内存的。如 i 结点包含了文件的所有者、文件长度、指向文件实际数据在磁盘上所在位置的指针等等。 v 结点结构和 i 结点结构实际上代表了文件的实体。 Linux 没有将相关数据结分为 i 节点和 v 节点，而是采用了一个与文件系统相关的 i 节点和个与文件系统无关的 i 节点。 一个进程打开多个文件： 两个进程打开同一个文件： 可能有多个文件描述符指向同一个文件表项。(dup、fork) dup的情况： fork的情况：","link":"/2023/03/06/linux-file-IO-read-write/"},{"title":"UNIX环境高级编程 - 文件I&#x2F;O - 打开&#x2F;创建&#x2F;关闭文件","text":"函数open和openat12345#include &lt;fcntl.h&gt;int open(const char* path,int oflag,.../*mode_t mode*/);int openat(int fd,const char*path,int oflag,.../*mode_t mode */); 可以使用如下命令查看参数： 1man 2 open 参数： path:要打开或者创建文件的名字 oflag：用于指定函数的操作行为： 必选的标志：（标志/常量定义于 fcntl.h 中） O_RDONLY常量：文件只读打开 O_WRONLY常量：文件只写打开 O_RDWR常量：文件读、写打开 O_EXEC常量：只执行打开 O_SEARCH常量：只搜索打开（应用于目录）。本文涉及的操作系统都没有支持该常 下面的常量是可选的（进行或运行）(不一定所有的操作系统支持，不同的系统得看实际情况)： O_APPEND：每次写时都追加到文件的尾端 O_CLOEXEC：将FD_CLOEXEC常量设置为文件描述符标志 O_CREAT：若此文件不存在则创建它。在使用此选项时，需要同时说明参数mode（指定该文件的访问权限） O_DIRECTORY：若path引用的不是目录，则出错 O_EXCL：若同时指定了O_CREAT时，且文件已存在则出错。根据此可以测试一个文件是否存在。若不存在则创建此文件。这使得测试和创建两者成为一个原子操作 O_NOCTTY：若path引用的是终端设备，则不将该设备分配作为此进程的控制终端 O_NOFOLLOW：若path引用的是一个符号链接，则出错 O_NONBLOCK：如果path引用的是一个FIFO、一个块特殊文件或者一个字符特殊文件，则文件本次打开操作和后续的 I/O 操作设为非阻塞模式。 O_SYNC：每次 write 等待物理 I/O 完成，包括由 write 操作引起的文件属性更新所需的 I/O O_TRUNC： 如果此文件存在，且为O_WRONLY或者O_RDWR成功打开，则将其长度截断为0 O_RSYNC：使每一个read操作等待，直到所有对文件同一部分挂起的写操作都完成。 O_DSYNC：每次 write 等待物理 I/O 完成，但不包括由 write 操作引起的文件属性更新所需的 I/O mode：文件访问权限。文件访问权限常量在 &lt;sys/stat.h&gt; 中定义，有以下九个： S_IRUSR：用户读 S_IWUSR：用户写 S_IXUSR：用户执行 S_IRGRP：组读 S_IWGRP：组写 S_IXGRP：组执行 S_IROTH：其他读 S_IWOTH：其他写 S_IXOTH：其他执行 返回值： 成功：返回文件描述符。 失败：返回 -1 由 open/openat 返回的文件描述符一定是最小的未使用的描述符数字。 对于openat函数，被打开的文件名由fd和path共同决定： 如果path指定的是绝对路径，此时fd被忽略。openat等价于open 如果path指定的是相对路径名，则fd是一个打开目录的文件描述符。被打开的文件的绝对路径由该fd描述符对应的目录加上path组合而成 如果path是一个相对路径名，而fd是特殊值AT_FDCWD，则path相对于当前工作目录。被打开文件在当前工作目录中查找。 fd 是 AT_FDCWD 说明是当前目录 openat 函数是 POSIX.1中新增的函数，希望解決两个问题。 让线程可以使用相对路径名打开目录中的文件，而不再只能打开当前工作目录。 同一进程中的所有线程共享相同的当前工作目录，因此很难让同一进程的多个不同线程在同时间工作在不同的目录中。 可以避免 time-of-check-to-time-of-use (TOCTTOU）错误。 TOCTTOU 错误的基本思想是：如果有两个基于文件的函数调用，其中第二个调用依赖于第一个调用的结果，那么程序是脆弱的。 因为两个调用并不是原子操作，在两个函数调用之间文件可能改变了，这样也就造成了第一个调用的结果就不再有效，使得程序最终的结果是错误的。 函数creat也可以使用creat 创建一个新文件。 123#include &lt;fcntl.h&gt;int creat(const char*path,mode_t mode); 此函数等效于： open(path, O_WRONLY | O_CREAT | O_TRUNC, mode) 参数： path:要创建文件的名字 mode：指定该文件的访问权限文件访问权限常量在 &lt;sys/stat.h&gt; 中定义，有下列九个： S_IRUSR：用户读 S_IWUSR：用户写 S_IXUSR：用户执行 S_IRGRP：组读 S_IWGRP：组写 S_IXGRP：组执行 S_IROTH：其他读 S_IWOTH：其他写 S_IXOTH：其他执行 返回值： 成功： 返回O_WRONLY打开的文件描述符 失败： 返回 -1 creat的不足： 它以只写方式打开。若要先写再读，则需调用creat、close，然后再调用open进行读取。 若文件已存在则将文件截断为0。 现在可以使用新的open: open(path, O_RDWR | O_CREAT | O_TRUNC, mode) 为什么会有open了还需要creat？ 历史原因，老版本的open没有O_CREAT标志。 函数close可以使用close 关闭一个打开文件。 123#include &lt;unistd.h&gt;int close(int fd); 参数： fd：待关闭文件的文件描述符 返回值： 成功：返回 0 失败：返回 -1 注意： 进程关闭一个文件会释放它加在该文件上的所有记录锁。 当一个进程终止时，内核会自动关闭它所有的打开的文件。","link":"/2023/03/06/linux-file-IO-open-close/"},{"title":"UNIX环境高级编程 - UNIX标准及实现","text":"在过去的近25年时间，人们为了UNIX的标准化做出了种种努力，这使得程序在不同版本的UNIX系统之间的移植相当容易。 UNIX标准化ISO C1989年，C语言首个标准得到批准，即C89。次年，一个带有小改动的版本标准被批准其为C90。因此，C89和C90通常指同一种语言。 在2000年三月，ANSI采纳了ISO/IEC 9899:1999标准，即C99。 在2011年12月，ANSI采纳了ISO/IEC 9899:2011标准，即C11，它是C程序语言的现行标准。 按照ISO C标准定义的头文件将C语言公用函数库划分成了24个部分。POSIX.1标准包括这些头文件以及一些额外的头文件。 IEEE POSIXPOSIX是由IEEE制订的一系列标准，其指的是可移植操作系统接口，它说明的是接口而不是实现。 POSIX.1标准包括ISO C标准库汗水(上图)以及一些额外的头文件（下图）。 Single UNIX SpecificationSingle UNIX Specification（SUS，单一UNIX规范），它是POSIX.1标准的一个超集，他定义了一些附加接口扩展POSIX.1规范提供的功能。 UNIX系统实现ISO C、IEEE POSIX、Single UNIX Specification是三个不同的组织，第一个组织负责对C语言进行标准化，后两个组织负责对UNIX系统接口进行标准化。 这三个组织制定了概念上的规范，但实现是由厂商进行的。几个知名实现发行版如下： SVR4：AT&amp;T实现 BSD：UCB实现 FreeBSD：开源（基于4.4BSD-Lite） Linux：Linus在1991年从Minix改写而来，开源 Mac OS X：Apple，又称Darwin系统 Solaris：SUN，基于SVR4 限制UNIX 系统实现定义了很多幻数和常量。有两种类型的限制是必须的： 编译时限制，如 short int 最大值是多少 通常编译时限制可以在头文件中定义；运行时限制则要求进程调用一个函数获得限制值。 运行时限制，如文件名最长多少个字符 某些限制在一个给定的 UNIX 实现中可能是固定的（由头文件定义），在另一个 UNIX 实现中可能是动态的（需要由进程调用一个函数获得限制值）。如文件名的最大字符数在不同的操作系统中，是属于动态/静态限制。因此提供了三种限制： 编译时限制（由头文件给定） 与文件或者目录无关的运行时限制（由 sysconf函数给定） 与文件或者目录相关的运行时限制（由 pathconf函数以及fpathconf函数给定） ISO C 限制ISO C 所有编译时限制都在头文件 &lt;limits.h&gt; 中,如整型大小。 这些限制常量在一个给定的操作系统中不会改变 关于浮点数的最大最小值的编译时限制，在&lt;float.h&gt;头文件中定义 &lt;stdio.h&gt; 头文件还定义了三个编译时限制： FOPEN_MAX：可同时打开的标准I/O 流限制的最小数 TMP_MAX：由tmpnam函数产生的唯一文件名的最大个数 FILENAME_MAX：虽然 ISO C 定义了该常量，但是要避免使用。而要用 POSIX 提供的 NAME_MAX和 PATH_MAX 常量 POSIX 限制POSIX定义了很多涉及操作系统实现限制的常量。这些常量大多数在&lt;limits.h&gt;中，也有的按照具体条件定义在其他头文件中。 获取运行时限制123456#include&lt;unistd.h&gt;long sysconf(int name); long pathconf(const char*pathname,int name);long fpathconf(int fd,int name); // 若成功，返回相应值；若出错，返回-1 参数： name：指定的限制值。name参数是系统定义的常量 以 _SC_开头的常量用于 sysconf函数 以 -PC_开头的常量用于pathconf和fpathconf函数 pathname：文件名 fd：打开文件的文件描述符 失败的情况： 若name参数并不是一个合适的常量，则这三个函数返回-1，并将 errno设置为 EINVAL 有些name会返回一个不确定的值，这通过返回 -1 来体现，同时不改变errno","link":"/2023/03/06/linux-unix-standard/"},{"title":"UNIX环境高级编程 - UNIX基础知识","text":"所有操作系统都为运行在它之上的程序提供各种服务，典型的服务包括：执行新程序、打开文件、读写文件、分配存储空间、提供时间等。 UNIX体系结构严格来说，操作系统是一种软件，它控制计算机硬件资源，提供程序运行环境。这种软件有个专业术语名称：内核。因为它小且位于计算机体系的核心。如下图所示： 内核的接口为系统调用，系统调用包裹在内核的外围，隔离开内核以保护内核。同时，系统调用作为和内核沟通的中间桥梁。 公用函数库通常指的是C/C++的标准库，例如libc、glibc、libstdc++、libc++等标准库，不同的标准库是由于不同的系统平台或编译器厂商造成的差异，但追根究底都是使用了底层系统内核的API接口系统调用。这些公用函数库极大的方便了上层开发者的使用，也是整个计算机软件体系（无论任何编程语言）的基础。 shell也是一个软件，该软件负责人机交互，用户和shell进行“对话”，然后shell理解用户的意图来使计算机按用户的想法工作。 用户程序也可以直接使用系统调用来请求服务。 对于打印hello world于终端中，对于上面三种请求服务的方式，有： printf(&quot;hello world&quot;); echo 'hello world' 直接使用write() 登录用户名和shell由配置文件/etc/passwd决定，密码由配置文件/etc/shadow决定。 口令文件中的登录项由 : 分隔的7个字段组成： 登录名 加密口令 用户ID（数字） 组ID（数字） 注释字段 起始目录 shell程序 例如，我电脑Mac OSX中就有： 1root:*:0:0:System Administrator:/var/root:/bin/sh 文件系统UNIX文件系统是目录和文件的一种层次结构。所有东西的起点称为根目录，即“/”。 在文件系统中，目录本质上也是一个文件，其内容是目录项的记录。每个目录项都是一个文件名，还包含一些文件属性的说明信息，比如权限、大小、时间等。 创建新目录时文件系统会自动创建两个文件夹：.（点）和 ..（点点）， .（点）表示当前目录，根目录“/”下的.（点）和 ..（点点）是同一个路径，都是“/”。 由斜线“/”开头的路径都是绝对路径，反之则是相对路径。 ls(1) ls(1)指的是第一部分的ls项目，UNIX命令通常都会有一个说明手册，手册中对命令有详细说明，但随着命令功能和说明的增加，说明手册页数越来越多，之后便对命令进行了分门别类，通常是1-8总共8中分类，具体是： 1、Standard commands （标准命令）2、System calls （系统调用）3、Library functions （库函数）4、Special devices （设备说明）5、File formats （文件格式）6、Games and toys （游戏和娱乐）7、Miscellaneous （杂项）8、Administrative Commands （管理员命令） 工作目录：每个进程都有一个工作目录，一般称为当前工作目录，进程可以用chdir来更改其工作目录。 起始目录：登录时，shell程序的工作目录设置为home目录，该目录通常从/etc/passwd配置文件中获得。 输入和输出在UNIX系统中输入和输出是经过抽象的，所有的输入和输出底层系统实现都是通过文件抽象来完成的。 文件描述符：文字描述符是一个小的非负整数，内核用以标识一个特定进程正在存访的文件。当内核打 开一个现存文件或创建一个新文件时，它就返回一个文件描述符。当读、写文件时，就可使 用它。 每个程序都有默认打开的三个文件描述符： 标准输入 - fd为0 标准输出 - fd为1 标准出错 - fd为2 不带缓存的I/O：系统调用open、read、write、lseek、close，它们都使用文件描述符来操作文件，并且不带缓冲。 标准I/O：公用函数库提供的封装过的接口来间接调用系统调用，公用函数库提供的接口是带缓冲的，且无需考虑对缓冲区大小的选择。例如使用printf输出。 程序和进程程序是静态的进程，而进程是运行着的程序。程序本质上是一个存在硬盘上的可执行文件。程序被加载到内存中之后就开始执行，此时程序变成一个动态刻画抽象的进程。 进程ID：每一个进程都有一个标识符，称为进程ID，其是一个非负数，且在当前时刻是唯一的。 进程控制：有3个可以用于控制进程的系统调用：fork、exec和waitpid。其中exec是一系列函数的统称。 线程和线程ID： 一个进程内的所有线程共享当前进程的所有内存空间、文件描述符号、栈以及进程相关的属性。由于所有进程共享进程的内存空间，因此在访问共享数据时需要采取同步措施以避免数据的不一致。 同进程类似，线程也有一个ID唯一标识每一个线程，但线程的ID只在进程内部有效，进程外部则无意义。 出错处理当 UNIX 系统函数出错时，通常会返回一个负值，同时整型变量 errno 通常被设置为具有特定信息的值。 文件 &lt;errno.h&gt; 定义了 errno 以及赋予它的各种常量，这些常量以 E 字符开头 在多线程环境中，每个线程都有属于自己的局部 errno，以避免一个线程干扰另一个线程。 对于 errno 的使用要注意两条规则： 如果没有出错，则 errno 的值不会被清除.因此只有在函数的返回值指明出错了时，检查 errno 才有意义 任何函数都不会将 errno 的值清零，且在 &lt;errno.h&gt; 中定义的所有常量都不为0 strerror/perror函数:用于处理错误信息 12345#include&lt;string.h&gt;char *strerror(int errnum);#include&lt;stdio.h&gt;void perror(const char*msg); strerror: 将 errnum（通常就是 errno 值）映射为一个出错消息字符串，并且返回此字符串的指针 参数： 一个整数（通常是 errno 的值） 返回： 出错消息字符串的指针 perror: 基于 errno 的当前值，在标准错误上产生一条出错消息，然后返回。这条出错消息首先是 msg 指向的字符串，后面是冒号，后面是一个空格，后面是对应于 errno 值的出错消息，最后是一个换行符。 参数：附加的出错消息 返回：无返回。但是向标准错误上输出一条出错消息。 用户标识用户ID：用户标识也是通过ID来进行区分的，该ID称为用户ID，它是一个数字。当一个用户创建时，会在/etc/passwd文件中生成唯一的用户ID，用户不能更改这个ID，除非是root用户才允许修改。ID号码为0的用户是root用户。 组ID：用户除了用ID来进行区分，也用组来进行划分管理，相应的，其也有组ID，也是一个数字。用户的组用户ID不唯一，一个用户可以拥有多个组ID，这表明该用户加入了多个小组。组的目的是为了让多个用户共享一个资源。组相关的配置文件是/etc/group。 可以通过 getuid( ) 和 getgid( ) 函数来获得相应的用户ID和组ID。 信号信号是UNIX系统用于发送通知的一种机制，例如，若某一进程执行除法操作，其除数为0，则将名为SIGFPE的信号发送给该进程。进程收到信号通知后，有3种应对处理方法： 忽略信号。收到之后什么也不做，当做未发生一样。 按系统默认方式处理。对于除0，系统默认方式是终止该进程。 提供一个处理函数。在收到信号之后，用提供的函数来进行处理。 使用Kill -9 杀死进程 ctrl + c 中断进程 ctrl + / 退出进程 时间值UNIX 系统使用两种时间： 日历时间：自 UTC 1970年1月1日 00:00:00 以来经历过的秒数累计值。用 time_t数据类型来保存这种时间值。 进程时间：也称作CPU时间，用于度量进程使用的CPU资源。进程时间以时间滴答来计算，用clock_t数据类型保存这种时间值。 当度量一个进程的执行时间时，UNIX系统为一个进程维护了3个进程时间值： 时钟时间： 又称作墙上时钟时间，是进程运行的时间总量，其值与系统中同时运行的进程数有关 用户CPU时间：执行用户指令所用的时间量 系统CPU时间：该进程执行内核程序所经历的时间。如进程执行一个read系统调用，则内核执行该系统调用的时间计入系统 CPU 时间 用户CPU时间和系统CPU时间之和称作 CPU 时间 系统调用和库函数所有的UNIX系统都提供多种服务的入口点，由此程序可以向内核请求服务。各种UNIX都提供了良好定义、数量有限、直接进入内核的入口点。这些入口点被称为系统调用。 系统调用接口在man手册的第二部分中说明，是使用C语言定义的。 公用函数库接口在man手册的第三部分中说明，也是使用C语言定义的。它们不一定是内核的入口点，部分会间接使用一个或多个内核系统调用，而有些则完全不使用。 从实现角度看，系统调用和公用函数库有着本质区别，一个是伴随内核而产生的，是不可替换的。另一个是编译器厂商根据语言标准而实现的，可以更新和替换。但从用户角度看，它们没有太大区别，显著的区别是公用函数库更好用，功能更加强。","link":"/2023/03/06/linux-unix-base/"},{"title":"Linux网络编程 - UDP发送&#x2F;接受数据","text":"UDP （User Datagram Protocol）：用户数据报协议。 UDP 是一个不可靠的通信协议，没有重传和确认，没有有序控制，也没有拥塞控制。可以简单地理解为，在 IP 报文的基础上，UDP 增加的能力有限。 UDP编程UDP中客户端和服务器端交互的图解： UDP Server : Create UDP socket. Bind the socket to server address. Wait until datagram packet arrives from client. Process the datagram packet and send a reply to client. Go back to Step 3. UDP Client : Create UDP socket. Send message to server. Wait until response from server is received. Process reply and go back to step 2, if necessary. Close socket descriptor and exit. 主要是使用以下函数： 1234567#include &lt;sys/socket.h&gt; ssize_t recvfrom(int sockfd, void *buff, size_t nbytes, int flags, struct sockaddr *from, socklen_t *addrlen); ssize_t sendto(int sockfd, const void *buff, size_t nbytes, int flags, const struct sockaddr *to, socklen_t *addrlen); recvfrom的参数含义： sockfd ：本地创建的套接字描述符 buff ：指向本地缓存的指针 nbytes ：最大接收数据字节 flags ：与 I/O 相关的参数 from 和 addrlen：返回对端发送方的地址和端口等信息 返回值：实际接收的字节数。 sendto的参数意义： sockfd ：本地创建的套接字描述符 buff ：指向本地缓存的指针 nbytes ：最大接收数据字节 flags ：与 I/O 相关的参数 to 和 addrlen，表示发送的对端地址和端口等信息。 UDP例子UDP Server: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// Server side implementation of UDP client-server model#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netinet/in.h&gt; #define PORT 8080#define MAXLINE 1024 // Driver codeint main() { int sockfd; char buffer[MAXLINE]; char sendbuffer[MAXLINE]; struct sockaddr_in servaddr, cliaddr; // Creating socket file descriptor if ( (sockfd = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0 ) { perror(&quot;socket creation failed&quot;); exit(EXIT_FAILURE); } memset(&amp;servaddr, 0, sizeof(servaddr)); memset(&amp;cliaddr, 0, sizeof(cliaddr)); // Filling server information servaddr.sin_family = AF_INET; // IPv4 servaddr.sin_addr.s_addr = INADDR_ANY; servaddr.sin_port = htons(PORT); // Bind the socket with the server address if ( bind(sockfd, (const struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0 ) { perror(&quot;bind failed&quot;); exit(EXIT_FAILURE); } int n; socklen_t len = (socklen_t)sizeof(cliaddr); //len is value/resuslt for (;;) { n = recvfrom(sockfd, (char *)buffer, MAXLINE, MSG_WAITALL, ( struct sockaddr *) &amp;cliaddr, &amp;len); buffer[n] = '\\0'; printf(&quot;Client : %s\\n&quot;, buffer); sprintf(sendbuffer, &quot;have recieve %d bytes&quot;, strlen(buffer)); sendto(sockfd, (const char *)sendbuffer, strlen(sendbuffer), 0, (const struct sockaddr *) &amp;cliaddr, len); fprintf(stdout, &quot;%s\\n&quot;, sendbuffer); } return 0;} UDP Client: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// Client side implementation of UDP client-server model#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netinet/in.h&gt;#define PORT 8080#define MAXLINE 1024 // Driver codeint main() { int sockfd; char buffer[MAXLINE]; char *hello = &quot;Hello from client&quot;; struct sockaddr_in servaddr; // Creating socket file descriptor if ( (sockfd = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0 ) { perror(&quot;socket creation failed&quot;); exit(EXIT_FAILURE); } memset(&amp;servaddr, 0, sizeof(servaddr)); // Filling server information servaddr.sin_family = AF_INET; servaddr.sin_port = htons(PORT); servaddr.sin_addr.s_addr = INADDR_ANY; socklen_t len = (socklen_t)sizeof(servaddr); //len is value/resuslt // send msg while (fgets(buffer, MAXLINE, stdin) != NULL) { int i = strlen(buffer); if (buffer[i - 1] == '\\n') { buffer[i - 1] = 0; } sendto(sockfd, (const char *)buffer, strlen(buffer), 0, (const struct sockaddr *) &amp;servaddr, len); fprintf(stdout, &quot;message: %s have sent.\\n&quot;, buffer); int n = recvfrom(sockfd, (char *)buffer, MAXLINE, MSG_WAITALL, (struct sockaddr *) &amp;servaddr, &amp;len); buffer[n] = '\\0'; printf(&quot;Server : %s\\n&quot;, buffer); } close(sockfd); return 0;} 情况1: 只运行客户端、不开启服务端可以看见，没有响应，也发送不了数据。程序会一直阻塞在 recvfrom 上。 情况2: 先开启服务端，再开启客户端 也可以使用多个UDP客户端去和UDP服务器端通信，不再细述。 总结 UDP 是无连接的数据报程序，和 TCP 不同，不需要三次握手建立一条连接。 UDP 程序通过 recvfrom 和 sendto 函数直接收发数据报报文。 reference[1] 极客时间 · 网络编程实战 ：06 | 嗨，别忘了UDP这个小兄弟 [2] UDP Server-Client implementation in C","link":"/2023/03/06/linux-network-udp/"},{"title":"Linux网络编程 - 发送&#x2F;接收数据 &amp; 缓冲区","text":"发送数据可以用以下三个函数发送数据。每个函数都是单独使用的，使用的场景略有不同。 12345ssize_t write (int socketfd, const void *buffer, size_t size); #include &lt;sys/socket.h&gt;ssize_t send (int socketfd, const void *buffer, size_t size, int flags);ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags); write 就是常见的文件写函数（Linux中一切皆为文件）。 对于普通文件描述符而言，操作系统内核不断地往文件系统中写入字节流。 写入的字节流大小通常和输入参数 size 的值是相同的，否则表示出错。 对于套接字描述符而言，它代表了一个双向连接。 写入的字节数有可能比请求的数量少。 send 可以指定选项，发送带外数据（一种基于 TCP 协议的紧急数据，用于客户端 - 服务器在特定场景下的紧急处理）。 sendmsg 指定多重缓冲区传输数据，以结构体 msghdr 的方式发送数据。 msghdr定义： 12345678910111213&gt;struct iovec { /* Scatter/gather array items */void *iov_base; /* Starting address */size_t iov_len; /* Number of bytes to transfer */&gt;};&gt;struct msghdr {void *msg_name; /* Optional address */socklen_t msg_namelen; /* Size of address */struct iovec *msg_iov; /* Scatter/gather array */size_t msg_iovlen; /* # elements in msg_iov */void *msg_control; /* Ancillary data, see below */size_t msg_controllen; /* Ancillary data buffer len */int msg_flags; /* Flags on received message */&gt;}; 发送缓冲区当 TCP 三次握手成功，TCP 连接成功建立后，操作系统内核会为每一个连接创建配套的基础设施，比如发送缓冲区。 发送缓冲区的大小可以通过套接字选项来改变，当应用程序调用 write 函数时，实际所做的事情是把数据从应用程序中拷贝到操作系统内核的发送缓冲区中，并不一定是把数据通过套接字写出去。 wirte() 的返回时机：直到某一个时刻，应用程序的数据可以完全放置到发送缓冲区里，write() 阻塞调用返回。 读取数据12345ssize_t read (int socketfd, void *buffer, size_t size);#include &lt;sys/socket.h&gt;ssize_t recv(int sockfd, void *buf, size_t len, int flags);ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags); read 函数要求操作系统内核从套接字描述字 socketfd 读取最多多少个字节（size），并将结果存储到 buffer 中。 返回值表示实际读取的字节数目，如果返回值为 0，表示 EOF（end-of-file），这在网络中表示对端发送了 FIN 包，要处理断连的情况；如果返回值为 -1，表示出错。 read 是最多读取 size 个字节。循环读取，每次都读到 size 个字节的函数： 1234567891011121314151617181920size_t readn(int fd, void *buffer, size_t size) { char *buffer_pointer = (char *)buffer; int length = size; while (length &gt; 0) { int result = read(fd, buffer_pointer, length); if (result &lt; 0) { if (errno == EINTR) continue; /* 考虑非阻塞的情况，这里需要再次调用read */ else return (-1); } else if (result == 0) break; /* EOF(End of File)表示套接字关闭 */ length -= result; buffer_pointer += result; } return (size - length); /* 返回的是实际读取的字节数*/} 例子common.h : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#pragma once#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;string.h&gt;#include &lt;string&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;/* error - print a diagnostic and optionally exit */void error(int status, int err, char *fmt, ...) { va_list ap; va_start(ap, fmt); vfprintf(stderr, fmt, ap); va_end(ap); if (err) { fprintf(stderr, &quot;: %s (%d)\\n&quot;, strerror(err), err); } if (status) { exit(status); }}int tcp_client(char *address, int port) { int socket_fd; socket_fd = socket(AF_INET, SOCK_STREAM, 0); struct sockaddr_in server_addr; bzero(&amp;server_addr, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(port); inet_pton(AF_INET, address, &amp;server_addr.sin_addr); socklen_t server_len = sizeof(server_addr); int connect_rt = connect(socket_fd, (struct sockaddr *) &amp;server_addr, server_len); if (connect_rt &lt; 0) { error(1, errno, &quot;connect failed &quot;); } return socket_fd;}size_t readn(int fd, void *buffer, size_t size) { char *buffer_pointer = (char *)buffer; int length = size; while (length &gt; 0) { int result = read(fd, buffer_pointer, length); if (result &lt; 0) { if (errno == EINTR) continue; /* 考虑非阻塞的情况，这里需要再次调用read */ else return (-1); } else if (result == 0) break; /* EOF(End of File)表示套接字关闭 */ length -= result; buffer_pointer += result; } return (size - length); /* 返回的是实际读取的字节数*/} Client: 12345678910111213141516171819202122232425262728293031323334353637383940#include &quot;tcp_send_read/common/commom.h&quot;# define MESSAGE_SIZE 1024 * 1024 * 100void send_data(int sockfd) { char *query; query = (char *)malloc(MESSAGE_SIZE + 1); for (int i = 0; i &lt; MESSAGE_SIZE; i++) { query[i] = 'a'; } query[MESSAGE_SIZE] = '\\0'; const char *cp; cp = query; size_t remaining = strlen(query); while (remaining) { int n_written = send(sockfd, cp, remaining, 0); fprintf(stdout, &quot;send into buffer %ld \\n&quot;, n_written); if (n_written &lt;= 0) { error(1, errno, &quot;send failed&quot;); return; } remaining -= n_written; cp += n_written; } return;}int main(int argc, char **argv) { struct sockaddr_in servaddr; if (argc != 2) error(1, 0, &quot;usage: tcpclient &lt;IPaddress&gt;&quot;); int sockfd = tcp_client(argv[1], 12345); send_data(sockfd); exit(0);} Server: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &quot;tcp_send_read/common/commom.h&quot;#define BUFFER_SIZE 1024 * 1024void read_data(int sockfd) { ssize_t n; char buf[BUFFER_SIZE]; int time = 0; for (;;) { fprintf(stdout, &quot;block in read\\n&quot;); if ((n = readn(sockfd, buf, BUFFER_SIZE)) == 0) { // EOF fprintf(stdout, &quot;read 0, close it!\\n&quot;); fflush(stdout); // must flust it! return; } time++; fprintf(stdout, &quot;1M read for %d \\n&quot;, time); usleep(2000); }}int main(int argc, char **argv) { int listenfd, connfd; socklen_t clilen; struct sockaddr_in cliaddr, servaddr; listenfd = socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(12345); /* bind到本地地址，端口为12345 */ bind(listenfd, (struct sockaddr *) &amp;servaddr, sizeof(servaddr)); /* listen的backlog为1024 */ listen(listenfd, 1024); /* 循环处理用户请求 */ for (;;) { clilen = sizeof(cliaddr); connfd = accept(listenfd, (struct sockaddr *) &amp;cliaddr, &amp;clilen); read_data(connfd); /* 读取数据 */ close(connfd); /* 关闭连接套接字，注意不是监听套接字*/ }} 此程序能说明几个问题： 阻塞式套接字最终发送返回的实际写入字节数和请求字节数是相等的 对于 send 来说，返回成功仅表示数据写到发送缓冲区成功，并不意味着对端已经成功收到（对端何时收到，对发送者透明） reference[1] 极客时间 · 网络编程实战 ：05 | 使用套接字进行读写：开始交流吧 [2] Linux高性能服务器编程","link":"/2023/03/06/linux-network-send-recv/"},{"title":"树莓派 - 开启ssh服务并固定ip","text":"开启ssh服务 进入菜单(Menu) -&gt; 首选项(Preferences) -&gt; Raspberry Pi Configuration -&gt; Interfaces。 将ssh开关打开 通过ssh命令登陆远端机器 12// @前为用户名，@后为远端机器地址（可以是url），IP可通过ifconfig查看，或登陆路由器ssh pi@192.168.1.100 固定树莓派IP因为公网IP不够，我们所用的网络IP都是DHCP服务器租借的IP地址（涉及网络中的DHCP和NAT协议），因此树莓派的IP地址其实并不固定。为了方便SSH登陆，因此固定树莓派的IP地址。 远端登陆树莓派 / 树莓派打开终端 通过 ifconfig 命令查看树莓派的IP地址 进入编辑界面 1sudo nano /etc/dhcpcd.conf 修改配置文件（需要对着 ifconfig 的输出wlan改，重点是改ip_address和routers） 保存、退出 重启树莓派 1sudo reboot 重启后即可通过固定的IP访问树莓派了。 需要注意的是：若固定的IP和DHCP租借出去的IP冲突，则有不能上网的可能，因此可以改一个DHCP地址池中稍微靠后的IP。","link":"/2023/03/06/hardware-Raspberry-Pi-ssh/"},{"title":"树莓派 - 树莓派开机自启动","text":"树莓派系统下简单的设置开机自启动程序： 在要运行的程序的同级目录下新建一个脚本start.sh 1sudo nano start.sh 脚本如下： 123#!/bin/shcd /home/pi/Desktop/timersudo ./timer 修改脚本文件权限 1sudo chmod 777 /hone/pi/Desktop/timer/start.sh 将脚本文件添加进rc.local中 1sudo nano /etc/rc.local ​ 加入如下内容： 1/home/pi/Desktop/timer/start.sh start 重启树莓派 1reboot 远程登录树莓派，可以发现已经自动启动我所写的定时程序：","link":"/2023/03/06/hardware-Raspberry-Pi-self-start/"},{"title":"ostep - 进程API","text":"概述进程的基本操作接口： 进程创建：fork (spawn, vfork, clone) 进程执行：exec 进程间同步：wait 进程退出：exit/abort 进程创建：fork()fork()语义：为调用进程创建一个一模一样的新进程，fork后的两个进程均为独立进程（调用进程为父进程，新进程为子进程）。 函数原型： 1234#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t fork(void); // 出错返回-1，子进程返回0，父进程返回子进程PID fork()调用的特点： 调用一次、返回两次 并发执行 相同但独立的地址空间 共享文件 fork为进程之间建立了父进程和子进程的关系，在进程之间建立了树型结构。 多个进程可以属于同一个进程组： 子进程默认与父进程属于同一个进程组 可以向同一进程组中的所有进程发送信号 主要用于shell程序中 写时拷贝（Copy-On-Write）：只拷贝内存映射，不拷贝实际内存 性能较好：一条映射至少对应一个4K的页面 调用exec的情况里，减少了无用的拷贝 进程的执行：exec()exec()语义：为进程指定可执行文件和参数。在fork之后调用exec，可以在载入可执行文件后会重置地址空间。 函数原型： 1234#include &lt;unistd.h&gt;//成功不返回，错误返回-1int execve(const char *filename, char *const argv[], char *const envp[]); exec()调用一次，并从不返回。 exec()的执行过程： exec()函数加载并运行可执行文件filename，以参数列表argv和环境变量列表envp为参数。 argv变量指向一个以null 结尾的指针数组，其中每个指针都指向一个参数字符串。按照惯例，argv [0]是可执行目标文件的名字。 envp变量指向一个以 null 结尾的指针数组，其中每个指针指向一个环境变量字符串，每个串都是形如name=value的名字一值对。 程序加载的过程： 创建内存映像 在程序头部表的引导下，加载器将可执行文件的片(chunk)复制到代码段和数据段。 加载器跳转到程序的入口点,也就是_start 函数的地址（系统目标文件 ctrl.o中定义）。 start 函数调用系统启动函数__libc_start_main（定义在libc.so 中）。 __libc_start_main初始化执行环境，调用用户层的 main 函数,处理 main函数的返回值,并且在需要的时候把控制返回给内核。 加载的过程（另一种描述）： 加载器删除子进程现有的虚拟內存段,并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零。通过将虛拟地址空间中的页映射到可执行文件的页大小的片(chunk),新的代码和数据段被初始化为可执行文件的内容。最后,加载器跳转到_start地址,它最终会调用应用程序的 main 函数。除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制。直到 CPU 引用一个被映射的虛拟页时才会进行复制，此时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。 main函数原型： 123int main(int argc, char **argv, char **envp);// 或者等价的int main(int argc, char *argv [], char *envp[); 当main函数开始执行时，用户栈的结构如下图。stack的中间是envp[]和argv[]表示的指针数组，每个指针指向一个底端的变量字符串；stack的顶端是系统启动函数libc_start_main。 回收子进程：wait()语义：等待子进程终止或停止。可以使用 wait()系统调用（或者更完整的兄弟接口 waitpid()）。 wait()函数原型：父进程一旦调用了wait就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。 1234#include &lt;sys/types.h&gt;/* 提供类型pid_t的定义*/#include &lt;wait.h&gt;int wait(int *status) waitpid()函数原型： 12345#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;//:如果成功,返回子进程的 PID,如果 WNOHANG,则为0,如果其他错误,则为-1。pid t waitpid(pid_t pid, int *statusp, int options); 例子创建一个子进程，统计一个文件的词数，然后父进程等待子进程介绍，回收之。 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/wait.h&gt;intmain(int argc, char *argv[]){ printf(&quot;hello world (pid:%d)\\n&quot;, (int) getpid()); int rc = fork(); if (rc &lt; 0) { // fork failed; exit fprintf(stderr, &quot;fork failed\\n&quot;); exit(1); } else if (rc == 0) { // child (new process) printf(&quot;hello, I am child (pid:%d)\\n&quot;, (int) getpid()); char *myargs[3]; myargs[0] = strdup(&quot;wc&quot;); // program: &quot;wc&quot; (word count) myargs[1] = strdup(&quot;p3.c&quot;); // argument: file to count myargs[2] = NULL; // marks end of array execvp(myargs[0], myargs); // runs word count printf(&quot;this shouldn't print out&quot;); } else { // parent goes down this path (original process) int wc = wait(NULL); printf(&quot;hello, I am parent of %d (wc:%d) (pid:%d)\\n&quot;, rc, wc, (int) getpid()); } return 0;} 运行后有结果： Why’s the design?为什么系统设计者要设计如此奇怪的接口（fork + exec），来完成简单的、 创建新进程的任务？ LAMPSON 定律：做对事（Get it right）。抽象和简化都不能替代做对事。 事实证明，这种分离 fork()及 exec()的做法对构建 UNIX shell 非常有用，因为这给了 shell 在 fork 之后 exec 之前运行代码的机会，这些代码可以在运行新程序前改变环境，从而让一系列有趣的功能很容易实现（比如重定向）。 1wc p3.c &gt; newfile.txt 重定向的工作原理：子进程向标准输出文件描述符的写入被透明地转向新打开的文件（可以使用dup2()函数）。 因此有如下代码（运行之，结果被存储在一个文件中）： 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;assert.h&gt;#include &lt;sys/wait.h&gt;intmain(int argc, char *argv[]){ int rc = fork(); if (rc &lt; 0) { // fork failed; exit fprintf(stderr, &quot;fork failed\\n&quot;); exit(1); } else if (rc == 0) { // child: redirect standard output to a file close(STDOUT_FILENO); open(&quot;./p4.output&quot;, O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU); // now exec &quot;wc&quot;... char *myargs[3]; myargs[0] = strdup(&quot;wc&quot;); // program: &quot;wc&quot; (word count) myargs[1] = strdup(&quot;p4.c&quot;); // argument: file to count myargs[2] = NULL; // marks end of array execvp(myargs[0], myargs); // runs word count } else { // parent goes down this path (original process) int wc = wait(NULL); assert(wc &gt;= 0); } return 0;} UNIX 管道也是用类似的方式实现的，但用的是 pipe()系统调用。在这种情况下，一个 进程的输出被链接到了一个内核管道（pipe）上，另一个进程的输入也被连接到了同一个管道上。前一个进程的输出无缝地作为后一个进程的输入，许多命令可以用这种方式串联在一起，共同完成某项任务。 1grep -o foo file | wc -l。 reference[1] 操作系统导论（ostep [2] 深入理解计算机系统 [3] 上海交通大学并行与分布式系统研究所-进程","link":"/2023/03/06/os-ostep-process-api/"},{"title":"ostep - 线程","text":"概述线程（thread），又被称为轻量级进程（Lightweight Process, LWP）是程序执行流的最小单位，也是调度的基本单位。 为什么需要线程？ 创建进程的开销较大：包括了数据、代码、堆、栈等 进程的隔离性过强：进程间交互可以通过进程间通信（IPC），但开销较大 进程内部无法支持并行 线程相较于进程，是一种更加轻量级的运行时抽象。 线程只包含运行时的状态：线程执行状态（运行、就绪等）、线程上下文（PC等寄存器集合）、栈。 一个进程可以包含多个线程：多个线程共享同一地址空间。 多线程进程的地址空间 每个线程拥有自己的栈。 内核中也有为线程准备的内核栈。 其它区域（数据、代码、堆）共享。 用户态线程与内核态线程根据线程是否受内核管理，可以将线程分为两类： 内核态线程 内核可见，受内核管理 由内核创建，线程相关信息存放在内核中 用户态线程 内核不可见，不受内核直接管理 在应用态创建，线程相关信息主要存放在应用数据中 与内核线程相比，用户态线程更加轻量级，创建开销更小，但功能也较为受限，与内核态相关的操作（系统调用）需要内核态线程协助才能完成。 线程模型线程模型表示了用户态线程与内核态线程之间的联系。 多对一模型：多个用户态线程对应一个内核态线程 一对一模型：一个用户态线程对应一个内核态线程 多对多模型：多个用户态线程对应多个内核态线程 指标 多对一模型 一对一模型 多对多模型 概念 将多个用户态线程映射给单一的内核线程 每个用户线程映射单独的内核线程 N个用户态线程映射到M个内核态线程（N &gt; M） 优点 高效的上下文切换和无限制的线程数量内核管理简单 用户线程和内核线程一致可扩展性好 解决了可扩展性问题（多对一）和线程过多问题（一对一） 缺点 可扩展性差，无法适应多核机器的发展一个用户线程阻塞，导致内核线程阻塞，其他线程也无法执行 os会限制内核线程数量，因此用户线程数量受到限制内核线程上下文切换开销大 管理复杂 实际情况 在主流操作系统中被弃用用于各种用户态线程库中 主流操作系统(Windows、Linux、OS X)都采用一对一模型 在虚拟化中得到了广泛应用 相关数据结构：TCB 线程控制块一对一模型的TCB可以分为两部分 内核态：与PCB结构类似 Linux中进程与线程使用的是同一种数据结构（task_struct） 上下文切换中会使用 应用态：可以由线程库定义 Linux：pthread结构体 Windows：TIB（Thread Information Block） 可以认为是内核TCB的扩展 TLS 线程本地存储不同线程可能会执行相同的代码（线程不具有独立的地址空间，多线程共享代码段）。 对于全局变量，不同线程可能需要不同的拷贝（用于标明系统调用错误的errno）。 使用TLS可以很方便的实现线程内的全局变量。 线程库允许定义每个线程独有的数据 __thread int id; 会为每个线程定义一个独有的id变量 每个线程的TLS结构相似 可通过TCB索引 TLS寻址模式：基地址＋偏移量 X86: 段页式 (fs寄存器) AArch64: 特殊寄存器tpidr_el0 reference[1] 上海交通大学并行与分布式系统研究所-进程 [2] 操作系统导论（ostep） [3] 操作系统-精髓与设计原理 [4] 现代操作系统 [5] 程序员的自我修养","link":"/2023/03/06/os-ostep-thread/"},{"title":"矩阵论 - 10 - 四个基本子空间","text":"四个基本子空间四个子空间 Four subspaces对于任意的 $m \\times n$ 矩阵 $A$，若 $rank(A)=r$ ，则有： 行空间 $C(A^T)$ $A$ 的行向量的线性组合在 $\\mathbb{R}^n$ 空间中构成的子空间，也就是矩阵 $A^T$ 的列空间。 $C(A^T) \\in \\mathbb{R}^n, dim C(A^T)=r$： 行空间的基：将矩阵 $A$ 化为行阶梯矩阵：$A=\\begin{bmatrix}1 &amp; 2 &amp; 3 &amp; 1 \\1 &amp; 1 &amp; 2 &amp; 1 \\1 &amp; 2 &amp; 3 &amp; 1 \\\\end{bmatrix}\\underrightarrow{消元、化简}\\begin{bmatrix}1 &amp; 0 &amp; 1 &amp; 1 \\0 &amp; 1 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 0 \\\\end{bmatrix}=R$ 行变换影响了 $A$ 的列空间，所以 $C(R) \\neq C(A)$，但行变换并不影响行空间，所以可以在矩阵 $R$ 中看出前两行就是行空间的一组基。 无论对于矩阵$A$还是$R$，其行空间的一组基，可以由行阶梯矩阵 $R$ 的前 $r$ 行向量组成。 零空间 $N(A)$ $Ax=0$ 的所有解 $x$ 在 $\\mathbb{R}^n$ 空间中构成的子空间。 $N(A) \\in \\mathbb{R}^n, dim N(A)=n-r$，自由元所在的列即可组成零空间的一组基。 列空间 $C(A)$ $A$ 的列向量的线性组合在 $\\mathbb{R}^m$ 空间中构成的子空间。 $C(A) \\in \\mathbb{R}^m, dim C(A)=r$，主元所在的列即可组成列空间的一组基。 左零空间 $N(A^T)$ 矩阵 $A^T$ 的零空间为矩阵 $A$ 的左零空间，是 $\\mathbb{R}^m$ 空间中的子空间。 为什么叫左零空间：$A^Ty=0 \\rightarrow (A^Ty)^T=0^T\\rightarrow y^TA=0^T$ $N(A^T) \\in \\mathbb{R}^m, dim N(A^T)=m-r$： 左零空间的基： 应用增广矩阵 $\\left[\\begin{array}{c|c}A_{m \\times n} &amp; I_{m \\times n}\\end{array}\\right] \\rightarrow \\left[\\begin{array}{c|c}R_{m \\times n} &amp; E_{m \\times n}\\end{array}\\right]$ 将 $A$ 通过消元得到矩阵 $R$ ，其消元矩阵记为 $E$ 。 则有 $EA=R$ （若 $A$ 为可逆方阵，则有 $E=A^{-1}$） 例子：$$\\left[\\begin{array}{c|c}A_{m \\times n} &amp; I_{m \\times m}\\end{array}\\right]=\\left[\\begin{array}{c c c c|c c c}1 &amp; 2 &amp; 3 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\1 &amp; 1 &amp; 2 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\1 &amp; 2 &amp; 3 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\\\end{array}\\right]\\underrightarrow{消元、化简}\\left[\\begin{array}{c c c c|c c c}1 &amp; 0 &amp; 1 &amp; 1 &amp; -1 &amp; 2 &amp; 0 \\0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; -1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 1 \\\\end{array}\\right]=\\left[\\begin{array}{c|c}R_{m \\times n} &amp; E_{m \\times m}\\end{array}\\right]$$则$$EA=\\begin{bmatrix}-1 &amp; 2 &amp; 0 \\1 &amp; -1 &amp; 0 \\-1 &amp; 0 &amp; 1 \\\\end{bmatrix}\\cdot\\begin{bmatrix}1 &amp; 2 &amp; 3 &amp; 1 \\1 &amp; 1 &amp; 2 &amp; 1 \\1 &amp; 2 &amp; 3 &amp; 1 \\\\end{bmatrix}\\begin{bmatrix}1 &amp; 0 &amp; 1 &amp; 1 \\0 &amp; 1 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 0 \\\\end{bmatrix}=R$$很明显，式中 $E$ 的最后一行对 $A$ 的行做线性组合后，得到 $R$ 的最后一行，即 $0$ 向量，也就是 $y^TA=0^T$。 总结四个子空间维度以及其之间关系可以参考Gilbert Strang的图： 行空间求法：将矩阵 $A$ 化为行阶梯矩阵，前 r 行向量。 零空间求法：将矩阵 $A$ 化为行阶梯矩阵，得出自由列个数，自由列一个个赋1，其他皆0，求解方程，得出自由列个数个特解，特解的线性组合就是 $A$ 的零空间。 列空间求法：主元所在的列即可组成列空间的一组基。 左零空间求法：应用增广矩阵 $\\left[\\begin{array}{c|c}A_{m \\times n} &amp; I_{m \\times n}\\end{array}\\right] \\rightarrow \\left[\\begin{array}{c|c}R_{m \\times n} &amp; E_{m \\times n}\\end{array}\\right]$ ，套用 $EA=R$ ，使得 $R$ 的某行为 $0$ 的$E$ 对应行向量。 reference[1] textbook [2] mit18.06学习笔记-0 [3] mit18.06学习笔记-1","link":"/2023/03/06/math-matrix-10/"}],"tags":[{"name":"cmu15445","slug":"cmu15445","link":"/tags/cmu15445/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"stl","slug":"stl","link":"/tags/stl/"},{"name":"mit6.824","slug":"mit6-824","link":"/tags/mit6-824/"},{"name":"mit6.s081","slug":"mit6-s081","link":"/tags/mit6-s081/"},{"name":"linux0.11","slug":"linux0-11","link":"/tags/linux0-11/"},{"name":"hitos","slug":"hitos","link":"/tags/hitos/"},{"name":"debug","slug":"debug","link":"/tags/debug/"},{"name":"linux使用","slug":"linux使用","link":"/tags/linux%E4%BD%BF%E7%94%A8/"},{"name":"linux编程","slug":"linux编程","link":"/tags/linux%E7%BC%96%E7%A8%8B/"},{"name":"qt","slug":"qt","link":"/tags/qt/"},{"name":"effective C++","slug":"effective-C","link":"/tags/effective-C/"},{"name":"网络编程","slug":"网络编程","link":"/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"树莓派","slug":"树莓派","link":"/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"ostep","slug":"ostep","link":"/tags/ostep/"},{"name":"操作系统理论","slug":"操作系统理论","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/"},{"name":"矩阵论","slug":"矩阵论","link":"/tags/%E7%9F%A9%E9%98%B5%E8%AE%BA/"}],"categories":[{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"分布式系统","slug":"分布式系统","link":"/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"杂七杂八","slug":"杂七杂八","link":"/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"name":"数据库系统","slug":"数据库系统","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"硬件","slug":"硬件","link":"/categories/%E7%A1%AC%E4%BB%B6/"},{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"}],"pages":[]}