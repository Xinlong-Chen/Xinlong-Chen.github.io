{"posts":[{"title":"CPP - const限定符","text":"const修饰的变量，它的值不能被改变。只能执行不改变其内容的操作。const修饰的变量一样能进行算数运算等操作。 1const int bufSize = 512; 如果对其进行修改，则会引发错误。 1bufSize = 1024; //error const对象必须初始化 const修饰不具有传递性 1234567const int j = get_size(); //correctconst int j = 42; //correctconst int k; // errorint i = 1024;const int ci = i; //correctint j = ci; //correct 默认状态下，const对象仅在文件内有效 编译时，编译器将变量替换成对应的值（类似于define），因为const对象仅在文件内有效，如果要让其他文件访问到，需要添加extern关键字。 1234//file1.cc 定义并初始化一个常量，它可以被其他文件访问extern const int bufSize = fcn();//file1.h 头文件extern const int bufSize; // 与file1.cc的相同 对常量的引用（reference to const）：把引用绑定到const对象上。对常量的引用不可以修改它所绑定的对象。 1234const int ci =1024;const int &amp;r1 = ci; //correctr1 = 41; //errorint &amp;r2 = ci; //correct,r2非常量引用 对const的引用的初始化： 初始化常量引用可以用任何表达式作为初始值 1234int i = 42;const int &amp;r1 = i; //correctconst int &amp;r2 = r1*2; //correctint &amp;r3 = r1*2; //error，结合下文，error原因为绑定的为一个临时量对象， 解释： 假设有如下代码： 12double dval = 3.14;const int &amp;ri = dval; dval为双精度浮点数，为了确保让ri绑定上一个整数，编译器将上述代码变成如下形式： 12const int temp = dval; //由浮点数生产一个临时的整形变量const int &amp;ri = temp; ri绑定了一个临时量对象。这个临时量对象是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。 对const的引用可能引用一个并非const的对象 12345int i = 42;int &amp;r1 = i;const int &amp;r2 = i;r1 = 0; //correctr2 = 0; //error 指向常量的指针（pointer to const） 要想存放常量对象的地址，必须使用指向常量的指针。 1234const double pi = 3.14;double *ptr = &amp;pi; //errorconst double *cptr = &amp;pi; //correct*cptr = 1; //error 对象的值能不能改变，还得看自身是不是const，引用和指针的const是保证自己不去改变变量的值。 const指针：指针是一个对象，因此可以将指针定义为const。 常量指针（const pointer）必须初始化，一旦初始化完成，他的值（指向的地址）就不能改变。 *放const之前，说明指针是一个常量（另一层意思：指针本身的值不变，指向的值可以变） 12345int errNum = 0;int *const curErr = &amp;errNum; //curErr一直指向errNumconst double pi = 3.14;const double *const pop = &amp;pi; // pop是一个指向常量对象的常量指针//阅读方法：从右往左读 顶层const 顶层const：指针本身是个常量（靠近变量） 底层const：指针所指对象是一个常量","link":"/2023/03/05/cpp-const/"},{"title":"CMU15445 - lab1","text":"本文为本人完成15445 2020fall（B+树版本）时的一些记录，仅作为备忘录使用。 TASK #1 - LRU REPLACEMENT POLICY本任务为实现一个LRU页面置换策略，建立一个关于面向磁盘的数据库的基本的概念是很重要的，如下图： 从中可以看出，实际数据是持久化存储于磁盘之上的，执行引擎主要进行一些数据操作（读/写，也即对Page增删改查），而BufferPool则是介于执行引擎和磁盘之间，位于内存中，给执行引擎提供Page。由于存储器体系结构一般表现为内存容量远小于磁盘容量，因此BufferPool是无法加载整个db的所有Pages的，因此需要在合适的时机将Page写入磁盘中，LRU就决定了牺牲哪个Page（即将哪个Page写回到磁盘中），其中包含了局部性原理的思想。 在Buffer Pool中，Page是存放在frame中的，这是要注意的一个点（buffer pool就是一个能容放多个Page的vector）。 The size of the LRUReplacer is the same as buffer pool since it contains placeholders for all of the frames in the BufferPoolManager. However, not all the frames are considered as in the LRUReplacer. The LRUReplacer is initialized to have no frame in it. Then, only the newly unpinned ones will be considered in the LRUReplacer. 所要实现的接口主要是下面四个： Victim(T*) : Remove the object that was accessed the least recently compared to all the elements being tracked by the Replacer, store its contents in the output parameter and return True. If the Replacer is empty return False. Pin(T) : This method should be called after a page is pinned to a frame in the BufferPoolManager. It should remove the frame containing the pinned page from the LRUReplacer. Unpin(T) : This method should be called when the pin_count of a page becomes 0. This method should add the frame containing the unpinned page to the LRUReplacer. Size() : This method returns the number of frames that are currently in the LRUReplacer. LRU的实现十分的简单，是经典的leetcode题，用list套一个unordered_map即可实现。 下面主要讲一下我对Pin和UnPin的理解： Pin(T) : 将一个Page(frame)从LRU的list中剔除。即该Page(frame)被Buffer Pool所使用了，LRU不应该牺牲该页面。 Unpin(T) : 加入一个Page(frame)入LRU的list。即该页面Buffer Pool目前没人使用了，LRU根据策略决定该页面的去留。 Victim(T*) :意思很直接，LRU根据规则（最近最少使用）有选择性的牺牲一个页面(frame)。 并发的话，直接加大锁就好了。std::lock_guard是一种RAII的加锁方式，可以不用unlock（在析构的时候unlock），比较方便。给出Victim的实现方法，其他的应 Prof. Pavlo 要求就不放出来了。 1234567891011bool LRUReplacer::Victim(frame_id_t *frame_id) { std::lock_guard&lt;std::mutex&gt; lock(latch_); if (id2iter_.empty()) { return false; } auto deleting_id = lru_list_.back(); lru_list_.pop_back(); id2iter_.erase(deleting_id); *frame_id = deleting_id; return true;} TASK #2 - BUFFER POOL MANAGER第二个任务为构造一个Buffer Pool。 The BufferPoolManager is responsible for fetching database pages from the DiskManager and storing them in memory. The BufferPoolManager can also write dirty pages out to disk when it is either explicitly instructed to do so or when it needs to evict a page to make space for a new page. 实现以下几个接口： FetchPageImpl(page_id) NewPageImpl(page_id) UnpinPageImpl(page_id, is_dirty) FlushPageImpl(page_id) DeletePageImpl(page_id) FlushAllPagesImpl() (其实可以先通过测试程序了解这几个接口怎么用的，然后再去实现会比较好！) NewPageImpl(page_id)：新建一个Page。 FetchPageImpl(page_id)：获取一个Page。 UnpinPageImpl(page_id, is_dirty)：解除对某个Page的使用（别的进程可能还在使用，pin_count为0的时候可以删除） DeletePageImpl(page_id)：删除一个Page。 FlushPageImpl(page_id)：强制将某个Page写盘。 FlushAllPagesImpl()：将所有Page写盘。 这个task其实本质上就是考验对下面两个点的理解，根据提示看看DiskManager 的API是比较好实现的： Dirty Flag ：当该flag为真时，该页被写过了，要写回磁盘。 Pin/Reference Counter：引用计数，当该计数为0时，将对应frame加入LRU中；当该计数不为0时，将对应frame从LRU中删除（即不参与LRU的替换）。 该task有几个坑需要注意一下： 重复UnpinPageImpl，但is_dirty标志不同。 不是简单的赋值设置is_dirty标志，而是累计，即或一下。 page-&gt;is_dirty_ |= is_dirty; New完一个Page后，其pin_count为1，因此不要将这个Page放入LRU。 replacer_-&gt;Pin(fid); New完一个Page后，要立即刷盘。可能会有new完以后unpin(false)的情况，不刷盘这一页就丢失了 disk_manager_-&gt;WritePage(new_page-&gt;GetPageId(), new_page-&gt;GetData()); 获取frame时，先从free list获取，再从lru中获取。 12345678910111213141516/*** @brief get a free page from free_list or lru_list** @return frame_id_t frame id, -1 is error*/frame_id_t BufferPoolManager::get_free_frame() {frame_id_t frame_id = -1;if (!free_list_.empty()) { frame_id = free_list_.front(); free_list_.pop_front();} else { replacer_-&gt;Victim(&amp;frame_id);}return frame_id;} 删除一个Page时，要保证free list和LRU中只存在一个fid，而不是两边都有。 replacer_-&gt;Pin(fid); free_list_.emplace_back(fid); 由于是多线程的程序，可以多跑几次测试一下，通过日志排查出错的原因。 12345678910111213141516#!/usr/bin/env bashtrap 'exit 1' INTecho &quot;Running test $1 for $2 iters&quot;for i in $(seq 1 $2); do echo -ne &quot;\\r$i / $2&quot; LOG=&quot;$i.txt&quot; # Failed go test return nonzero exit codes $1 &amp;&gt; $LOG if [[ $? -eq 0 ]]; then rm $LOG else echo &quot;Failed at iter $i, saving log at $LOG&quot; fidone （gradescope上测试要是失败了可以直接偷测试文件，逃 若有概念不理解的可以翻翻课件。","link":"/2023/03/05/cmu15445-lab1/"},{"title":"CPP - 头文件","text":"1 头文件的布局： 2 #define 保护 所有头文件都应该有 #define 保护来防止头文件被多重包含, 命名格式当是: &lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_ 。 防御式开头防止重复include头文件。 1234#ifndef COMMON_H#define COMMON_H//.... code#endif //COMMON_H Google C++规范： 为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径。 例如, 项目 foo 中的头文件 foo/src/bar/baz.h 可按如下方式保护: 1234#ifndef FOO_BAR_BAZ_H_#define FOO_BAR_BAZ_H_...#endif // FOO_BAR_BAZ_H_ 也可以使用 1#pragma once 3 前置声明 尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。 前置声明（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义。 前置声明是为了降低编译依赖，防止修改一个头文件引发多米诺效应。 Google C++规范： 优点： 节省编译时间：多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。 节省不必要的重新编译的时间： #include 使代码因为头文件中无关的改动而被重新编译多次。 缺点： 前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。 前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。 极端情况下，用前置声明代替 #include 甚至都会暗暗地改变代码的含义： 123456789// b.h:struct B {};struct D : B {};// good_user.cc:#include &quot;b.h&quot;void f(B*);void f(void*);void test(D* x) { f(x); } // calls f(B*) ​ 如果 #include 被 B 和 D 的前置声明替代， test() 就会调用 f(void*) 结论： 尽量避免前置声明那些定义在其他项目中的实体. 函数：总是使用 #include. 类模板：优先使用 #include. 4 内联函数 只有当函数只有 10 行甚至更少时才将其定义为内联函数. 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用。 在类的声明中定义的函数将被编译器尝试翻译为内联函数。 优点: 只要内联的函数体较小, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联. 缺点: 滥用内联将导致程序变得更慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。 经验： 不要内联超过 10 行的函数 谨慎对待析构函数 内联包含循环或 switch 语句的函数往往得不偿失 一般不会被内联的函数：虚函数和递归函数不会被正常内联 5 #include 的路径及顺序 使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 .h, 本项目内的 .h. 项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 . (当前目录) 或 .. (上级目录).(即使用绝对路径而非相对路径) #include 的顺序： dir2/foo2.h (这个cpp文件对应的.h文件，放置于优先位置) C 系统文件 C++ 系统文件 其他库的 .h 文件 本项目内 .h 文件 这种优先的顺序排序保证 dir2/foo2.h（.h文件） 遗漏某些必要的库时， 其实现/测试（.cpp文件）的构建会立刻中止。这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是别人。","link":"/2021/10/26/cpp-header-file/"},{"title":"CPP - 函数默认参数","text":"c++规定默认参数必须从函数参数的右边向左边使用，如下： 正确： 12void fun1(int a, int b=10);void fun2(int a, int b=10, int c=20); 错误： 12void fun3(int a=5, int b, int c);void fun4(int a, int b=5, int c); 默认参数不能在声明和定义中同时出现 错误： 12void fun1(int a=10);void fun1(int a=10){......} 正确： 12345void fun2(int a=10);void fun2(int a){......}// orvoid fun2(int a);void fun2(int a=10){......}","link":"/2021/12/11/cpp-default-parameters/"},{"title":"CPP - memset与for循环赋初值比较","text":"写代码的时候思考了一会儿memset初始化快还是for循环初始化快。看了大量的文献资料，结论如下： 如果对于一个数组进行赋初值操作，memset肯定比for循环快 memset赋初值是按字节为单位的，如果要赋一些比较难的值（33，22等），就比较难 接上，因为memset是按字节为单位赋初值，当变量所占字节数越大，速度越慢（int的数组比char慢） 测试代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;chrono&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;numeric&gt;using namespace std;using namespace std::chrono;const int MAXROWNUM = 5e3;const int MAXCOLNUM = 5e3;const int loopTimes = 10;const int loop = 10;int arr[MAXROWNUM][MAXCOLNUM];int arr0[MAXROWNUM][MAXCOLNUM];int arr1[MAXROWNUM][MAXCOLNUM];int arr2[MAXROWNUM][MAXCOLNUM];int arr3[MAXROWNUM][MAXCOLNUM];int arr4[MAXROWNUM][MAXCOLNUM];int arr5[MAXROWNUM][MAXCOLNUM];int arr6[MAXROWNUM][MAXCOLNUM];int arr7[MAXROWNUM][MAXCOLNUM];int arr8[MAXROWNUM][MAXCOLNUM];int arr9[MAXROWNUM][MAXCOLNUM];char str0[MAXROWNUM][MAXCOLNUM];char str1[MAXROWNUM][MAXCOLNUM];char str2[MAXROWNUM][MAXCOLNUM];char str3[MAXROWNUM][MAXCOLNUM];char str4[MAXROWNUM][MAXCOLNUM];char str5[MAXROWNUM][MAXCOLNUM];char str6[MAXROWNUM][MAXCOLNUM];char str7[MAXROWNUM][MAXCOLNUM];char str8[MAXROWNUM][MAXCOLNUM];char str9[MAXROWNUM][MAXCOLNUM];char str[MAXROWNUM][MAXCOLNUM];long long memsetfunc_i(){ auto start = system_clock::now(); int len =MAXROWNUM*MAXCOLNUM*sizeof(int); memset(arr,0, len); auto end = system_clock::now(); auto tt = duration_cast&lt;microseconds&gt;(end - start);// printf(&quot;memset cost %.3f us\\n&quot;,tt.count()); return tt.count();}long long memsettenfunc_i(){ auto start = system_clock::now(); int len =MAXROWNUM*MAXCOLNUM*sizeof(int); for (int i = 0; i &lt; loopTimes; ++i) { memset(arr,0, len); } auto end = system_clock::now(); auto tt = duration_cast&lt;microseconds&gt;(end - start); return tt.count();}long long forfunc_i(){ auto start1 = system_clock::now(); for (int i = 0; i &lt; MAXROWNUM; ++i) { for (int j = 0; j &lt; MAXCOLNUM; ++j) { arr[i][j] = 0; } } auto end1 = system_clock::now(); auto tt1 = duration_cast&lt;microseconds&gt;(end1 - start1); return tt1.count();}long long fortenfunc_i(){ auto start1 = system_clock::now(); for (int k = 0; k &lt; loopTimes; ++k) { for (int i = 0; i &lt; MAXROWNUM; ++i) { for (int j = 0; j &lt; MAXCOLNUM; ++j) { arr[i][j] = 0; } } } auto end1 = system_clock::now(); auto tt1 = duration_cast&lt;microseconds&gt;(end1 - start1); return tt1.count();}long long memsetfunc_c(){ auto start = system_clock::now(); int len =MAXROWNUM*MAXCOLNUM*sizeof(char); memset(str,'0', len); auto end = system_clock::now(); auto tt = duration_cast&lt;microseconds&gt;(end - start);// printf(&quot;memset cost %.3f us\\n&quot;,tt.count()); return tt.count();}long long memsettenfunc_c(){ auto start = system_clock::now(); int len =MAXROWNUM*MAXCOLNUM*sizeof(char); for (int i = 0; i &lt; loopTimes; ++i) { memset(str,'0', len); } auto end = system_clock::now(); auto tt = duration_cast&lt;microseconds&gt;(end - start); return tt.count();}long long forfunc_c(){ auto start1 = system_clock::now(); for (int i = 0; i &lt; MAXROWNUM; ++i) { for (int j = 0; j &lt; MAXCOLNUM; ++j) { str[i][j] = '0'; } } auto end1 = system_clock::now(); auto tt1 = duration_cast&lt;microseconds&gt;(end1 - start1); return tt1.count();}long long fortenfunc_c(){ auto start1 = system_clock::now(); for (int k = 0; k &lt; loopTimes; ++k) { for (int i = 0; i &lt; MAXROWNUM; ++i) { for (int j = 0; j &lt; MAXCOLNUM; ++j) { str[i][j] = '0'; } } } auto end1 = system_clock::now(); auto tt1 = duration_cast&lt;microseconds&gt;(end1 - start1); return tt1.count();}long long memsettendifffunc_c(){ auto start = system_clock::now(); int len =MAXROWNUM*MAXCOLNUM*sizeof(char); memset(str0,'0', len); memset(str1,'0', len); memset(str2,'0', len); memset(str3,'0', len); memset(str4,'0', len); memset(str5,'0', len); memset(str6,'0', len); memset(str7,'0', len); memset(str8,'0', len); memset(str9,'0', len); auto end = system_clock::now(); auto tt = duration_cast&lt;microseconds&gt;(end - start); return tt.count();}long long fortendifffunc_c(){ auto start1 = system_clock::now(); for (int i = 0; i &lt; MAXROWNUM; ++i) { for (int j = 0; j &lt; MAXCOLNUM; ++j) { str0[i][j] = '0'; str1[i][j] = '0'; str2[i][j] = '0'; str3[i][j] = '0'; str4[i][j] = '0'; str5[i][j] = '0'; str6[i][j] = '0'; str7[i][j] = '0'; str8[i][j] = '0'; str9[i][j] = '0'; } } auto end1 = system_clock::now(); auto tt1 = duration_cast&lt;microseconds&gt;(end1 - start1); return tt1.count();}long long memsettendifffunc(){ auto start = system_clock::now(); int len =MAXROWNUM*MAXCOLNUM*sizeof(char); memset(arr0,0, len); memset(arr1,0, len); memset(arr2,0, len); memset(arr3,0, len); memset(arr4,0, len); memset(arr5,0, len); memset(arr6,0, len); memset(arr7,0, len); memset(arr8,0, len); memset(arr9,0, len); auto end = system_clock::now(); auto tt = duration_cast&lt;microseconds&gt;(end - start); return tt.count();}long long fortendifffunc(){ auto start1 = system_clock::now(); for (int i = 0; i &lt; MAXROWNUM; ++i) { for (int j = 0; j &lt; MAXCOLNUM; ++j) { arr0[i][j] = 0; arr1[i][j] = 0; arr2[i][j] = 0; arr3[i][j] = 0; arr4[i][j] = 0; arr5[i][j] = 0; arr6[i][j] = 0; arr7[i][j] = 0; arr8[i][j] = 0; arr9[i][j] = 0; } } auto end1 = system_clock::now(); auto tt1 = duration_cast&lt;microseconds&gt;(end1 - start1); return tt1.count();}vector&lt;long long&gt; ans;double getAns(long long(*p)()){ ans.clear(); for (int i = 0; i &lt; loop; ++i) { ans.push_back((*p)()); } sort(ans.begin(),ans.end()); double cost = accumulate(ans.begin()+2, ans.end()-2, 0.0) / static_cast&lt;double&gt;(ans.size()-6); cost = cost/1000; return cost;}int main() { double m1,m10,f1,f10,cm1,cm10,cf1,cf10,cmd10,cfd10,md10,fd10; m1 = getAns(memsetfunc_i); m10 = getAns(memsettenfunc_i); f1 = getAns(forfunc_i); f10 = getAns(fortenfunc_i); cm1 = getAns(memsetfunc_c); cm10 = getAns(memsettenfunc_c); cf1 = getAns(forfunc_c); cf10 = getAns(fortenfunc_c); cmd10 = getAns(memsettendifffunc_c); cfd10 = getAns(fortendifffunc_c); md10 = getAns(memsettendifffunc); fd10 = getAns(fortendifffunc); printf(&quot;int数组memset一次耗时:%.3fms\\tint数组for循环一次耗时:%.3fms\\n&quot;,m1,f1); printf(&quot;int数组memset十次耗时:%.3fms\\tint数组for循环十次耗时:%.3fms\\n&quot;,m10,f10); printf(&quot;不同的十个int数组memset耗时:%.3fms\\t不同的十个int数组for循环耗时:%.3fms\\n&quot;,md10,fd10); printf(&quot;\\n&quot;); printf(&quot;char数组memset一次耗时:%.3fms\\tchar数组for循环一次耗时:%.3fms\\n&quot;,cm1,cf1); printf(&quot;char数组memset十次耗时:%.3fms\\tchar数组for循环十次耗时:%.3fms\\n&quot;,cm10,cf10); printf(&quot;不同的十个char数组memset耗时:%.3fms\\t不同的十个char数组for循环耗时:%.3fms\\n&quot;,cmd10,cfd10);} 数组都开在的栈区，因此数组不能设的太大。。。运行结果如下：可以佐证上诉的结论。运行结果 memset具体的实现可以看一下下面这个博客，写的很仔细：https://www.cnblogs.com/hoodlum1980/p/3505802.html。 以大佬的总结作为我的总结： 对数组使用初始化列表，或 memset 两者在底层上可能等效。（msvc编译器将前者处理为后者）。对数组用循环初始化，和使用 memset 初始化相比，很有可能等效。即使不等效（memset 调用了 SSE2 扩展），也不可能达到成为一个优化命题和关注点。如果一定要说有点区别，那就是如果是对一个整数数组用初始化列表或者循环初始化，那么编译器不需要考虑地址对齐的问题（因为编译器必然把数组分配到对齐的地址），而 memset 则需要考虑传入的地址是否已对齐到某个基本粒度，并对此未对齐部分作处理。当对一个随机数据组成的内存块进行清零操作，memset 看起来仿佛是唯一正确的可选方式（如果所在平台无此函数，则可以用手写循环替代）。声明数组时提供初始化列表，声明后再调用 memset 或者使用循环初始化（显然，在能够使用 memset 时，循环写法在高级语言层面不如前者简洁），无论是代码规范还是性能层面，这些写法都不存在值得强调的绝对优劣关系。","link":"/2023/03/05/cpp-memset/"},{"title":"CPP面向对象 - 概述","text":"C vs C++C是面向过程的，C++是面向对象的，面向对象即是讲一些数据和函数绑定在一起。 对象(classes)的两种经典分类 Class without pointer members complex 拷贝都得一一复制（因为数据成员都包含在对象中了） Class with pointer members string 拷贝分深浅，因此有移动语义（C++11支持） C++程序代码的基本形式一般而言分 .cpp 或 .h 两种： .h ：写一些类的声明 .cpp ：类的实现 也不一定是 .cpp 或 .h 文件，也有可能是 .hpp 等文件。","link":"/2021/10/26/cpp-oop-intro/"},{"title":"CPP - 操作符重载！看这篇就够了！","text":"实现一个操作符重载的方式通常有两种情况： 将操作符重载实现为类的成员函数。 操作符重载实现为非类的成员函数（即全局函数）。 将操作符重载实现为类的成员函数 在类体中声明（定义）需要重载的操作符，声明方式跟普通的成员函数一样，只不过操作符重载函数的名字是“关键字operator +以及紧跟其后的一个C++预定义的操作符”。参数则需要传入除自己以外的别的参数（比如==需要两个参数，即自身和另一个对象，因此传入另一个对象即可，自身就是this）。 形式即如下(Student为自定义类)： 1bool operator==(const Student &amp;student){} 此处要注意输入输出操作（&lt;&lt; and &gt;&gt;）的重载方式有所不同，需要使用友元函数，形式如下： 1friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Student &amp;student) 操作符重载实现为非类的成员函数 对于全局重载操作符，代表左操作数的参数必须被显式指定。 形式如下： 1bool operator&gt;(Student &amp;student, Student &amp;student1) 可以根据以下因素，确定把一个操作符重载为类的成员函数还是全局函数： 如果一个重载操作符是类成员，那么只有当与它一起使用的左操作数是该类的对象时，该操作符才会被调用；而如果该操作符的左操作数确定为其他的类型，则操作符必须被重载为全局函数； C++要求’=’、’[]’、’()’、’-&gt;’操作符必须被定义为类的成员操作符，把这些操作符通过全局函数进行重载时会出现编译错误 如果有一个操作数是类类型（如string类），那么对于对称操作符（比如==操作符），最好通过全局函数的方式进行重载。 实现操作符重载时，需要注意有如下限制： 重载后操作符的操作数至少有一个是用户定义类型； 不能违反原来操作数的语法规则； 不能创建新的操作符； 不能重载的操作符包括（以空格分隔）：sizeof . .* :: ?: RTTI类型运算符 =、()、[]、以及 -&gt;操作符只能被类的成员函数重载 下面给出示例代码，其中使用全局函数的为重载&gt;。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;using namespace std;class Student {public: int sno; string name; Student(int s = 0, string n = &quot;&quot;) : sno(s), name(n) {} bool operator==(const Student &amp;student) { if (sno == student.sno) return true; return false; } // 将操作符重载实现为类的成员函数 bool operator&lt;(const Student &amp;student) { if (sno &lt; student.sno) return true; return false; } // ++student 前缀形式 Student &amp;operator++() { sno++; return *this; } // student++ 后缀形式 Student operator++(int) { Student student(sno, name); sno++; return student; } friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Student &amp;student) { os &lt;&lt; student.sno &lt;&lt; &quot; &quot; &lt;&lt; student.name; return os; } friend istream &amp;operator&gt;&gt;(istream &amp;is, Student &amp;student) { cout &lt;&lt; &quot;input sno:&quot;; is &gt;&gt; student.sno; cout &lt;&lt; &quot;input name:&quot;; is &gt;&gt; student.name; return is; }};// 操作符重载实现为非类的成员函数bool operator&gt;(Student &amp;student, Student &amp;student1) { if (student.sno &gt; student1.sno) return true; return false;}int main() { Student student_a; cin &gt;&gt; student_a; cout &lt;&lt; &quot;your input: &quot; &lt;&lt; student_a &lt;&lt; endl; Student student_b = student_a++; cout &lt;&lt; &quot;student_a: &quot; &lt;&lt; student_a &lt;&lt; endl; cout &lt;&lt; &quot;student_b: &quot; &lt;&lt; student_b &lt;&lt; endl; cout &lt;&lt; &quot;student_a &lt; student_b: &quot; &lt;&lt; (student_a &lt; student_b) &lt;&lt; endl; cout &lt;&lt; &quot;student_a &gt; student_b: &quot; &lt;&lt; (student_a &gt; student_b) &lt;&lt; endl; cout &lt;&lt; &quot;student_a == student_b: &quot; &lt;&lt; (student_a == student_b) &lt;&lt; endl; cout &lt;&lt; endl; Student student_c = ++student_a; cout &lt;&lt; &quot;student_a: &quot; &lt;&lt; student_a &lt;&lt; endl; cout &lt;&lt; &quot;student_c: &quot; &lt;&lt; student_c &lt;&lt; endl; cout &lt;&lt; &quot;student_a &lt; student_c: &quot; &lt;&lt; (student_a &lt; student_c) &lt;&lt; endl; cout &lt;&lt; &quot;student_a &gt; student_c: &quot; &lt;&lt; (student_a &gt; student_c) &lt;&lt; endl; cout &lt;&lt; &quot;student_a == student_c: &quot; &lt;&lt; (student_a == student_c) &lt;&lt; endl;} 结果如下：","link":"/2023/03/05/cpp-operator-override/"},{"title":"CPP - 引用&amp;指针","text":"引用 引用(reference)为对象起了另外一个名字，引用类型引用(refers to)另外一种类型。通过将声明符写成 &amp;d 的形式来定义引用类型型,其中 d 是声明的变量名。在初始化变量时，会出现初始值拷贝现象，定义引用则将引用与初始值对象绑定在一起。 引用必须初始化（类型必须严格匹配） 引用并不是对象，而是给一个已经存在的对象起另一个名字（这个对象必须存在，不可为字面值[10,”10”…]） 1234int &amp;refVal = 0; //errordouble dval = 3.14;int &amp;refVal2 = dval; //error 指针 指针(pointer)是’”指向(point to)“另外一种类型型的复合类型。定义指针类型的方法将声明符写成d的形式,其中d是变量名。 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。 指针无须在定义时赋初值。 使用取地址符（ &amp; ）可以取得存放某个对象的地址。 类型必须严格匹配 12double dval = 3.14;int *p = &amp;dval; 指针的值(即地址)应属下列4种状态之一: 指向一个对象。 指向紧邻对象所占空间的下一个位置。 空指针,意味着指针没有指向任何对象。 无效指针,也就是上述情况之外的其他值。 利用指针访问对象 如果指针指向了一个对象，则可以用解引用符（*）来访问该对象。 12345int ival = 42;int *p = &amp;ival; //声明指针*p = 0; //改变对象内容cout&lt;&lt; *p; //输出0 解引用符只适用于确指向了某个对象的有效指针 空指针 空指针不指向任何对象，在试图使用一个指针之前可以检查其是否为空。 123int *p1 = nullptr; //C++11int *p2 = 0;int *p3 = NULL; //cstdlib void* 指针 void *是一种特殊的指针类型，可用于存放任意对象的地址。存放的也仅仅就是一个地址。 12double obj = 3.14;void *pv = &amp;obj; 不能直接操作相关void *所指向的对象。 指向指针的指针 通过*的个数区分指针的级别。 123int ival = 1024;int *pi = &amp;ival; //指向intint **ppi = &amp;pi; //指向一个int指针 指向指针的引用 引用不是对象，指针是对象，因此不存在指向引用的指针，只存在指向指针的引用。 123456int i = 42;int *p;int *&amp;r = p; //对int指针的引用r = &amp;i; //r是一个int指针，即r指向i*r = 0; //解引用r得到i 如何理解r的类型是什么？ 从右往左阅读，越靠近r的对r有最直接影响（*&amp;r -&gt; &amp; -&gt; r为一个指针）","link":"/2023/03/05/cpp-reference-pointer/"},{"title":"CPP - 栈展开(stack unwinding)","text":"栈展开（stack unwinding）的定义抛出异常时，将暂停当前函数的执行，开始查找匹配的 catch 子句。首先检查 throw 本身是否在 try 块内部，如果是，检查与该 try 相关的 catch 子句，看是否可以处理该异常。如果不能处理，就退出当前函数，并且释放当前函数的内存并销毁局部对象，继续到上层的调用函数中查找，直到找到一个可以处理该异常的 catch 。这个过程称为栈展开（stack unwinding）。当处理该异常的 catch 结束之后，紧接着该 catch 之后的点继续执行。 为局部对象调用析构函数 在栈展开的过程中，会释放局部对象所占用的内存并运行类类型局部对象的析构函数。但需要注意的是，如果一个块通过 new 动态分配内存，并且在释放该资源之前发生异常，该块因异常而退出，那么在栈展开期间不会释放该资源，编译器不会删除该指针，这样就会造成内存泄露。 析构函数应该从不抛出异常 在为某个异常进行栈展开的时候，析构函数如果又抛出自己的未经处理的另一个异常，将会导致调用标准库 terminate 函数。通常 terminate 函数将调用 abort 函数，导致程序的非正常退出。所以析构函数应该从不抛出异常。 异常与构造函数 如果在构造函数对象时发生异常，此时该对象可能只是被部分构造，要保证能够适当的撤销这些已构造的成员。 未捕获的异常将会终止程序 不能不处理异常。如果找不到匹配的catch，程序就会调用库函数terminate。 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;class MyException{};class Dummy {public: // 构造函数 Dummy(string s) : MyName(s) { PrintMsg(&quot;Created Dummy:&quot;); } // 拷贝构造 Dummy(const Dummy&amp; other) : MyName(other.MyName){ PrintMsg(&quot;Copy created Dummy:&quot;); } // 析构函数 ~Dummy(){ PrintMsg(&quot;Destroyed Dummy:&quot;); } void PrintMsg(string s) { cout &lt;&lt; s &lt;&lt; MyName &lt;&lt; endl; } string MyName; int level;};void C(Dummy d, int i) { cout &lt;&lt; &quot;Entering Function C&quot; &lt;&lt; endl; d.MyName = &quot; C&quot;; throw MyException(); cout &lt;&lt; &quot;Exiting Function C&quot; &lt;&lt; endl;}void B(Dummy d, int i) { cout &lt;&lt; &quot;Entering Function B&quot; &lt;&lt; endl; d.MyName = &quot; B&quot;; C(d, i + 1); cout &lt;&lt; &quot;Exiting Function B&quot; &lt;&lt; endl;}void A(Dummy d, int i) { cout &lt;&lt; &quot;Entering Function A&quot; &lt;&lt; endl; d.MyName = &quot; A&quot; ; // Dummy* pd = new Dummy(&quot;new Dummy&quot;); //Not exception safe!!! B(d, i + 1); // delete pd; cout &lt;&lt; &quot;Exiting FunctionA&quot; &lt;&lt; endl;}int main() { cout &lt;&lt; &quot;Entering main&quot; &lt;&lt; endl; try { Dummy d(&quot; M&quot;); A(d,1); } catch (MyException&amp; e) { cout &lt;&lt; &quot;Caught an exception of type: &quot; &lt;&lt; typeid(e).name() &lt;&lt; endl; } cout &lt;&lt; &quot;Exiting main.&quot; &lt;&lt; endl; return 0;}/**/ 进行编译，运行，可得到如下结果： 1234567891011121314151617$ g++ stack_unwinding.cpp -o stack_test -std=c++11$ ./stack_test Entering mainCreated Dummy: MCopy created Dummy: MEntering Function ACopy created Dummy: AEntering Function BCopy created Dummy: BEntering Function CDestroyed Dummy: CDestroyed Dummy: BDestroyed Dummy: ADestroyed Dummy: MCaught an exception of type: 11MyExceptionExiting main. 程序运行时对应栈的内容如下图所示： 程序执行将从 C 中的 throw 语句跳转到 main 中的 catch 语句，并在此过程中展开每个函数。 根据创建 Dummy 对象的顺序，在它们超出范围时将其销毁。 除了包含 catch 语句的 main 之外，其他函数均未完成。 函数 A 绝不会从其对 B() 的调用返回，并且 B 绝不会从其对 C() 的调用返回。 reference[1] microsoft C++文档 [2] 抛出异常与栈展开（stack unwinding）","link":"/2023/03/05/cpp-stack-unwinding/"},{"title":"CPP - 虚函数指针和虚函数表","text":"虚函数指针和虚函数表虚函数表的定义多态是由虚函数实现的，而虚函数主要是通过虚函数表（V-Table）来实现的。 如果一个类中包含虚函数（virtual修饰的函数），那么这个类就会包含一张虚函数表(vftbl)，虚函数表存储的每一项是一个虚函数的地址。在一个对象的内存布局中，指向这张虚函数表的指针（vfptr）位于最前端。如下图： 一般继承（无虚函数覆盖）对于如下UML的类：在普通继承情况，派生类没有重写基类的虚函数： 体现在代码上为： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;class Base{public: virtual void f() { cout &lt;&lt; &quot;Base:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base:h()&quot; &lt;&lt; endl; }};class Derive : public Base{public: virtual void f1() { cout &lt;&lt; &quot;Derive:f1()&quot; &lt;&lt; endl; } virtual void g1() { cout &lt;&lt; &quot;Derive:g1()&quot; &lt;&lt; endl; } virtual void h1() { cout &lt;&lt; &quot;Derive:h1()&quot; &lt;&lt; endl; }};int main() { Base base; Derive derive;} 使用lldb查看虚函数指针和虚函数表内容： 根据结果，可以得知其虚函数表如下图： 一般继承（有虚函数覆盖）对于如下UML的类：在普通继承情况，派生类重写了基类的虚函数( f() )： 代码为： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;class Base{public: virtual void f() { cout &lt;&lt; &quot;Base:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base:h()&quot; &lt;&lt; endl; }};class Derive : public Base{public: virtual void f() { cout &lt;&lt; &quot;Derive:f()&quot; &lt;&lt; endl; } virtual void g1() { cout &lt;&lt; &quot;Derive:g1()&quot; &lt;&lt; endl; } virtual void h1() { cout &lt;&lt; &quot;Derive:h1()&quot; &lt;&lt; endl; }};int main() { Base base; Derive derive;} 结果为： 绘制成图，为： 多重继承（无虚函数覆盖）对于如下UML的类：在多重继承情况，派生类没有重写了基类的虚函数： 代码为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;using namespace std;class Base1{public: virtual void f() { cout &lt;&lt; &quot;Base1:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base1:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base1:h()&quot; &lt;&lt; endl; }};class Base2{public: virtual void f() { cout &lt;&lt; &quot;Base2:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base2:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base2:h()&quot; &lt;&lt; endl; }};class Base3{public: virtual void f() { cout &lt;&lt; &quot;Base3:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base3:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base3:h()&quot; &lt;&lt; endl; }};class Derive : public Base1, public Base2, public Base3{public: virtual void f1() { cout &lt;&lt; &quot;Derive:f1()&quot; &lt;&lt; endl; } virtual void g1() { cout &lt;&lt; &quot;Derive:g1()&quot; &lt;&lt; endl; }};int main() { Derive derive;} 结果为： 绘制成图，为： 多重继承（有虚函数覆盖）对于如下UML的类：在多重继承情况，派生类没有重写了基类的虚函数： 代码为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;using namespace std;class Base1{public: virtual void f() { cout &lt;&lt; &quot;Base1:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base1:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base1:h()&quot; &lt;&lt; endl; }};class Base2{public: virtual void f() { cout &lt;&lt; &quot;Base2:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base2:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base2:h()&quot; &lt;&lt; endl; }};class Base3{public: virtual void f() { cout &lt;&lt; &quot;Base3:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base3:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base3:h()&quot; &lt;&lt; endl; }};class Derive : public Base1, public Base2, public Base3{public: virtual void f() { cout &lt;&lt; &quot;Derive:f()&quot; &lt;&lt; endl; } virtual void g1() { cout &lt;&lt; &quot;Derive:g1()&quot; &lt;&lt; endl; }};int main() { Derive derive;} 结果为： 绘制成图，为：","link":"/2023/03/05/cpp-virtual-function/"},{"title":"CPP - 处理类型","text":"类型别名类型别名是一个名字，是某种类型的同义词。使用类型别名可以使复杂的类型名字变得简单明了。 12typedef double wages;typedef wages base, *p; //base=double,p=double* C++11中支持新方法： 1using wages = double; auto类型说明符C++11标准，编译器通过初始值推算变量的类型。（auto定义的变量必须具有初始值） 12auto i = 0, *p = &amp;i; //correctauto sz = 0, pi = 3.14; //error decltype类型指示符希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。 1decltype(f()) sum = x; //sum的类型就是函数f的返回类型","link":"/2023/03/05/cpp-type/"},{"title":"Mac删除讨厌的.DS_Store文件夹","text":"先设置好path，然后删除，直接写在find后也行： 12345678deletepath=/# 制定当前deletepath=$(pwd)sudo find $deletepath -name &quot;.DS_Store&quot; -depth -exec rm {} \\;zip -d file.zip __MACOSX/\\* 可以加.gitignore文件以忽略一些无关文件： 12345.gitignore*.[oa]git.idea/.DS_Store/cmake-build-debug/","link":"/2023/03/06/debug-delete-DS-Store-in-Mac/"},{"title":"git push问题：Connection reset by peer","text":"在git push时遇到如下问题： kex_exchange_identification: read: Connection reset by peerfatal: Could not read from remote repository. Please make sure you have the correct access rightsand the repository exists. 再尝试了更改rsa密钥等一系列行为后不行，看到stackoverflow上的方法，尝试下： 1git init 成功了。 原文： I had a similar issue recently, I’m not sure whether its exactly the same as I got the connected user by following command. ssh -T git@gitlab.com But when I try to push the code to remote repository I got same error. 12345kex_exchange_identification: read: Connection reset by peerfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. After trying few solutions from the internet without success, I just tried git init and it worked for me. I hope this works only if the connection user has bound correctly. Try it out Good Luck.. :)","link":"/2023/03/06/debug-git-push-error/"},{"title":"yum安装报错No package xxx available","text":"Cent OS7使用yum安装软件出现 No package xxx available. [chenxinlong@localhost Documents]$ sudo yum install tldr[sudo] password for chenxinlong:Loaded plugins: fastestmirror, langpacksLoading mirror speeds from cached hostfile base: mirrors.cn99.com centos-sclo-rh: mirrors.nju.edu.cn centos-sclo-sclo: mirrors.nju.edu.cn extras: mirrors.nju.edu.cn updates: mirrors.nju.edu.cnNo package tldr available.Error: Nothing to do 使用 1sudo yum install epel-release 使用yum搜索某些rpm包，找不到包是因为CentOS是RedHat企业版编译过来的，去掉了所有关于版权问题的东西。 安装EPEL后可以很好的解决这个问题。EPEL(Extra Packages for Enterprise Linux )即企业版Linux的扩展包，提供了很多可共Centos使用的组件，安装完这个以后基本常用的rpm都可以找到[1]。 [1] yum安装时提示No package xxx available的解决方案","link":"/2023/03/06/debug-yum-install-error/"},{"title":"Effective C++ 第一章 让自己习惯 C++","text":"第一章 让自己习惯 C++（Accustoming Youself to C++）条款1：视C++为一个语言联邦C++是个多重范型编程语言，同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式。 视C++为一个语言联邦，包括以下四个部分： C：面向过程的部分 Object-Oriented C++：面向对象的部分，包括封装、继承、多态以及虚函数（动态绑定）等。 Template C++：泛型编程部分 STL： 融合泛型编程和OOP编程思想的C++标准模板库，包括容器、迭代器、算法以及函数对象等。 请记住： C++高效编程守则视状况而变化，取决于使用的是这四个部分中的哪一部分。 条款2：尽量以const，enum，inline代替#define宁可以编译器代替预处理器。 #define即宏定义在预处理阶段进行处理，不进入记号表（symbol table）。 123int a = 5, b = 0;CALL_MAX(++a, b); //a被累加2次CALL_MAX(++a, b + 10); //a被累加1次 这是不可预料的行为，因此使用内联函数来代替宏定义函数。 请记住： 对于单纯常量，最好使用const对象或enum替换#defines。 对于形似函数的宏，最好改用inline函数替换#defines。 条款3：尽可能使用constconst关键字告诉编译器某值应该保持不变，即为只读的。 const成员函数两个成员函数如果只是常量性不同，可以被重载。 const成员函数代表this指针的类型为：const className &amp;。 使用const成员函数来处理const对象。 在const和non-cons成员函数中避免重复利用non-const版本调用const版本，再加上转型const_cast、static_cast,例如： 123456const char&amp; operator[](int pos) const;//const版本char&amp; operator[](int pos) { //non-const版本 return const_cast&lt;char&amp;&gt; //返回值转型，移除const (static_cast&lt;const className&amp;&gt;(*this)[pos]);//*this转型,增加const} 但反过来使用const版本调用non-const版本则是一种错误行为。 请记住： 将某些东西声明为const可以帮助编译器侦测除错误；const可以被施加在任何作用域内的对象、函数参数、函数返回类型、成员函数本身。 编译器强制实施bitwise constness，但是你编写程序时应该使用“概念上的常量性”。 当const和non-const成员函数有着实质等价的实现时，使用non-const版本来调用const版本可以避免代码重复。 条款4：确定对象使用前已被初始化永远在对象使用之前将其初始化。 对于内置类型，手动初始化。 对于非内置类型，使用构造函数进行初始化。 赋值和初始化有区别： 12345678910// 赋值，而非初始化ABEntry(const string&amp; name, const string&amp; address, int num) { _name = name; _address = address; _num = num; }// 初始化，发生在进入构造函数本体之前// 即成员初值列(member initialization list)ABEntry::ABEntry(const string&amp; name, const string&amp; address, int num) : _name(name), _address(address), _num(num) { } C++有着固定的初始化顺序：按照声明顺序进行初始化，且基类先于派生类初始化 static对象：其寿命从被构造出来直到程序结束为止。 local static object(局部静态对象)：函数内的static对象。 non-local static object(非局部静态对象)：非函数内的static对象，不同编译单元之间初始化次序不确定 因此，要解决non-local static object初始化次序问题，就要将non-local static object转换为local static object（使用单例模式，即封装一层函数） 123456789101112class Singleton{public: static Singleton&amp; getInstance() { static Singleton s; return s; }private: Singleton() {} Singleton(const Singleton&amp;); void operator=(const Singleton&amp;);}; 请记住: 为内置类型进行手工初始化，C++不保证初始化它们。 构造函数最好使用成员初值列，不要在构造函数中使用赋值操作，初值列中的成员变量的顺序应该和声明顺序一致。 为免除“跨编译单元之初始化次序”问题，使用返回local static对象引用的函数来代替non-local static对象。 reference[1] Effective C++ · Scott Meyers","link":"/2021/12/12/effective-cpp-1/"},{"title":"Effective C++ 第二章 构造&#x2F;析构&#x2F;赋值运算","text":"第一章 让自己习惯 C++（Accustoming Youself to C++）条款1：视C++为一个语言联邦C++是个多重范型编程语言，同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式。 视C++为一个语言联邦，包括以下四个部分： C：面向过程的部分 Object-Oriented C++：面向对象的部分，包括封装、继承、多态以及虚函数（动态绑定）等。 Template C++：泛型编程部分 STL： 融合泛型编程和OOP编程思想的C++标准模板库，包括容器、迭代器、算法以及函数对象等。 请记住： C++高效编程守则视状况而变化，取决于使用的是这四个部分中的哪一部分。 条款2：尽量以const，enum，inline代替#define宁可以编译器代替预处理器。 #define即宏定义在预处理阶段进行处理，不进入记号表（symbol table）。 123int a = 5, b = 0;CALL_MAX(++a, b); //a被累加2次CALL_MAX(++a, b + 10); //a被累加1次 这是不可预料的行为，因此使用内联函数来代替宏定义函数。 请记住： 对于单纯常量，最好使用const对象或enum替换#defines。 对于形似函数的宏，最好改用inline函数替换#defines。 条款3：尽可能使用constconst关键字告诉编译器某值应该保持不变，即为只读的。 const成员函数两个成员函数如果只是常量性不同，可以被重载。 const成员函数代表this指针的类型为：const className &amp;。 使用const成员函数来处理const对象。 在const和non-cons成员函数中避免重复利用non-const版本调用const版本，再加上转型const_cast、static_cast,例如： 123456const char&amp; operator[](int pos) const;//const版本char&amp; operator[](int pos) { //non-const版本 return const_cast&lt;char&amp;&gt; //返回值转型，移除const (static_cast&lt;const className&amp;&gt;(*this)[pos]);//*this转型,增加const} 但反过来使用const版本调用non-const版本则是一种错误行为。 请记住： 将某些东西声明为const可以帮助编译器侦测除错误；const可以被施加在任何作用域内的对象、函数参数、函数返回类型、成员函数本身。 编译器强制实施bitwise constness，但是你编写程序时应该使用“概念上的常量性”。 当const和non-const成员函数有着实质等价的实现时，使用non-const版本来调用const版本可以避免代码重复。 条款4：确定对象使用前已被初始化永远在对象使用之前将其初始化。 对于内置类型，手动初始化。 对于非内置类型，使用构造函数进行初始化。 赋值和初始化有区别： 12345678910// 赋值，而非初始化ABEntry(const string&amp; name, const string&amp; address, int num) { _name = name; _address = address; _num = num; }// 初始化，发生在进入构造函数本体之前// 即成员初值列(member initialization list)ABEntry::ABEntry(const string&amp; name, const string&amp; address, int num) : _name(name), _address(address), _num(num) { } C++有着固定的初始化顺序：按照声明顺序进行初始化，且基类先于派生类初始化 static对象：其寿命从被构造出来直到程序结束为止。 local static object(局部静态对象)：函数内的static对象。 non-local static object(非局部静态对象)：非函数内的static对象，不同编译单元之间初始化次序不确定 因此，要解决non-local static object初始化次序问题，就要将non-local static object转换为local static object（使用单例模式，即封装一层函数） 123456789101112class Singleton{public: static Singleton&amp; getInstance() { static Singleton s; return s; }private: Singleton() {} Singleton(const Singleton&amp;); void operator=(const Singleton&amp;);}; 请记住: 为内置类型进行手工初始化，C++不保证初始化它们。 构造函数最好使用成员初值列，不要在构造函数中使用赋值操作，初值列中的成员变量的顺序应该和声明顺序一致。 为免除“跨编译单元之初始化次序”问题，使用返回local static对象引用的函数来代替non-local static对象。 reference[1] Effective C++ · Scott Meyers","link":"/2021/12/19/effective-cpp-2/"},{"title":"QT - Clion配置qt creator和uic","text":"配置qt creator（用于画ui，拖空间） Program：自己安装qt的目录，在tools中找到相关的二进制可执行文件 Arguments：$FileName$ Working directory: $FileDir$ 配置uic（自动生成C++代码） Program：自己安装qt的目录，在版本号中找到相关的二进制可执行文件 Arguments：$FileName$ -o ui_$FileNameWithoutExtension$.h Working directory: $FileDir$ 注意事项：注意 Working directory 不能是 $ProjectFileDir$， 否则在二级目录使用工具会打不开文件（路径错误）。","link":"/2023/03/06/frontend-qt-creator-uic/"},{"title":"QT - 多个窗口之间传递参数（低耦合实现）","text":"实现目标有一MainWindow（主窗口）、有一Dialog（新建的窗口），之间互相传递一个QList对象。 实现方案主窗口给新建的窗口传递参数主窗口会持有一个新建窗口的指针，如下： 1Waypoints_Dialog *waypoints_dlg = new Waypoints_Dialog; 因此新建窗口开一个小窗让主窗口设置即可（即使用一个public方法） 新建的窗口： 123456void Waypoints_Dialog::set_wayPointList(QList&lt;wayPoint&gt;&amp; ls) { this-&gt;wayPointList = ls; update_table(); update_waypoints_spin();} 主窗口： 123456789void MainWindow::on_menuWaypoints_triggered() { this-&gt;waypoints_dlg-&gt;set_wayPointList(wayPointList); this-&gt;waypoints_dlg-&gt;exec();}void MainWindow::set_wayPointList(QList&lt;wayPoint&gt;&amp; ls) { this-&gt;wayPointList = ls;} 新建的窗口给主窗口传递参数新建的窗口是没有主窗口的指针的，因此上面的方案不可行。 考虑使用信号与槽的方案实现（其实就是一个观察者模式，因为主窗口含有新建串口的指针，因此主窗口可以设置为观察者（槽），新建窗口为被观察者（信号））： 被观察者(新窗口)： 信号声明（不需要实现，发送即可）： 12signals: void send_wayPointList(QList&lt;wayPoint&gt;&amp; ls); 发送信号： 1234void Waypoints_Dialog::on_send_btn_clicked() { emit send_wayPointList(this-&gt;wayPointList); QDialog::accept();} 观察者（主窗口）： 声明槽： 12private slots: void set_wayPointList(QList&lt;wayPoint&gt;&amp; ls); 定义之： 123void MainWindow::set_wayPointList(QList&lt;wayPoint&gt;&amp; ls) { this-&gt;wayPointList = ls;}","link":"/2023/03/06/frontend-qt-pass-parameters-in-windows/"},{"title":"树莓派 - 树莓派开机自启动","text":"树莓派系统下简单的设置开机自启动程序： 在要运行的程序的同级目录下新建一个脚本start.sh 1sudo nano start.sh 脚本如下： 123#!/bin/shcd /home/pi/Desktop/timersudo ./timer 修改脚本文件权限 1sudo chmod 777 /hone/pi/Desktop/timer/start.sh 将脚本文件添加进rc.local中 1sudo nano /etc/rc.local ​ 加入如下内容： 1/home/pi/Desktop/timer/start.sh start 重启树莓派 1reboot 远程登录树莓派，可以发现已经自动启动我所写的定时程序：","link":"/2023/03/06/hardware-Raspberry-Pi-self-start/"},{"title":"QT - qmake - command not found","text":"安装了QT后，执行 qmake 后发现 command not found。 解决办法： 执行 updatedb 执行 locate bin/qmake， 可见如下结果： 执行 cd /usr/local/bin 执行 ln -s /opt/QT_5.9.5/5.9.5/gcc_64/bin/qmake /usr/local/bin 执行 qmake -v ，可以发现可以使用 qmake 指令了。","link":"/2023/03/06/frontend-qt-qmake-error/"},{"title":"树莓派 - 开启ssh服务并固定ip","text":"开启ssh服务 进入菜单(Menu) -&gt; 首选项(Preferences) -&gt; Raspberry Pi Configuration -&gt; Interfaces。 将ssh开关打开 通过ssh命令登陆远端机器 12// @前为用户名，@后为远端机器地址（可以是url），IP可通过ifconfig查看，或登陆路由器ssh pi@192.168.1.100 固定树莓派IP因为公网IP不够，我们所用的网络IP都是DHCP服务器租借的IP地址（涉及网络中的DHCP和NAT协议），因此树莓派的IP地址其实并不固定。为了方便SSH登陆，因此固定树莓派的IP地址。 远端登陆树莓派 / 树莓派打开终端 通过 ifconfig 命令查看树莓派的IP地址 进入编辑界面 1sudo nano /etc/dhcpcd.conf 修改配置文件（需要对着 ifconfig 的输出wlan改，重点是改ip_address和routers） 保存、退出 重启树莓派 1sudo reboot 重启后即可通过固定的IP访问树莓派了。 需要注意的是：若固定的IP和DHCP租借出去的IP冲突，则有不能上网的可能，因此可以改一个DHCP地址池中稍微靠后的IP。","link":"/2023/03/06/hardware-Raspberry-Pi-ssh/"},{"title":"UNIX环境高级编程 - 文件I&#x2F;O - 打开&#x2F;创建&#x2F;关闭文件","text":"函数open和openat12345#include &lt;fcntl.h&gt;int open(const char* path,int oflag,.../*mode_t mode*/);int openat(int fd,const char*path,int oflag,.../*mode_t mode */); 可以使用如下命令查看参数： 1man 2 open 参数： path:要打开或者创建文件的名字 oflag：用于指定函数的操作行为： 必选的标志：（标志/常量定义于 fcntl.h 中） O_RDONLY常量：文件只读打开 O_WRONLY常量：文件只写打开 O_RDWR常量：文件读、写打开 O_EXEC常量：只执行打开 O_SEARCH常量：只搜索打开（应用于目录）。本文涉及的操作系统都没有支持该常 下面的常量是可选的（进行或运行）(不一定所有的操作系统支持，不同的系统得看实际情况)： O_APPEND：每次写时都追加到文件的尾端 O_CLOEXEC：将FD_CLOEXEC常量设置为文件描述符标志 O_CREAT：若此文件不存在则创建它。在使用此选项时，需要同时说明参数mode（指定该文件的访问权限） O_DIRECTORY：若path引用的不是目录，则出错 O_EXCL：若同时指定了O_CREAT时，且文件已存在则出错。根据此可以测试一个文件是否存在。若不存在则创建此文件。这使得测试和创建两者成为一个原子操作 O_NOCTTY：若path引用的是终端设备，则不将该设备分配作为此进程的控制终端 O_NOFOLLOW：若path引用的是一个符号链接，则出错 O_NONBLOCK：如果path引用的是一个FIFO、一个块特殊文件或者一个字符特殊文件，则文件本次打开操作和后续的 I/O 操作设为非阻塞模式。 O_SYNC：每次 write 等待物理 I/O 完成，包括由 write 操作引起的文件属性更新所需的 I/O O_TRUNC： 如果此文件存在，且为O_WRONLY或者O_RDWR成功打开，则将其长度截断为0 O_RSYNC：使每一个read操作等待，直到所有对文件同一部分挂起的写操作都完成。 O_DSYNC：每次 write 等待物理 I/O 完成，但不包括由 write 操作引起的文件属性更新所需的 I/O mode：文件访问权限。文件访问权限常量在 &lt;sys/stat.h&gt; 中定义，有以下九个： S_IRUSR：用户读 S_IWUSR：用户写 S_IXUSR：用户执行 S_IRGRP：组读 S_IWGRP：组写 S_IXGRP：组执行 S_IROTH：其他读 S_IWOTH：其他写 S_IXOTH：其他执行 返回值： 成功：返回文件描述符。 失败：返回 -1 由 open/openat 返回的文件描述符一定是最小的未使用的描述符数字。 对于openat函数，被打开的文件名由fd和path共同决定： 如果path指定的是绝对路径，此时fd被忽略。openat等价于open 如果path指定的是相对路径名，则fd是一个打开目录的文件描述符。被打开的文件的绝对路径由该fd描述符对应的目录加上path组合而成 如果path是一个相对路径名，而fd是特殊值AT_FDCWD，则path相对于当前工作目录。被打开文件在当前工作目录中查找。 fd 是 AT_FDCWD 说明是当前目录 openat 函数是 POSIX.1中新增的函数，希望解決两个问题。 让线程可以使用相对路径名打开目录中的文件，而不再只能打开当前工作目录。 同一进程中的所有线程共享相同的当前工作目录，因此很难让同一进程的多个不同线程在同时间工作在不同的目录中。 可以避免 time-of-check-to-time-of-use (TOCTTOU）错误。 TOCTTOU 错误的基本思想是：如果有两个基于文件的函数调用，其中第二个调用依赖于第一个调用的结果，那么程序是脆弱的。 因为两个调用并不是原子操作，在两个函数调用之间文件可能改变了，这样也就造成了第一个调用的结果就不再有效，使得程序最终的结果是错误的。 函数creat也可以使用creat 创建一个新文件。 123#include &lt;fcntl.h&gt;int creat(const char*path,mode_t mode); 此函数等效于： open(path, O_WRONLY | O_CREAT | O_TRUNC, mode) 参数： path:要创建文件的名字 mode：指定该文件的访问权限文件访问权限常量在 &lt;sys/stat.h&gt; 中定义，有下列九个： S_IRUSR：用户读 S_IWUSR：用户写 S_IXUSR：用户执行 S_IRGRP：组读 S_IWGRP：组写 S_IXGRP：组执行 S_IROTH：其他读 S_IWOTH：其他写 S_IXOTH：其他执行 返回值： 成功： 返回O_WRONLY打开的文件描述符 失败： 返回 -1 creat的不足： 它以只写方式打开。若要先写再读，则需调用creat、close，然后再调用open进行读取。 若文件已存在则将文件截断为0。 现在可以使用新的open: open(path, O_RDWR | O_CREAT | O_TRUNC, mode) 为什么会有open了还需要creat？ 历史原因，老版本的open没有O_CREAT标志。 函数close可以使用close 关闭一个打开文件。 123#include &lt;unistd.h&gt;int close(int fd); 参数： fd：待关闭文件的文件描述符 返回值： 成功：返回 0 失败：返回 -1 注意： 进程关闭一个文件会释放它加在该文件上的所有记录锁。 当一个进程终止时，内核会自动关闭它所有的打开的文件。","link":"/2023/03/06/linux-file-IO-open-close/"},{"title":"UNIX环境高级编程 - 文件I&#x2F;O - 读写&#x2F;共享文件","text":"函数lseek使用 lseek 函数显式的为一个打开文件设置偏移量。 每个打开的文件都有一个与其关联的“当前文件偏移量”。它通常是个非负整数，用于度量从文件开始处计算的字节数。 读、写操作都从当前文件偏移量处开始，并使偏移量增加所读写的字节数。 123#include &lt;unistd.h&gt;off_t lseek(int fd, off_t offset, int whence); 参数： fd：打开的文件的文件描述符 whence：必须是 SEEK_SET、SEEK_CUR、SEEK_END 三个常量之一 offset： 若 whence 是SEEK_SET，则将该文件的偏移量设置为距离文件开始处 offset 个字节 若 whence 是 SEEK_CUR，则将该文件的偏移量设置为当前值加上 offset 个字节，offset 可正，可负 若 whence 是 SEEK_END，则将该文件的偏移量设置为文件长度加上 offset 个字节，offset 可正，可负 返回值： 成功： 返回新的文件偏移量 失败：返回 -1 一些关于 lseek 和文件偏移量的注意事项： 打开一个文件时，除非指定 O_APPEND 选项，否则系统默认将该偏移量设为0 如果文件描述符指定的是一个管道、FIFO、或者网络套接字，则无法设定当前文件偏移量，则 lseek 将返回 -1 ，并且将 errno 设置为 ESPIPE。 对于普通文件，其当前文件偏移量必须是非负值。但是某些设备运行负的偏移量出现。因此比较 lseek 的结果时，不能根据它小于0 就认为出错。要根据是否等于 -1 来判断是否出错。 lseek 并不会引起任何 I/O 操作，lseek 仅仅将当前文件的偏移量记录在内核中。 当前文件偏移量可以大于文件的当前长度。此时对该文件的下一次写操作将加长该文件，并且在文件中构成一个空洞。空洞中的内容位于文件中但是没有被写过，其字节被读取时都被读为0 文件中的空洞并不要求在磁盘上占据存储区。具体处理方式与操作系统有关 函数read调用 read 函数从打开文件中读取数据。 读操作从文件的当前偏移量开始，在成功返回之前，文件的当前偏移量会增加实际读到的字节数。 123#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t nbytes); 参数： fd：打开的文件的文件描述符 buf：存放读取内容的缓冲区的地址（由程序员手动分配） nbytes：期望读到的字节数 返回值： 成功：返回读到的字节数，若已到文件尾则返回 0 失败：返回 -1 有多种情况可能导致实际读到的字节数少于期望读到的字节数： 读普通文件时，在读到期望字节数之前到达了文件尾端 当从终端设备读时，通常一次最多读取一行（终端默认是行缓冲的） 当从网络读时，网络中的缓存机制可能造成返回值小于期望读到的字节数 当从管道或者FIFO读时，若管道包含的字节少于所需的数量，则 read只返回实际可用的字节数 当从某些面向记录的设备（如磁带）中读取时，一次最多返回一条记录 当一个信号造成中断，而已读了部分数据时。 函数write123#include &lt;unistd.h&gt;ssize_t write(int fd, const void *buf, size_t nbytes); 参数： fd：打开的文件的文件描述符 buf：存放待写的数据内容的缓冲区的地址（由程序员手动分配） nbytes：期望写入文件的字节数 返回值： 成功：返回已写的字节数 失败：返回 -1 write 的返回值通常都是与 nbytes 相同。否则表示出错。 write 出错的一个常见原因是磁盘写满，或者超过了一个给定进行的文件长度限制 对于普通文件，写操作从文件的当前偏移量处开始。如果打开文件时指定了 O_APPEND 选项，则每次写操作之前，都会将文件偏移量设置在文件的当前结尾处。在一次成功写之后，该文件偏移量增加实际写的字节数。 I/O效率下图显示了用 20 种不同的缓冲区长度，读 516,581,760 字节的文件所得到的结果: 此测试所用的文件系统是 Linux ext4 文件系统，其磁盘块长度为 4096 字节（4K)。 系统 CPU 时间的几个最小值差不多出现在 BUFFSIZE 为 4096 及以后的位置，继续增加缓冲区长度对此时间几乎没有影响。 缓冲区长度小至 32 字节时的时钟时间与拥有较大缓冲区长度时的时钟时间几乎一样。 Why? 大多数文件系统为改善性能都采用某种预读（read ahead）技术。当检测到正进行顺序读取时，系统就试图读入比应用所要求的更多数据，并假想应用很快就会读这些数据。（利用了局部性原理） 文件共享UNIX 系统支持在不同进程间共享打开文件。 内核使用三种数据结构描述打开文件。它们之间的关系决定了一个进程与另一个进程在打开的文件之间的相互影响。 内核为每个进程分配一个进程表项（所有进程表项构成进程表），进程表中都有一个打开的文件描述符表。每个文件描述符占用一项，其内容为： 文件描述符标志 指向一个文件表项的指针 内核为每个打开的文件分配一个文件表项（所有的文件表项构成文件表）。每个文件表项的内容包括： 文件状态标志（读、写、添写、同步和阻塞等） 当前文件偏移量 指向该文件 v 结点表项的指针 每个打开的文件或者设备都有一个 v 结点结构（v-node）。 v 结点结构的内容包括： 文件类型和对此文件进行各种操作函数的指针。 对于大多数文件， v 结点还包含了该文件的 i 结点。 这些信息都是在打开文件时从磁盘读入内存的。如 i 结点包含了文件的所有者、文件长度、指向文件实际数据在磁盘上所在位置的指针等等。 v 结点结构和 i 结点结构实际上代表了文件的实体。 Linux 没有将相关数据结分为 i 节点和 v 节点，而是采用了一个与文件系统相关的 i 节点和个与文件系统无关的 i 节点。 一个进程打开多个文件： 两个进程打开同一个文件： 可能有多个文件描述符指向同一个文件表项。(dup、fork) dup的情况： fork的情况：","link":"/2023/03/06/linux-file-IO-read-write/"},{"title":"hitos - lab1 操作系统的引导解答","text":"实验目的 熟悉hit-oslab实验环境； 建立对操作系统引导过程的深入认识； 掌握操作系统的基本开发过程； 能对操作系统代码进行简单的控制，揭开操作系统的神秘面纱。 实验内容此次实验的基本内容是： 阅读《Linux内核完全注释》的第6章，对计算机和Linux 0.11的引导过程进行初步的了解； 按照下面的要求改写0.11的引导程序bootsect.s 有兴趣同学可以做做进入保护模式前的设置程序setup.s。 改写bootsect.s主要完成如下功能： bootsect.s能在屏幕上打印一段提示信息“XXX is booting…”，其中XXX是你给自己的操作系统起的名字，例如LZJos、Sunix等 改写setup.s主要完成如下功能： bootsect.s能完成setup.s的载入，并跳转到setup.s开始地址执行。而setup.s向屏幕输出一行”Now we are in SETUP”。 setup.s能获取至少一个基本的硬件参数（如内存参数、显卡参数、硬盘参数等），将其存放在内存的特定地址，并输出到屏幕上。 setup.s不再加载Linux内核，保持上述信息显示在屏幕上即可。 实验过程1 bootsect.s在屏幕上打印一段提示信息linux0.11源码中便有，改改即可。 核心代码如下： 12345678910111213141516171819202122! Print some inane messageok_load_setup: mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#23 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#msg1 mov ax,#0x1301 ! write string, move cursor int 0x10 msg1: .byte 13,10 .ascii &quot;COS is booting...&quot; .byte 13,10,13,10.org 508root_dev: .word ROOT_DEVboot_flag: .word 0xAA55 2 bootsect.s完成setup.s的载入，并跳转到setup.s开始地址执行首先是需要知道内存中的几个模块，比如boot、setup、system； 系统上电后各模块之间的执行顺序： 系统上电后，会将bootsec.s加载入0x7C00位置 bootsec.s将自己移动到0x90000 加载setup.s入内存，加载system入0x10000处，然后跳转至setup.s中执行 setup.s加载一些硬件参数 将系统移动至0x0000处，跳转至system中的head.s中执行 需要在bootsect.s中实现跳转到setup.s中执行： 1234567891011121314151617181920212223242526272829303132333435363738394041424344SETUPLEN = 4 ! nr of setup-sectorsBOOTSEG = 0x07c0 ! original address of boot-sectorINITSEG = 0x9000 ! we move boot here - out of the waySETUPSEG = 0x9020 ! setup starts hereSYSSEG = 0x1000 ! system loaded at 0x10000 (65536).ENDSEG = SYSSEG + SYSSIZE ! where to stop loading! ROOT_DEV: 0x000 - same type of floppy as boot.! 0x301 - first partition on first drive etcROOT_DEV = 0x306! move BOOTSEG -&gt; INITSEGentry _start_start: mov ax,#BOOTSEG mov ds,ax mov ax,#INITSEG mov es,ax mov cx,#256 sub si,si sub di,di rep movw jmpi go,INITSEGgo: mov ax,cs mov ds,ax mov es,ax! load setup.sload_setup: mov dx,#0x0000 ! drive 0, head 0 mov cx,#0x0002 ! sector 2, track 0 mov bx,#0x0200 ! address = 512, in INITSEG mov ax,#0x0200+SETUPLEN ! service 2, nr of sectors int 0x13 ! read it jnc ok_load_setup ! ok - continue mov dx,#0x0000 mov ax,#0x0000 ! reset the diskette int 0x13 j load_setup! jump to setup.s jmpi 0,SETUPSEG 然后在setup.s中显示已经跳转到setup.s中了，如下：(一定要记得重设ds数据段的寄存器，因为msg是在0x90200开始的数据段上的) 12345678910111213141516171819202122entry _start_start:init_ds_es: mov ax,cs mov ds,ax mov es,ax ! Print in begining of setup.sprint_cur: mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#28 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#msg1 mov ax,#0x1301 ! write string, move cursor int 0x10 msg1: .ascii &quot;Now we are in SETUP...&quot; .byte 13,10,13,10 3 setup.s获取硬件参数，将其存放在内存的特定地址，并输出到屏幕上3.1 获取光标位置使用bios的0x10号中断实现，ah是功能选择，结果放在dx中，最后将结果放入0x90000。 1234567! get cursor pos mov ax,#INITSEG mov ds,ax ! set ds=0x9000 mov ah,#0x03 ! get cursor pos xor bh,bh int 0x10 ! interrupt mov [0],dx ! write cursor pos to 0x90000. 打印： 1234567891011121314print_cursor_pos: mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#10 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#cursor mov ax,#0x1301 ! write string, move cursor int 0x10 mov ax,[0] call print_hex call print_nl 3.2 获取内存大小同上，利用bios的0x15号中断： 1234! get memory size mov ah,#0x88 int 0x15 mov [2],ax 打印： 12345678910111213print_memmory_size: mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#14 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#memory_size mov ax,#0x1301 ! write string, move cursor int 0x10 mov ax,[2] call print_hex 3.3 获取硬盘参数12345678910! 从0x41处拷贝16个字节（磁盘参数表） mov ax,#0x0000 mov ds,ax lds si,[4*0x41] mov ax,#INITSEG mov es,ax mov di,#0x0004 mov cx,#0x10 rep ! for i in 16: movsb 打印： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546print_hd_info:! Cylinders mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#16 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#hdinfo mov ax,#0x1301 ! write string, move cursor int 0x10 mov ax,[4] call print_hex call print_nl! head mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#10 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#head mov ax,#0x1301 ! write string, move cursor int 0x10 xor ax, ax mov al,[4+2] call print_hex call print_nl! sect mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#10 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#sect mov ax,#0x1301 ! write string, move cursor int 0x10 xor ax, ax mov al,[0x4+0x0E] call print_hex call print_nl 4 setup.s不再加载Linux内核，保持上述信息显示在屏幕上即可上述工作完成后，直接死循环即可： 12dead_loop: jmp dead_loop 5 完整代码bootsec.s: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111!! SYS_SIZE is the number of clicks (16 bytes) to be loaded.! 0x3000 is 0x30000 bytes = 196kB, more than enough for current! versions of linux!SYSSIZE = 0x3000!! bootsect.s (C) 1991 Linus Torvalds!! bootsect.s is loaded at 0x7c00 by the bios-startup routines, and moves! iself out of the way to address 0x90000, and jumps there.!! It then loads 'setup' directly after itself (0x90200), and the system! at 0x10000, using BIOS interrupts. !! NOTE! currently system is at most 8*65536 bytes long. This should be no! problem, even in the future. I want to keep it simple. This 512 kB! kernel size should be enough, especially as this doesn't contain the! buffer cache as in minix!! The loader has been made as simple as possible, and continuos! read errors will result in a unbreakable loop. Reboot by hand. It! loads pretty fast by getting whole sectors at a time whenever possible..globl begtext, begdata, begbss, endtext, enddata, endbss.textbegtext:.databegdata:.bssbegbss:.textSETUPLEN = 4 ! nr of setup-sectorsBOOTSEG = 0x07c0 ! original address of boot-sectorINITSEG = 0x9000 ! we move boot here - out of the waySETUPSEG = 0x9020 ! setup starts hereSYSSEG = 0x1000 ! system loaded at 0x10000 (65536).ENDSEG = SYSSEG + SYSSIZE ! where to stop loading! ROOT_DEV: 0x000 - same type of floppy as boot.! 0x301 - first partition on first drive etcROOT_DEV = 0x306! move BOOTSEG -&gt; INITSEGentry _start_start: mov ax,#BOOTSEG mov ds,ax mov ax,#INITSEG mov es,ax mov cx,#256 sub si,si sub di,di rep movw jmpi go,INITSEGgo: mov ax,cs mov ds,ax mov es,ax! load setup.sload_setup: mov dx,#0x0000 ! drive 0, head 0 mov cx,#0x0002 ! sector 2, track 0 mov bx,#0x0200 ! address = 512, in INITSEG mov ax,#0x0200+SETUPLEN ! service 2, nr of sectors int 0x13 ! read it jnc ok_load_setup ! ok - continue mov dx,#0x0000 mov ax,#0x0000 ! reset the diskette int 0x13 j load_setup! Print some inane messageok_load_setup: mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#23 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#msg1 mov ax,#0x1301 ! write string, move cursor int 0x10! jump to setup.s jmpi 0,SETUPSEGsectors: .word 0msg1: .byte 13,10 .ascii &quot;COS is booting...&quot; .byte 13,10,13,10.org 508root_dev: .word ROOT_DEVboot_flag: .word 0xAA55.textendtext:.dataenddata:.bssendbss: setup.s: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208.globl begtext, begdata, begbss, endtext, enddata, endbss.textbegtext:.databegdata:.bssbegbss:.textSETUPLEN = 4 ! nr of setup-sectorsBOOTSEG = 0x07c0 ! original address of boot-sectorINITSEG = 0x9000 ! we move boot here - out of the waySETUPSEG = 0x9020 ! setup starts hereSYSSEG = 0x1000 ! system loaded at 0x10000 (65536).ENDSEG = SYSSEG + SYSSIZE ! where to stop loading! ROOT_DEV: 0x000 - same type of floppy as boot.! 0x301 - first partition on first drive etcROOT_DEV = 0x306entry _start_start:init_ds_es: mov ax,cs mov ds,ax mov es,ax ! Print in begining of setup.sprint_cur: mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#28 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#msg1 mov ax,#0x1301 ! write string, move cursor int 0x10! get cursor pos mov ax,#INITSEG mov ds,ax ! set ds=0x9000 mov ah,#0x03 ! get cursor pos xor bh,bh int 0x10 ! interrupt mov [0],dx ! write cursor pos to 0x90000.! get memory size mov ah,#0x88 int 0x15 mov [2],ax! 从0x41处拷贝16个字节（磁盘参数表） mov ax,#0x0000 mov ds,ax lds si,[4*0x41] mov ax,#INITSEG mov es,ax mov di,#0x0004 mov cx,#0x10 rep ! for i in 16: movsbreset_ds_es: mov ax,#INITSEG mov ds,ax mov ax,#SETUPSEG mov es,ax print_cursor_pos: mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#10 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#cursor mov ax,#0x1301 ! write string, move cursor int 0x10 mov ax,[0] call print_hex call print_nlprint_memmory_size: mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#14 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#memory_size mov ax,#0x1301 ! write string, move cursor int 0x10 mov ax,[2] call print_hex print_hd_info:! Cylinders mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#16 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#hdinfo mov ax,#0x1301 ! write string, move cursor int 0x10 mov ax,[4] call print_hex call print_nl! head mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#10 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#head mov ax,#0x1301 ! write string, move cursor int 0x10 xor ax, ax mov al,[4+2] call print_hex call print_nl! sect mov ah,#0x03 ! read cursor pos xor bh,bh int 0x10 mov cx,#10 mov bx,#0x0007 ! page 0, attribute 7 (normal) mov bp,#sect mov ax,#0x1301 ! write string, move cursor int 0x10 xor ax, ax mov al,[0x4+0x0E] call print_hex call print_nldead_loop: jmp dead_loop! 以16进制方式打印栈顶的16位数, AXprint_hex: mov cx,#4 ! 4个十六进制数字 mov dx,ax ! 将ax所指的值放入dx中print_digit: rol dx,#4 ! 循环以使低4比特用上 !! 取dx的高4比特移到低4比特处。 mov ax,#0xe0f ! ah = 请求的功能值，al = 半字节(4个比特)掩码。 and al,dl ! 取dl的低4比特值。 add al,#0x30 ! 给al数字加上十六进制0x30 cmp al,#0x3a jl outp !是一个不大于十的数字 add al,#0x07 !是a～f，要多加7outp: int 0x10 loop print_digit ret! print \\n print_nl: mov ax,#0xe0d ! CR int 0x10 mov al,#0xa ! LF int 0x10 retmsg1: .ascii &quot;Now we are in SETUP...&quot; .byte 13,10,13,10cursor: .ascii &quot;cursor: 0x&quot;memory_size: .ascii &quot;memory_size:0x &quot;hdinfo: .ascii &quot;KB&quot; .byte 13,10 .ascii &quot;Cylinders:0x&quot;head: .ascii &quot;Headers:0x&quot;sect: .ascii &quot;Secotrs:0x&quot;.org 508root_dev: .word ROOT_DEVboot_flag: .word 0xAA55.textendtext:.dataenddata:.bssendbss: 使用make BootImage编译不过去，是要改一下tools/build.c： 判断system模块有没有，没有直接跳过后边读取即可： 123if (strcmp(argv[3], &quot;none&quot;) == 0) { return 0;} 加入位置如下： 实验结果编译： 运行结果： 查看bochs配置文件： 12345678910111213romimage: file=$OSLAB_PATH/bochs/BIOS-bochs-latestmegs: 16vgaromimage: file=$OSLAB_PATH/bochs/vgabios.binfloppya: 1_44=&quot;$OSLAB_PATH/linux-0.11/Image&quot;, status=insertedata0-master: type=disk, path=&quot;$OSLAB_PATH/hdc-0.11.img&quot;, mode=flat, cylinders=204, heads=16, spt=38boot: alog: $OSLAB_PATH/bochsout.txtkeyboard: type=mf, serial_delay=200, paste_delay=100000cpu: count=1, ips=4000000mouse: enabled=0private_colormap: enabled=0fullscreen: enabled=0screenmode: name=&quot;sample&quot; 其中有cylinders=204, heads=16, spt=38，和系统输出的获取到的参数是一样的，因此本次实验是成功的！ reference[1] 实验指导书","link":"/2023/03/06/linux-hitos-lab1/"},{"title":"UNIX环境高级编程 - 文件I&#x2F;O - 原子操作、复制、修改文件描述符","text":"原子操作 追加到一个文件 追加一个文件时，不能通过lseek到末尾然后write。要用O_APPEND选项打开文件，然后直接write。 通过lseek到末尾然后write时，如果多个进程同时执行这两个操作，则会引起竞争条件 通过 O_APPEND选项打开文件，然后直接write时，内核每一次在写操作之前，都会将进程的当前偏移量设置到文件的末尾，于是就不需要执行lseek定位操作 pread/pwrite可以执行原子性的定位读/定位写 O_CREAT|O_EXCL选项打开文件时，可以原子性的检查文件是否存在和创建文件这两个操作。 函数 pread 和 pwrite 123#include &lt;unistd.h&gt;ssize_t pread(int fd,void*buf,size_t nbytes,off_t offset);ssize_t pwrite(int fd,const void*buf,size_t nbytes,off_t offset); 参数： fd：打开的文件描述符 buf：读出数据存放的缓冲区/ 写到文件的数据的缓冲区 nbytes：预期读出/写入文件的字节数 offset：从文件指定偏移量开始执行read/write 返回： 成功：读到的字节数/已写的字节数 失败： -1 调用pread相当于先调用lseek再调用read.但是调用pread时，无法中断其定位和读操作，并且不更新当前文件偏移量；调用pwrite相当于先调用lseek再调用write.但是调用pwrite时，无法中断其定位和写操作，并且不更新当前文件偏移量 其他操作dup使用dup/dup2复制一个现有的文件描述符： 1234#include &lt;unistd.h&gt;int dup(int fd);int dup2(int fd,int fd2); 参数： fd：被复制的文件描述符（已被打开） fd2：指定的新的文件描述符（待生成） 返回值： 成功： 返回新的文件描述符 失败： 返回 -1 对于dup函数，返回的新的文件描述符一定是当前可用的文件描述符中最小的数字。 对于dup2函数： 如果 fd2已经是被打开的文件描述符且不等于fd，则先将其关闭，然后再打开（原子操作） 如果 fd2等于fd，则直接返回fd2（也等于fd），而不作任何操作 任何情况下，这个返回的新的文明描述符与参数fd共享同一个文件表项（因此文件状态标志以及文件偏移量都会共享）。任何情况下，这个返回的新的文明描述符的close-on-exec标志总是被清除。 dup后的内核数据结构如下： syncUNIX操作系统在内核中设有缓冲区，大多数磁盘 I/O 都通过缓冲区进行。当用户程序想文件写入数据时，内核通常都首先将数据复制到缓冲区中，然后排入队列，晚些时候再写入磁盘。这种方式称为延迟写。 当内核需要重用缓冲区来存方其他数据时，它会把所有延迟写的数据库写入磁盘 也可以调用下列函数来显式的将延迟写的数据库写入磁盘 12345#include &lt;unistd.h&gt;int fsync(int fd);int fdatasync(int fd);void sync(void); 参数： fd：指定的打开的文件描述符 返回值： 成功：返回 0 失败： 返回 -1 区别： sync：将所有修改过的块缓冲区排入写队列，然后返回，它并不等待时机写磁盘结束 fsync：只对由fd指定的单个文件起作用，等待写磁盘操作结束才返回 fdatasync：只对由fd指定的单个文件起作用，等待写磁盘操作结束才返回，但是它只影响文件的数据部分（fsync会同步更新文件的属性） update 守护进程会周期性的调用sync函数。命令sync也会调用sync函数","link":"/2023/03/06/linux-file-IO/"},{"title":"hitos - lab2 系统调用解答","text":"实验目的 建立对系统调用接口的深入认识 掌握系统调用的基本过程 能完成系统调用的全面控制 为后续实验做准备 实验内容此次实验的基本内容是：在Linux 0.11上添加两个系统调用，并编写两个简单的应用程序测试它们。 iam()第一个系统调用是iam()，其原型为： 1int iam(const char * name); 完成的功能是将字符串参数name的内容拷贝到内核中保存下来。要求name的长度不能超过23个字符。返回值是拷贝的字符数。如果name的字符个数超过了23，则返回“-1”，并置errno为EINVAL。 在kernal/who.c中实现此系统调用。 whoami()第二个系统调用是whoami()，其原型为： 1int whoami(char* name, unsigned int size); 它将内核中由iam()保存的名字拷贝到name指向的用户地址空间中，同时确保不会对name越界访存（name的大小由size说明）。返回值是拷贝的字符数。如果size小于需要的空间，则返回“-1”，并置errno为EINVAL。 也是在kernal/who.c中实现。 测试程序运行添加过新系统调用的Linux 0.11，在其环境下编写两个测试程序iam.c和whoami.c。最终的运行结果是： 123$ ./iam lizhijun$ ./whoamilizhijun 实验原理操作系统实现系统调用的基本过程是： 应用程序调用库函数（API）； API将系统调用号存入EAX，然后通过中断调用使系统进入内核态； 内核中的中断处理函数根据系统调用号，调用对应的内核函数（系统调用）； 系统调用完成相应功能，将返回值存入EAX，返回到中断处理函数； 中断处理函数返回到API中； API将EAX返回给应用程序。 应用程序如何调用系统调用在通常情况下，调用系统调用和调用一个普通的自定义函数在代码上并没有什么区别，但调用后发生的事情有很大不同。调用自定义函数是通过call指令直接跳转到该函数的地址，继续运行。而调用系统调用，是调用系统库中为该系统调用编写的一个接口函数，叫API（Application Programming Interface）。API并不能完成系统调用的真正功能，它要做的是去调用真正的系统调用，过程是： 把系统调用的编号存入EAX 把函数参数存入其它通用寄存器 触发0x80号中断（int 0x80） 0.11的lib目录下有一些已经实现的API。Linus编写它们的原因是在内核加载完毕后，会切换到用户模式下，做一些初始化工作，然后启动shell。而用户模式下的很多工作需要依赖一些系统调用才能完成，因此在内核中实现了这些系统调用的API。我们不妨看看lib/close.c，研究一下close()的API： 123#define __LIBRARY__#include &lt;unistd.h&gt;_syscall1(int,close,int,fd) 其中_syscall1是一个宏，在include/unistd.h中定义。将_syscall1(int,close,int,fd)进行宏展开，可以得到： 1234567891011int close(int fd) { long __res; __asm__ volatile (&quot;int $0x80&quot; : &quot;=a&quot; (__res) : &quot;0&quot; (__NR_close),&quot;b&quot; ((long)(fd))); if (__res &gt;= 0) return (int) __res; errno = -__res; return -1; } 这就是API的定义。它先将宏__NR_close存入EAX，将参数fd存入EBX，然后进行0x80中断调用。调用返回后，从EAX取出返回值，存入__res，再通过对__res的判断决定传给API的调用者什么样的返回值。其中__NR_close就是系统调用的编号，在include/unistd.h中定义： 1#define __NR_close 6 所以添加系统调用时需要修改include/unistd.h文件，使其包含__NR_whoami和__NR_iam。而在应用程序中，要有： 1234#define __LIBRARY__ /* 有它，_syscall1等才有效。详见unistd.h */#include &lt;unistd.h&gt; /* 有它，编译器才能获知自定义的系统调用的编号 */_syscall1(int, iam, const char*, name); /* iam()在用户空间的接口函数 */_syscall2(int, whoami,char*,name,unsigned int,size); /* whoami()在用户空间的接口函数 */ 在0.11环境下编译C程序，包含的头文件都在/usr/include目录下。该目录下的unistd.h是标准头文件（它和0.11源码树中的unistd.h并不是同一个文件，虽然内容可能相同），没有__NR_whoami和__NR_iam两个宏，需要手工加上它们，也可以直接从修改过的0.11源码树中拷贝新的unistd.h过来。 从“int 0x80”进入内核函数int 0x80触发后，接下来就是内核的中断处理了。先了解一下0.11处理0x80号中断的过程。 在内核初始化时，主函数（在init/main.c中，Linux实验环境下是main()，Windows下因编译器兼容性问题被换名为start()）调用了sched_init()初始化函数： 12345678910111213141516171819202122232425262728293031void main(void) { …… time_init(); sched_init(); buffer_init(buffer_memory_end); ……}sched_init()在kernel/sched.c中定义为：void sched_init(void){ …… set_system_gate(0x80,&amp;system_call);}set_system_gate是个宏，在include/asm/system.h中定义为：#define set_system_gate(n,addr) \\ _set_gate(&amp;idt[n],15,3,addr)_set_gate的定义是：#define _set_gate(gate_addr,type,dpl,addr) \\__asm__ (&quot;movw %%dx,%%ax\\n\\t&quot; \\ &quot;movw %0,%%dx\\n\\t&quot; \\ &quot;movl %%eax,%1\\n\\t&quot; \\ &quot;movl %%edx,%2&quot; \\ : \\ : &quot;i&quot; ((short) (0x8000+(dpl&lt;&lt;13)+(type&lt;&lt;8))), \\ &quot;o&quot; (*((char *) (gate_addr))), \\ &quot;o&quot; (*(4+(char *) (gate_addr))), \\ &quot;d&quot; ((char *) (addr)),&quot;a&quot; (0x00080000)) 虽然看起来挺麻烦，但实际上很简单，就是填写IDT（中断描述符表），将system_call函数地址写到0x80对应的中断描述符中，也就是在中断0x80发生后，自动调用函数system_call。具体细节请参考《注释》的第4章。 接下来看system_call。该函数纯汇编打造，定义在kernel/system_call.s中： 1234567891011121314151617181920212223242526……nr_system_calls = 72 #这是系统调用总数。如果增删了系统调用，必须做相应修改…….globl system_call.align 2system_call: cmpl $nr_system_calls-1,%eax #检查系统调用编号是否在合法范围内 ja bad_sys_call push %ds push %es push %fs pushl %edx pushl %ecx pushl %ebx # push %ebx,%ecx,%edx，是传递给系统调用的参数 movl $0x10,%edx # 让ds,es指向GDT，内核地址空间 mov %dx,%ds mov %dx,%es movl $0x17,%edx # 让fs指向LDT，用户地址空间 mov %dx,%fs call sys_call_table(,%eax,4) pushl %eax movl current,%eax cmpl $0,state(%eax) jne reschedule cmpl $0,counter(%eax) je reschedule system_call用.globl修饰为其他函数可见。Windows实验环境下会看到它有一个下划线前缀，这是不同版本编译器的特质决定的，没有实质区别。call sys_call_table(,%eax,4)之前是一些压栈保护，修改段选择子为内核段，call sys_call_table(,%eax,4)之后是看看是否需要重新调度，这些都与本实验没有直接关系，此处只关心call sys_call_table(,%eax,4)这一句。根据汇编寻址方法它实际上是： 1call sys_call_table + 4 * %eax # 其中eax中放的是系统调用号，即__NR_xxxxxx 显然，sys_call_table一定是一个函数指针数组的起始地址，它定义在include/linux/sys.h中： 1fn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, sys_read,…… 增加实验要求的系统调用，需要在这个函数表中增加两个函数引用——sys_iam和sys_whoami。当然该函数在sys_call_table数组中的位置必须和__NR_xxxxxx的值对应上。同时还要仿照此文件中前面各个系统调用的写法，加上： 12extern int sys_whoami();extern int sys_iam(); 不然，编译会出错的。 实验过程添加系统调用的流程添加一个系统调用的流程如下： 修改 include/unistd.h， 添加#define __NR_foo num，num为接下来使用的系统调用号 修改 include/linux/sys.h , 添加extern rettype sys_foo();， 在sys_call_table数组对应位置加入sys_foo 修改 kernel/system_call.s，修改 nr_system_calls = num (num为系统调用总数目) 在 kernel 中添加 foo.c （若需要支持内核态与用户态数据交互，则包含 include/asm/segment.h，其中有 put_fs_XXX 和 get_fs_XXX函数） 在 foo.c 实现系统调用sys_foo() 修改 kernel 的Makefile，将 foo.c 与内核其它代码编译链接到一起 系统调用用户需要使用 123#define __LIBRARY__#include &lt;unistd.h&gt;_syscallN宏展开系统调用，提供用户态的系统调用接口（参数数目确定具体宏） 添加whoami和iam两个系统调用： 修改 include/unistd.h， 添加#define __NR_foo num，num为接下来使用的系统调用号 12#define __NR_iam 72#define __NR_whoami 73 修改 include/linux/sys.h , 添加extern rettype sys_foo();， 在sys_call_table数组对应位置加入sys_foo 12345678910111213141516extern int sys_iam();extern int sys_whoami();fn_ptr sys_call_table[] = { sys_setup, sys_exit, sys_fork, sys_read,sys_write, sys_open, sys_close, sys_waitpid, sys_creat, sys_link,sys_unlink, sys_execve, sys_chdir, sys_time, sys_mknod, sys_chmod,sys_chown, sys_break, sys_stat, sys_lseek, sys_getpid, sys_mount,sys_umount, sys_setuid, sys_getuid, sys_stime, sys_ptrace, sys_alarm,sys_fstat, sys_pause, sys_utime, sys_stty, sys_gtty, sys_access,sys_nice, sys_ftime, sys_sync, sys_kill, sys_rename, sys_mkdir,sys_rmdir, sys_dup, sys_pipe, sys_times, sys_prof, sys_brk, sys_setgid,sys_getgid, sys_signal, sys_geteuid, sys_getegid, sys_acct, sys_phys,sys_lock, sys_ioctl, sys_fcntl, sys_mpx, sys_setpgid, sys_ulimit,sys_uname, sys_umask, sys_chroot, sys_ustat, sys_dup2, sys_getppid,sys_getpgrp, sys_setsid, sys_sigaction, sys_sgetmask, sys_ssetmask,sys_setreuid, sys_setregid, sys_iam, sys_whoami}; 修改 kernel/system_call.s，修改 nr_system_calls = num (num为系统调用总数目) 1nr_system_calls = 74 在 kernel 中添加 foo.c （若需要支持内核态与用户态数据交互，则包含 include/asm/segment.h，其中有 put_fs_XXX 和 get_fs_XXX函数） 在 foo.c 实现系统调用sys_foo() who.c内容如下： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;asm/segment.h&gt;char username[24];int sys_iam(const char * name) { char tmp[26]; short break_flag = 0, i = 0; for (i = 0; i &lt; 26; ++i) { tmp[i] = get_fs_byte(name + i); if (tmp[i] == '\\0') { break_flag = 1; break; } } if (!break_flag || i &gt; 23) { return -(EINVAL); } char* dest = username; strcpy(dest, tmp); return i;}int sys_whoami(char* name, unsigned int size) { short length = strlen(username); if (length &gt; size) { return -(EINVAL); } short i = 0; for (i; i &lt; size; ++i) { put_fs_byte(username[i], name + i); if (username[i] == '\\0') { break; } } return i;} 修改 kernel 的Makefile，将 foo.c 与内核其它代码编译链接到一起 123456OBJS = sched.o system_call.o traps.o asm.o fork.o \\ panic.o printk.o vsprintf.o sys.o exit.o \\ signal.o mktime.o who.o### Dependencies:who.s who.o: who.c ../include/linux/kernel.h ../include/unistd.h 用户调用系统调用：(在运行的linux0.11上编写编译运行) whoami.c: 12345678910111213#include &lt;errno.h&gt;#define __LIBRARY__#include &lt;unistd.h&gt;_syscall2(int, whoami,char*,name,unsigned int,size);int main(){ char s[30]; whoami(s,30); printf(&quot;%s&quot;,s); return 0;} iam.c: 123456789101112#include &lt;errno.h&gt;#define __LIBRARY__#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;_syscall1(int, iam, const char*, name);int main(int argc,char ** argv){ iam(argv[1]); return 0;} 如编译错误，说__NR_whoami和__NR_iam未定义，则是下面的问题： 在0.11环境下编译C程序，包含的头文件都在/usr/include目录下。该目录下的unistd.h是标准头文件（它和0.11源码树中的unistd.h并不是同一个文件，虽然内容可能相同），没有__NR_whoami和__NR_iam两个宏，需要手工加上它们，也可以直接从修改过的0.11源码树中拷贝新的unistd.h过来。 实验结果可以发现可以很好地执行！证明此次实验是成功的！ reference[1] 实验指导书 [2] 现成代码","link":"/2023/03/06/linux-hitos-lab2/"},{"title":"hitos - lab4 信号量的实现和应用解答","text":"所需数据结构（定义在头文件中，用户也需要知道）： 123456789101112131415161718#define SEM_FAILED (void*) 0#define SEM_NAME_MAX_LEN 16#define SEM_QUEUE_LEN 16struct semaphore_queue { int front; int rear; struct task_struct* wait_tasks[SEM_QUEUE_LEN];};typedef struct semaphore_queue sem_queue;struct semaphore_t { int val; int open_flag; char name[SEM_NAME_MAX_LEN]; sem_queue wait_queue;};typedef struct semaphore_t sem_t; 对上述数据结构的一些基本操作（实现了一个循环队列）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#define __LIBRARY__ #include &lt;unistd.h&gt; /* type def */#include &lt;linux/sched.h&gt; /* schedule */#include &lt;linux/kernel.h&gt; /* printk */#include &lt;asm/segment.h&gt; /* get_fs_byte */#include &lt;asm/system.h&gt; /* sti cli */#define SEM_COUNT 32sem_t semaphores[SEM_COUNT];void init_queue(sem_queue* q) { q-&gt;front = q-&gt;rear = 0;}int empty(sem_queue* q) { return q-&gt;front == q-&gt;rear ? 1 : 0;}int full(sem_queue* q) { return (q-&gt;rear + 1) % SEM_QUEUE_LEN == q-&gt;front ? 1 : 0;} struct task_struct* front(sem_queue* q) { if(empty(q)) { printk(&quot;front fail! no task in queue\\n&quot;); return NULL; } struct task_struct *tmp = q-&gt;wait_tasks[q-&gt;front]; return tmp;}void pop(sem_queue* q) { if (empty(q)) { printk(&quot;pop fail! no task in queue!\\n&quot;); return; } q-&gt;front = (q-&gt;front + 1) % SEM_QUEUE_LEN;}void push(sem_queue* q, struct task_struct* p) { if (full(q)) { printk(&quot;push fail! queue is full!\\n&quot;); return; } q-&gt;wait_tasks[q-&gt;rear] = p; q-&gt;rear = (q-&gt;rear + 1) % SEM_QUEUE_LEN;}int sem_exit(const char* name) { int i = 0; for (i = 0; i &lt; SEM_COUNT; ++i) { if (semaphores[i].open_flag == 1 &amp;&amp; strcmp(name, semaphores[i].name) == 0) { return i; } } return -1;} sem_open实现: 12345678910111213141516171819202122232425262728293031sem_t* sys_sem_open(const char* name, unsigned int value) { char buffer[SEM_NAME_MAX_LEN]; int i = 0; for (i = 0; i &lt; SEM_NAME_MAX_LEN; ++i) { buffer[i] = get_fs_byte(name + i); if (buffer[i] == '\\0') { break; } } if (i &gt;= SEM_NAME_MAX_LEN) { printk(&quot;name too long!\\n&quot;); return NULL; } int idx = sem_exit(buffer); if (idx != -1) { // exits return &amp;semaphores[idx]; } // not exits for (i = 0; i &lt; SEM_COUNT; ++i) { if (semaphores[i].open_flag == 0) { strcpy(semaphores[i].name, buffer); semaphores[i].open_flag = 1; semaphores[i].val = value; init_queue(&amp;(semaphores[i].wait_queue)); return &amp;semaphores[i]; } } // can't find a slot printk(&quot;MAX SEMAPHORE's NUMBER IS %d, NOW FULL!\\n&quot;, SEM_COUNT); return NULL;} sem_unlink实现: 1234567891011121314151617181920212223int sys_sem_unlink(const char *name) { char buffer[SEM_NAME_MAX_LEN]; int i = 0; for (i = 0; i &lt; SEM_NAME_MAX_LEN; ++i) { buffer[i] = get_fs_byte(name + i); if (buffer[i] == '\\0') { break; } } if (i &gt;= SEM_NAME_MAX_LEN) { printk(&quot;name too long!\\n&quot;); return -1; } int idx = sem_exit(buffer); if (idx == -1) { // not exits printk(&quot;SEM %s NOT EXIT\\n&quot;, buffer); return -1; } semaphores[idx].val = 0; semaphores[idx].open_flag = 0; strcpy(semaphores[idx].name, &quot;\\0&quot;); return 0;} sem_wait实现: 12345678910111213int sys_sem_wait(sem_t* sem) { if (sem == NULL) { return -1; } cli(); if (--sem-&gt;val &lt; 0) { current-&gt;state = TASK_UNINTERRUPTIBLE; push(&amp;(sem-&gt;wait_queue), current); schedule(); } sti(); return 0;} sem_wait实现: 123456789101112131415int sys_sem_post(sem_t* sem) { if (sem == NULL) { return -1; } cli(); if (++sem-&gt;val &lt;= 0) { struct task_struct* p = front(&amp;(sem-&gt;wait_queue)); if (p != NULL) { pop(&amp;(sem-&gt;wait_queue)); p-&gt;state = TASK_RUNNING; } } sti(); return 0;} 然后按添加系统调用的流程添加上系统调用即可。 有一个比较坑的地方是，添加的系统调用可能没用，编译不过去（拷贝个unistd.h到linux0.11即可）。","link":"/2023/03/06/linux-hitos-lab4/"},{"title":"linux0.11 - 地址映射过程","text":"0. 概述linux0.11对内存的管理是段页式的，所以其地址映射过程是将逻辑地址先通过分段机制变换得到线性地址，然后再通过分页机制变换为实际的物理地址。 1. 分段linux除了启动时运行在实模式下，其他时间运行在保护模式下。 保护模式下寻址和实模式有所不同： 实模式即DS：SI的形式去寻址。 保护模式通过段选择子的方式来寻址。（计算机科学中经典的加一层设计） 在保护模式下，段寄存器中存放的是一个段描述符表(Segment Descriptor Table)中某描述符项在表中的索引值。索引值指定的段描述符项中含有需要寻址的内存段的基地址、段的长度值和段的访问特权级别等信息。 在Linux0.11中，程序逻辑地址到线性地址的变换过程使用了CPU的全局段描述符表GDT和局部段描述符表LDT。 由GDT映射的地址空间称为全局地址空间，由LDT映射的地址空间则称为局部地址空间，而这两者构成了虚拟地址的空间。 2. 分页采用多级页表的形式进行分页。 控制寄存器CR3保存着是当前页目录表在物理内存中的基地址（因此CR3也被称为页目录基地址寄存器PDBR）。 32位的线性地址被分成三个部分： 页目录表中偏移。 页表中偏移。 页内偏移。 4. 例子以下边这段程序为例子，跟踪 i 的地址翻译过程。（即从逻辑地址怎么映射到物理地址的） 1234567891011121314#include &lt;stdio.h&gt;int i = 0x12345678;int main(void){ printf(&quot;The logical/virtual address of i is 0x%08x&quot;, &amp;i); fflush(stdout); while (i) ; return 0;} 运行以上程序，结果为： 1The logical/virtual address of i is 0x00003004 可知 i 的逻辑地址为0x00003004。 4.1 分段（逻辑地址 =&gt; 线性地址）ctrl+c 使Bochs暂停运行，进入调试状态： 1(0) [0x000000fa7063] 000f:00000063 (unk. ctxt): cmp dword ptr ds:0x00003004, 0x00000000 ; 833d0430000000 ds:0x3004是虚拟地址，ds表明这个地址属于ds段。 在GDT（全局描述符表）中找到LDT的基地址 1234567891011121314151617&lt;bochs:49&gt; sreges:0x0017, dh=0x10c0f300, dl=0x00003fff, valid=1 Data segment, base=0x10000000, limit=0x03ffffff, Read/Write, Accessedcs:0x000f, dh=0x10c0fb00, dl=0x00000002, valid=1 Code segment, base=0x10000000, limit=0x00002fff, Execute/Read, Non-Conforming, Accessed, 32-bitss:0x0017, dh=0x10c0f300, dl=0x00003fff, valid=1 Data segment, base=0x10000000, limit=0x03ffffff, Read/Write, Accessedds:0x0017, dh=0x10c0f300, dl=0x00003fff, valid=3 Data segment, base=0x10000000, limit=0x03ffffff, Read/Write, Accessedfs:0x0017, dh=0x10c0f300, dl=0x00003fff, valid=1 Data segment, base=0x10000000, limit=0x03ffffff, Read/Write, Accessedgs:0x0017, dh=0x10c0f300, dl=0x00003fff, valid=1 Data segment, base=0x10000000, limit=0x03ffffff, Read/Write, Accessedldtr:0x0068, dh=0x000082fa, dl=0xa2d00068, valid=1tr:0x0060, dh=0x00008bfa, dl=0xa2e80068, valid=1gdtr:base=0x00005cb8, limit=0x7ffidtr:base=0x000054b8, limit=0x7ff GDT的位置由gdtr明确给出，在物理地址的0x00005cb8。 ldtr是GDT的段选择子。0x0068=0000000001101000（二进制），表示LDT表存放在GDT表的1101(二进制)=13（十进制）号位置。 123&lt;bochs:50&gt; xp /2w 0x5cb8 + 13 * 8[bochs]:0x00005d20 &lt;bogus+ 0&gt;: 0xa2d00068 0x000082fa 段描述符定义如下： 组合出LDT的基地址：0x00faa2d0 在LDT中找到段描述符，将逻辑地址映射为线性地址 查看LDT： 1234&lt;bochs:51&gt; xp /8w 0xfaa2d0[bochs]:0x00faa2d0 &lt;bogus+ 0&gt;: 0x00000000 0x00000000 0x00000002 0x10c0fb000x00faa2e0 &lt;bogus+ 16&gt;: 0x00003fff 0x10c0f300 0x00000000 0x00fab000 根据ds为0x0017（0x0017=0000000000010111（二进制）），由段选择子的概念，得出是LDT中的第10（二进制）项。 LDT[2]的内容为0x00003fff 0x10c0f300，根据段描述符的概念可知：ds所代表的段的基址为0x10000000； 由：线性地址 = 段基址 + 段内偏移 所以ds:0x3004的线性地址就是：0x10000000 + 0x3004 = 0x10003004。 4.2 分页（线性地址 =&gt; 物理地址）从线性地址计算物理地址，需要查找页表。线性地址变成物理地址的过程如下： 0x10003004的页目录号是64，页号3，页内偏移是4。 IA-32下，页目录表的位置由CR3寄存器指引。查看CR3寄存器内容。 12345678&lt;bochs:52&gt; cregCR0=0x8000001b: PG cd nw ac wp ne ET TS em MP PECR2=page fault laddr=0x10002facCR3=0x000000000000 PCD=page-level cache disable=0 PWT=page-level write-through=0CR4=0x00000000: pke smap smep osxsave pcid fsgsbase smx vmx osxmmexcpt umip osfxsr pce pge mce pae pse de tsd pvi vmeEFER=0x00000000: ffxsr nxe lma lme sce 由上可知：页目录表的起始地址（CR3）为0x000000000000。 页目录表中的第64项为： 123&lt;bochs:54&gt; xp /w 0 + 64 * 4[bochs]:0x00000100 &lt;bogus+ 0&gt;: 0x00fa3027 ‘ 所以页表所在物理页框号为0x00fa3，即页表在物理内存的0x00fa3000位置。 查看页表0x00fa3000的第三页，有 123&lt;bochs:57&gt; xp /w 0x00fa3000 + 3 * 4[bochs]:0x00fa300c &lt;bogus+ 0&gt;: 0x00f9c067 组合上页内偏移，物理地址为0x00f9c004。 验证下： 123&lt;bochs:58&gt; xp /w 0x00f9c004[bochs]:0x00f9c004 &lt;bogus+ 0&gt;: 0x12345678 5. 总结 参考资料[1] linux内核完全注释 [2] 哈工大操作系统实验指导书","link":"/2023/03/06/linux-linux0-11-memory-map/"},{"title":"Linux网络编程 - 发送&#x2F;接收数据 &amp; 缓冲区","text":"发送数据可以用以下三个函数发送数据。每个函数都是单独使用的，使用的场景略有不同。 12345ssize_t write (int socketfd, const void *buffer, size_t size); #include &lt;sys/socket.h&gt;ssize_t send (int socketfd, const void *buffer, size_t size, int flags);ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags); write 就是常见的文件写函数（Linux中一切皆为文件）。 对于普通文件描述符而言，操作系统内核不断地往文件系统中写入字节流。 写入的字节流大小通常和输入参数 size 的值是相同的，否则表示出错。 对于套接字描述符而言，它代表了一个双向连接。 写入的字节数有可能比请求的数量少。 send 可以指定选项，发送带外数据（一种基于 TCP 协议的紧急数据，用于客户端 - 服务器在特定场景下的紧急处理）。 sendmsg 指定多重缓冲区传输数据，以结构体 msghdr 的方式发送数据。 msghdr定义： 12345678910111213&gt;struct iovec { /* Scatter/gather array items */void *iov_base; /* Starting address */size_t iov_len; /* Number of bytes to transfer */&gt;};&gt;struct msghdr {void *msg_name; /* Optional address */socklen_t msg_namelen; /* Size of address */struct iovec *msg_iov; /* Scatter/gather array */size_t msg_iovlen; /* # elements in msg_iov */void *msg_control; /* Ancillary data, see below */size_t msg_controllen; /* Ancillary data buffer len */int msg_flags; /* Flags on received message */&gt;}; 发送缓冲区当 TCP 三次握手成功，TCP 连接成功建立后，操作系统内核会为每一个连接创建配套的基础设施，比如发送缓冲区。 发送缓冲区的大小可以通过套接字选项来改变，当应用程序调用 write 函数时，实际所做的事情是把数据从应用程序中拷贝到操作系统内核的发送缓冲区中，并不一定是把数据通过套接字写出去。 wirte() 的返回时机：直到某一个时刻，应用程序的数据可以完全放置到发送缓冲区里，write() 阻塞调用返回。 读取数据12345ssize_t read (int socketfd, void *buffer, size_t size);#include &lt;sys/socket.h&gt;ssize_t recv(int sockfd, void *buf, size_t len, int flags);ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags); read 函数要求操作系统内核从套接字描述字 socketfd 读取最多多少个字节（size），并将结果存储到 buffer 中。 返回值表示实际读取的字节数目，如果返回值为 0，表示 EOF（end-of-file），这在网络中表示对端发送了 FIN 包，要处理断连的情况；如果返回值为 -1，表示出错。 read 是最多读取 size 个字节。循环读取，每次都读到 size 个字节的函数： 1234567891011121314151617181920size_t readn(int fd, void *buffer, size_t size) { char *buffer_pointer = (char *)buffer; int length = size; while (length &gt; 0) { int result = read(fd, buffer_pointer, length); if (result &lt; 0) { if (errno == EINTR) continue; /* 考虑非阻塞的情况，这里需要再次调用read */ else return (-1); } else if (result == 0) break; /* EOF(End of File)表示套接字关闭 */ length -= result; buffer_pointer += result; } return (size - length); /* 返回的是实际读取的字节数*/} 例子common.h : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#pragma once#include &lt;iostream&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#include &lt;string.h&gt;#include &lt;string&gt;#include &lt;unistd.h&gt;#include &lt;errno.h&gt;#include &lt;netinet/in.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;/* error - print a diagnostic and optionally exit */void error(int status, int err, char *fmt, ...) { va_list ap; va_start(ap, fmt); vfprintf(stderr, fmt, ap); va_end(ap); if (err) { fprintf(stderr, &quot;: %s (%d)\\n&quot;, strerror(err), err); } if (status) { exit(status); }}int tcp_client(char *address, int port) { int socket_fd; socket_fd = socket(AF_INET, SOCK_STREAM, 0); struct sockaddr_in server_addr; bzero(&amp;server_addr, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(port); inet_pton(AF_INET, address, &amp;server_addr.sin_addr); socklen_t server_len = sizeof(server_addr); int connect_rt = connect(socket_fd, (struct sockaddr *) &amp;server_addr, server_len); if (connect_rt &lt; 0) { error(1, errno, &quot;connect failed &quot;); } return socket_fd;}size_t readn(int fd, void *buffer, size_t size) { char *buffer_pointer = (char *)buffer; int length = size; while (length &gt; 0) { int result = read(fd, buffer_pointer, length); if (result &lt; 0) { if (errno == EINTR) continue; /* 考虑非阻塞的情况，这里需要再次调用read */ else return (-1); } else if (result == 0) break; /* EOF(End of File)表示套接字关闭 */ length -= result; buffer_pointer += result; } return (size - length); /* 返回的是实际读取的字节数*/} Client: 12345678910111213141516171819202122232425262728293031323334353637383940#include &quot;tcp_send_read/common/commom.h&quot;# define MESSAGE_SIZE 1024 * 1024 * 100void send_data(int sockfd) { char *query; query = (char *)malloc(MESSAGE_SIZE + 1); for (int i = 0; i &lt; MESSAGE_SIZE; i++) { query[i] = 'a'; } query[MESSAGE_SIZE] = '\\0'; const char *cp; cp = query; size_t remaining = strlen(query); while (remaining) { int n_written = send(sockfd, cp, remaining, 0); fprintf(stdout, &quot;send into buffer %ld \\n&quot;, n_written); if (n_written &lt;= 0) { error(1, errno, &quot;send failed&quot;); return; } remaining -= n_written; cp += n_written; } return;}int main(int argc, char **argv) { struct sockaddr_in servaddr; if (argc != 2) error(1, 0, &quot;usage: tcpclient &lt;IPaddress&gt;&quot;); int sockfd = tcp_client(argv[1], 12345); send_data(sockfd); exit(0);} Server: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &quot;tcp_send_read/common/commom.h&quot;#define BUFFER_SIZE 1024 * 1024void read_data(int sockfd) { ssize_t n; char buf[BUFFER_SIZE]; int time = 0; for (;;) { fprintf(stdout, &quot;block in read\\n&quot;); if ((n = readn(sockfd, buf, BUFFER_SIZE)) == 0) { // EOF fprintf(stdout, &quot;read 0, close it!\\n&quot;); fflush(stdout); // must flust it! return; } time++; fprintf(stdout, &quot;1M read for %d \\n&quot;, time); usleep(2000); }}int main(int argc, char **argv) { int listenfd, connfd; socklen_t clilen; struct sockaddr_in cliaddr, servaddr; listenfd = socket(AF_INET, SOCK_STREAM, 0); bzero(&amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(12345); /* bind到本地地址，端口为12345 */ bind(listenfd, (struct sockaddr *) &amp;servaddr, sizeof(servaddr)); /* listen的backlog为1024 */ listen(listenfd, 1024); /* 循环处理用户请求 */ for (;;) { clilen = sizeof(cliaddr); connfd = accept(listenfd, (struct sockaddr *) &amp;cliaddr, &amp;clilen); read_data(connfd); /* 读取数据 */ close(connfd); /* 关闭连接套接字，注意不是监听套接字*/ }} 此程序能说明几个问题： 阻塞式套接字最终发送返回的实际写入字节数和请求字节数是相等的 对于 send 来说，返回成功仅表示数据写到发送缓冲区成功，并不意味着对端已经成功收到（对端何时收到，对发送者透明） reference[1] 极客时间 · 网络编程实战 ：05 | 使用套接字进行读写：开始交流吧 [2] Linux高性能服务器编程","link":"/2023/03/06/linux-network-send-recv/"},{"title":"linux0.11 - 进程调度函数分析","text":"0 引言进程是操作系统分配资源的最小单位；线程是程序执行的最小单位。计算机上运行着几十上百个程序，对于每个程序而言，他们都是独享CPU的，操作系统制造了这一有多个CPU的假象。这一假象得以维持的基础就在于进程之间的切换，而进程切换则需要用到进程调度，具体的进程调度内容可以看之前的博文：操作系统-进程调度。 但是空说无凭，理论还是需要结合实际，这篇博文将从linux0.11入手，看一个实际的调度函数。 1 源码分析1.1 时间片轮转在BIOS引导进入系统后，会执行系统的main函数（init/main.c）： 12345678910111213141516void main(void) /* This really IS void, no error here. */{ /* The startup routine assumes (well, ...) this *//* * Interrupts are still disabled. Do necessary setups, then * enable them */ ... sched_init(); ... move_to_user_mode(); if (!fork()) { /* we count on this going ok */ init(); } for(;;) pause();} 其中进行了很多的初始化操作，包括 sched_init，这便是内核调度程序的初始化子程序(kernel/sched.c)，其定义如下： 12345678910void sched_init(void){ ... outb_p(0x36,0x43); /* binary, mode 3, LSB/MSB, ch 0 */ outb_p(LATCH &amp; 0xff , 0x40); /* LSB */ outb(LATCH &gt;&gt; 8 , 0x40); /* MSB */ set_intr_gate(0x20,&amp;timer_interrupt); ...} sched_init 初始化了8253定时器（微机原理与接口技术学过的），8253每10ms发出一个中断请求信号。然后设置了一个中断服务程序 timer_interrupt，即每10ms中断一次，执行一次 timer_interrupt 。 timer_interrupt 在kernel/system_call.s中定义，为一段汇编程序： 1234567891011121314151617181920212223.align 2timer_interrupt: push %ds # save ds,es and put kernel data space push %es # into them. %fs is used by _system_call push %fs pushl %edx # we save %eax,%ecx,%edx as gcc doesn't pushl %ecx # save those across function calls. %ebx pushl %ebx # is saved as we use that in ret_sys_call pushl %eax movl $0x10,%eax mov %ax,%ds mov %ax,%es movl $0x17,%eax mov %ax,%fs incl jiffies movb $0x20,%al # EOI to interrupt controller #1 outb %al,$0x20 movl CS(%esp),%eax andl $3,%eax # %eax is CPL (0 or 3, 0=supervisor) pushl %eax call do_timer # 'do_timer(long CPL)' does everything from addl $4,%esp # task switching to accounting ... jmp ret_from_sys_call 可以发现，其核心为一句 call do_timer，即调用 do_timer 函数。 do_timer 函数在kernel/sched.c中定义， 123456789void do_timer(long cpl){ ... if ((--current-&gt;counter)&gt;0) return; current-&gt;counter=0; // 内核中不调度 if (!cpl) return; schedule();} 其调用了一个 schedule(), 这个 schedule() 函数选出下一个要执行的进程，并且切换到它，这是今天的主角！ 通过上面的分析可以发现，counter 扮演了时间片的角色，每一次8253产生中断会调用中断服务程序，使 counter 减1，减到0则调用调度函数 schedule()，这是一个十分明显的round robin（时间片轮转）策略。 1.2 优先级调度先看看 schedule() 函数的全貌吧，只看片段容易盲人摸象： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* * 'schedule()' is the scheduler function. This is GOOD CODE! There * probably won't be any reason to change this, as it should work well * in all circumstances (ie gives IO-bound processes good response etc). * The one thing you might take a look at is the signal-handler code here. * * NOTE!! Task 0 is the 'idle' task, which gets called when no other * tasks can run. It can not be killed, and it cannot sleep. The 'state' * information in task[0] is never used. */void schedule(void){ int i,next,c; struct task_struct ** p;/* check alarm, wake up any interruptible tasks that have got a signal */ for(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p) if (*p) { if ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) { (*p)-&gt;signal |= (1&lt;&lt;(SIGALRM-1)); (*p)-&gt;alarm = 0; } if (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp; (*p)-&gt;state==TASK_INTERRUPTIBLE) { (*p)-&gt;state=TASK_RUNNING; } }/* this is the scheduler proper: */ while (1) { c = -1; next = 0; i = NR_TASKS; p = &amp;task[NR_TASKS]; while (--i) { if (!*--p) continue; if ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c) c = (*p)-&gt;counter, next = i; } if (c) break; for(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p) if (*p) (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; 1) + (*p)-&gt;priority; } switch_to(next);} schedule() 函数中，第一个for循环处理了很多信号的响应，这不是调度的重点（毕竟next代表选出的下一个要运行的进程，这一段还没有next相关的操作呢。。。）。 重点聚焦于 while (1) 循环，毕竟注释也写了，这是调度程序的主要部分。 下面的代码展示了调度策略，从任务数组的最后一个任务开始循环处理，跳过不含任务的数组槽。选择就绪任务中 counter 值最大的任务（说明），若有 counter 值不为0的结果或系统没有一个可运行任务（此时next为0）存在，则选择next对应进程进行切换。 12345678c = -1, next = 0, i = NR_TASKS, p = &amp;task[NR_TASKS];while (--i) { if (!*--p) continue; if ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c) c = (*p)-&gt;counter, next = i;}if (c) break; 若就绪任务中 counter 值全为0，则根据每个任务的优先权值更新每一个任务（全部任务，包含阻塞的）的 counter 值。 123for(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p) if (*p) (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; 1) + (*p)-&gt;priority; 从上面的式子也可以看出来，若某些任务一直执行 counter 调整，其 counter 值是趋向于 2 * (*p)-&gt;priority 的（级数，自己可以算一下）。 综上，schedule() 函数的行为为： 找 counter 值最大的任务调度， counter 表示了优先级。 counter 代表的优先级可以动态调整。 因为2的存在，阻塞的进程再就绪后，其优先级会高于非阻塞进程。阻塞是因为发生了I/O，而I/O则是前台进程的特征，所以该调度策略照顾了前台进程。 2 总结正如Linus Torvalds所说，这确实是个GOOD CODE！！！ 短短的一点代码实现的一个简单的算法，包含了优先级、时间片轮转等多种算法，解决了大多数任务的需求，大佬牛逼，给大佬打call！！！ 3 参考文献[1] Linux内核完全注释：基于0.11内核 · 赵烔 [2] 哈工大操作系统课程 · 李治军","link":"/2023/03/06/linux-linux0-11-sched/"},{"title":"Linux网络编程 - UDP发送&#x2F;接受数据","text":"UDP （User Datagram Protocol）：用户数据报协议。 UDP 是一个不可靠的通信协议，没有重传和确认，没有有序控制，也没有拥塞控制。可以简单地理解为，在 IP 报文的基础上，UDP 增加的能力有限。 UDP编程UDP中客户端和服务器端交互的图解： UDP Server : Create UDP socket. Bind the socket to server address. Wait until datagram packet arrives from client. Process the datagram packet and send a reply to client. Go back to Step 3. UDP Client : Create UDP socket. Send message to server. Wait until response from server is received. Process reply and go back to step 2, if necessary. Close socket descriptor and exit. 主要是使用以下函数： 1234567#include &lt;sys/socket.h&gt; ssize_t recvfrom(int sockfd, void *buff, size_t nbytes, int flags, struct sockaddr *from, socklen_t *addrlen); ssize_t sendto(int sockfd, const void *buff, size_t nbytes, int flags, const struct sockaddr *to, socklen_t *addrlen); recvfrom的参数含义： sockfd ：本地创建的套接字描述符 buff ：指向本地缓存的指针 nbytes ：最大接收数据字节 flags ：与 I/O 相关的参数 from 和 addrlen：返回对端发送方的地址和端口等信息 返回值：实际接收的字节数。 sendto的参数意义： sockfd ：本地创建的套接字描述符 buff ：指向本地缓存的指针 nbytes ：最大接收数据字节 flags ：与 I/O 相关的参数 to 和 addrlen，表示发送的对端地址和端口等信息。 UDP例子UDP Server: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// Server side implementation of UDP client-server model#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netinet/in.h&gt; #define PORT 8080#define MAXLINE 1024 // Driver codeint main() { int sockfd; char buffer[MAXLINE]; char sendbuffer[MAXLINE]; struct sockaddr_in servaddr, cliaddr; // Creating socket file descriptor if ( (sockfd = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0 ) { perror(&quot;socket creation failed&quot;); exit(EXIT_FAILURE); } memset(&amp;servaddr, 0, sizeof(servaddr)); memset(&amp;cliaddr, 0, sizeof(cliaddr)); // Filling server information servaddr.sin_family = AF_INET; // IPv4 servaddr.sin_addr.s_addr = INADDR_ANY; servaddr.sin_port = htons(PORT); // Bind the socket with the server address if ( bind(sockfd, (const struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0 ) { perror(&quot;bind failed&quot;); exit(EXIT_FAILURE); } int n; socklen_t len = (socklen_t)sizeof(cliaddr); //len is value/resuslt for (;;) { n = recvfrom(sockfd, (char *)buffer, MAXLINE, MSG_WAITALL, ( struct sockaddr *) &amp;cliaddr, &amp;len); buffer[n] = '\\0'; printf(&quot;Client : %s\\n&quot;, buffer); sprintf(sendbuffer, &quot;have recieve %d bytes&quot;, strlen(buffer)); sendto(sockfd, (const char *)sendbuffer, strlen(sendbuffer), 0, (const struct sockaddr *) &amp;cliaddr, len); fprintf(stdout, &quot;%s\\n&quot;, sendbuffer); } return 0;} UDP Client: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// Client side implementation of UDP client-server model#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netinet/in.h&gt;#define PORT 8080#define MAXLINE 1024 // Driver codeint main() { int sockfd; char buffer[MAXLINE]; char *hello = &quot;Hello from client&quot;; struct sockaddr_in servaddr; // Creating socket file descriptor if ( (sockfd = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0 ) { perror(&quot;socket creation failed&quot;); exit(EXIT_FAILURE); } memset(&amp;servaddr, 0, sizeof(servaddr)); // Filling server information servaddr.sin_family = AF_INET; servaddr.sin_port = htons(PORT); servaddr.sin_addr.s_addr = INADDR_ANY; socklen_t len = (socklen_t)sizeof(servaddr); //len is value/resuslt // send msg while (fgets(buffer, MAXLINE, stdin) != NULL) { int i = strlen(buffer); if (buffer[i - 1] == '\\n') { buffer[i - 1] = 0; } sendto(sockfd, (const char *)buffer, strlen(buffer), 0, (const struct sockaddr *) &amp;servaddr, len); fprintf(stdout, &quot;message: %s have sent.\\n&quot;, buffer); int n = recvfrom(sockfd, (char *)buffer, MAXLINE, MSG_WAITALL, (struct sockaddr *) &amp;servaddr, &amp;len); buffer[n] = '\\0'; printf(&quot;Server : %s\\n&quot;, buffer); } close(sockfd); return 0;} 情况1: 只运行客户端、不开启服务端可以看见，没有响应，也发送不了数据。程序会一直阻塞在 recvfrom 上。 情况2: 先开启服务端，再开启客户端 也可以使用多个UDP客户端去和UDP服务器端通信，不再细述。 总结 UDP 是无连接的数据报程序，和 TCP 不同，不需要三次握手建立一条连接。 UDP 程序通过 recvfrom 和 sendto 函数直接收发数据报报文。 reference[1] 极客时间 · 网络编程实战 ：06 | 嗨，别忘了UDP这个小兄弟 [2] UDP Server-Client implementation in C","link":"/2023/03/06/linux-network-udp/"},{"title":"POSIX信号量的使用","text":"1. 概述信号量分为有名信号量(named semaphore)，无名信号量(unnamed semaphore)。 (这里说的信号量主要是指semaphore.h中的信号量) 有名信号量由sem_open打开，无名信号量由sem_init打开. 有名信号量通过sem_unlink删除, 无名信号量通过sem_destroy删除信号量 有名信号量由内核持续，正是因此多个进程间才能利用它；无名信号量一般是线程之间使用，也可以搭配共享内存在多进程之间使用。 2. 函数原型12345678910111213141516171819#include &lt;semaphore.h&gt;// 有名信号量的操作sem_t *sem_open(const char *, int, ...);int sem_unlink(const char *);int sem_close(sem_t *);// 无名信号量的操作int sem_init(sem_t *, int, unsigned int);int sem_destroy(sem_t *);// 获取信号量值int sem_getvalue(sem_t *, int *);// 发出信号，即释放拥有权int sem_post(sem_t *);// 等待信号，即获取拥有权int sem_trywait(sem_t *);int sem_wait(sem_t *); 3. 用信号量解生产者-消费者问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;stdio.h&gt;#include &lt;semaphore.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#define NUMBER 50000#define CHILD 5#define BUFSIZE 10// critical resourceint fd;// semaphoresem_t* empty;sem_t* full;sem_t* mutex;void comsumer() { int buf_out = 0; int data = 0; int cnt = 0; for (int k = 0; k &lt; NUMBER / CHILD; k++) { sem_wait(full); sem_wait(mutex); // fetch buf_out lseek(fd, BUFSIZE * sizeof(int), SEEK_SET); read(fd, (char*)&amp;buf_out, sizeof(int)); cnt++; lseek(fd, sizeof(int) * buf_out, SEEK_SET); read(fd, (char*)&amp;data, sizeof(int)); printf(&quot;%d comsume %d %d\\n&quot;, getpid(), data, cnt); fflush(stdout); // write back buf_out = (buf_out + 1) % BUFSIZE; lseek(fd, BUFSIZE * sizeof(int), SEEK_SET); write(fd, (char *)&amp;buf_out, sizeof(int)); sem_post(mutex); sem_post(empty); } printf(&quot;%d total consume %d\\n&quot;, getpid(), cnt);}void producer() { int buf_in = 0; for (int i = 0 ; i &lt; NUMBER; i++) { sem_wait(empty); sem_wait(mutex); lseek(fd, buf_in * sizeof(int), SEEK_SET); write(fd, (char*)&amp;i, sizeof(int)); buf_in = (buf_in + 1) % BUFSIZE; printf(&quot;produce %d\\n&quot;, i); fflush(stdout); sem_post(mutex); sem_post(full); }}int main() { mutex = sem_open(&quot;mutex&quot;, O_CREAT | O_EXCL, 0644, 1); full = sem_open(&quot;full&quot;, O_CREAT | O_EXCL, 0644, 0); empty = sem_open(&quot;empty&quot;, O_CREAT | O_EXCL, 0644, BUFSIZE); int out_index = 0; fd = open(&quot;buffer.dat&quot;, O_CREAT | O_RDWR | O_TRUNC, 0666); lseek(fd, BUFSIZE * sizeof(int), SEEK_SET); write(fd, (char *)&amp;(out_index), sizeof(int)); pid_t p; // create producer if ((p = fork()) == 0) { producer(); return 0; } else if (p &lt; 0){ printf(&quot;Fail to fork!\\n&quot;); return -1; } // create comsumer for (int j = 0; j &lt; CHILD ; j++) { if ((p = fork()) == 0) { comsumer(); return 0; } else if (p &lt; 0) { printf(&quot;Fail to fork!\\n&quot;); return -1; } } int cnt = 0; printf(&quot;wait children!\\n&quot;); pid_t pid; while (pid = waitpid(-1, NULL, 0)) { if (errno == ECHILD) { break; } cnt ++; printf(&quot;pid: %d end | sum: %d\\n&quot;, pid, cnt); } sem_unlink(&quot;empty&quot;); sem_unlink(&quot;full&quot;); sem_unlink(&quot;mutex&quot;); return 0;} 编译命令： 1g++ pcc.c -o test -lpthread 参考资料[1] 信号量 [2] semaphore.h","link":"/2023/03/06/linux-posix-semaphore/"},{"title":"UNIX环境高级编程 - 信号量","text":"1. 概述信号量一个计数器，用于多进程对共享数据对象的存取。 P操作： 为了获得共享资源，进程需要执行下列操作: 测试控制该资源的信号量。 若此信号量的值为正，则进程可以使用该资源。进程将信号量值减1，表示它使用了一个资源单位。 若此信号量的值为0，则进程进入睡眠状态，直至信号量值大于0。若进程被唤醒后，它返回至第1步。 V操作： 当进程不再使用由一个信息量控制的共享资源时，该信号量值增1。如果有进程正在睡眠等待此信号量，则唤醒它们。 为了正确地实现信息量，信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的。 2. 获取信号量当使用XSI信号量时，首先需要通过调用函数 semget 来获得一个信号量ID。 123456#include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/sem.h&gt;int semget(key_t key, int nsems, int flag); 返回值：若成功，返回信号量ID；若出错，返回-1 nsems是该集合中的信号量数。如果是创建新集合(一般在服务器中)，则必须指定nsems。如果引用一个现存的集合(一个客户机)，则将nsems指定为0。 3. 信号量基本操作semctl 函数包含了多种信号量操作。 123456789101112#include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/sem.h&gt;int semctl(int semid, int semum, int cmd, . . . /* union semun arg */);union semun { int val; /* value for SETVAL */ struct semid_ds *buf; /* buffer for IPC_STAT &amp; IPC_SET */ u_short *array; /* array for GETALL &amp; SETALL */}; 对于除GETALL以外的所有GET命令，semctl函数都返回相应值。其他命令的返回值为0。 宏定义 作用 IPC_STAT 对此集合取semid_ds结构，并存储在由arg.buf指向的结构中。 IPC_SET 按arg.buf指向的结构中的值设置集合相关结构体中的相关成员。 IPC_RMID 从系统中删除该信号量集合。 GETVAL 返回成员semnum的semval值。 SETVAL 设置成员semnum的semval值。该值由arg.val指定。 GETPID 返回成员semnum的sempid的值。 GETNCNT 返回成员semnum的semncnt值 GETZCNT 返回成员semnum的semzcnt值。 GETALL 返回该集合中的所有的信号量值。 SETALL 将该集合中的所有的信号量设置成arg.array指向的数组中的值。 4. 信号量PV操作函数semop自动执行信号量集合上的操作数组。 123456789101112#include &lt;sys/types.h&gt; #include &lt;sys/ipc.h&gt; #include &lt;sys/sem.h&gt;int semop(int semid, struct sembuf semoparray[ ], size_t nops); 返回值：若成功，返回信号量ID；若出错，返回-1 struct sembuf { unsigned short sem_num; /* member # in set (0, 1, …, nsems-1) */ short sem_op; /* operation (negative, 0, or positive) */ short sem_flg; /* IPC_NOWAIT, SEM_UNDO */}; 参数nops规定该数组中操作的数量（元素数）。 对集合中的每个成员的操作由相应的sem_op值规定。此值可以是负值、0或者是正值。 若sem_op为正值，则对应于进程释放占用的资源数。 若sem_op为负值，则表示要获得由该信号量控制的资源。 5. 包装（warp function）对相关api包装一下可以更加通用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748bool sem_get(const key_t key, int *sem_id) { *sem_id = semget((key_t)key, 1, 0666 | IPC_CREAT); if (*sem_id == -1) { printf(&quot;sem_get fail!\\n&quot;); return false; } return true;}bool sem_init(const int sem_id, const int val) { if (semctl(sem_id, 0, SETVAL, val) == -1) { printf(&quot;sem_init fail!\\n&quot;); return false; } return true;}bool sem_unlink(const int sem_id) { if (semctl(sem_id, 0, IPC_RMID, sem_id) == -1) { printf(&quot;sem_unlink fail!\\n&quot;); return false; } return true;}bool sem_wait(int sem_id) { struct sembuf buf; buf.sem_num = 0; buf.sem_op = -1; buf.sem_flg = 0; if(semop(sem_id, &amp;buf, 1) == -1) { printf(&quot;sem_wait fail! %d\\n&quot;, errno); return false; } return true;}bool sem_post(int sem_id) { struct sembuf buf; buf.sem_num = 0; buf.sem_op = +1; buf.sem_flg = 0; if(semop(sem_id, &amp;buf, 1) == -1) { printf(&quot;sem_post fail! %d\\n&quot;, errno); return false; } return true;} 6. 例子：用信号量解生产者-消费者模型生产者-消费者问题可以用信号量如下解决： 例子使用上述的warp函数，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195#include &lt;stdbool.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;#include &lt;sys/wait.h&gt; #include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#define NUMBER 50000#define CHILD 5#define BUFSIZE 10bool sem_get(const key_t key, int* sem_id);bool sem_init(const int sem_id, const int val);bool sem_unlink(const int sem_id);bool sem_wait(const int semid); // Pbool sem_post(const int semid); // V#define IS_ERROR(ret) \\ do { \\ if (!ret) { \\ exit(0); \\ } \\ } while(0); \\// critical resourceint fd;// semaphoreint empty = -1;int full = -1;int mutex = -1;void comsumer() { int buf_out = 0; int data = 0; int cnt = 0; for (int k = 0; k &lt; NUMBER / CHILD; k++) { sem_wait(full); sem_wait(mutex); // fetch buf_out lseek(fd, BUFSIZE * sizeof(int), SEEK_SET); read(fd, (char*)&amp;buf_out, sizeof(int)); cnt++; lseek(fd, sizeof(int) * buf_out, SEEK_SET); read(fd, (char*)&amp;data, sizeof(int)); printf(&quot;%d comsume %d %d\\n&quot;, getpid(), data, cnt); fflush(stdout); // write back buf_out = (buf_out + 1) % BUFSIZE; lseek(fd, BUFSIZE * sizeof(int), SEEK_SET); write(fd, (char *)&amp;buf_out, sizeof(int)); sem_post(mutex); sem_post(empty); } printf(&quot;%d total consume %d\\n&quot;, getpid(), cnt);}void producer() { int buf_in = 0; for (int i = 0 ; i &lt; NUMBER; i++) { sem_wait(empty); sem_wait(mutex); lseek(fd, buf_in * sizeof(int), SEEK_SET); write(fd, (char*)&amp;i, sizeof(int)); buf_in = (buf_in + 1) % BUFSIZE; printf(&quot;produce %d\\n&quot;, i); fflush(stdout); sem_post(mutex); sem_post(full); }}int main() { int ret = sem_get(123, &amp;empty); IS_ERROR(ret); ret = sem_get(234, &amp;full); IS_ERROR(ret); ret = sem_get(345, &amp;mutex); IS_ERROR(ret); ret = sem_init(empty, BUFSIZE); IS_ERROR(ret); ret = sem_init(full, 0); IS_ERROR(ret); ret = sem_init(mutex, 1); IS_ERROR(ret); int out_index = 0; fd = open(&quot;buffer.dat&quot;, O_CREAT | O_RDWR | O_TRUNC, 0666); lseek(fd, BUFSIZE * sizeof(int), SEEK_SET); write(fd, (char *)&amp;(out_index), sizeof(int)); pid_t p; // create producer if((p = fork()) == 0) { producer(); return 0; } else if(p &lt; 0){ printf(&quot;Fail to fork!\\n&quot;); return -1; } // create comsumer for(int j = 0; j &lt; CHILD ; j++) { if((p = fork()) == 0) { comsumer(); return 0; } else if(p &lt; 0) { printf(&quot;Fail to fork!\\n&quot;); return -1; } } int cnt = 0; printf(&quot;wait children!\\n&quot;); pid_t pid; while (pid = waitpid(-1, NULL, 0)) { if (errno == ECHILD) { break; } cnt ++; printf(&quot;pid: %d end | sum: %d\\n&quot;, pid, cnt); } ret = sem_unlink(empty); IS_ERROR(ret); ret = sem_unlink(full); IS_ERROR(ret); ret = sem_unlink(mutex); IS_ERROR(ret); return 0;}bool sem_get(const key_t key, int *sem_id) { *sem_id = semget((key_t)key, 1, 0666 | IPC_CREAT); if (*sem_id == -1) { printf(&quot;sem_get fail!\\n&quot;); return false; } return true;}bool sem_init(const int sem_id, const int val) { if (semctl(sem_id, 0, SETVAL, val) == -1) { printf(&quot;sem_init fail!\\n&quot;); return false; } return true;}bool sem_unlink(const int sem_id) { if (semctl(sem_id, 0, IPC_RMID, sem_id) == -1) { printf(&quot;sem_unlink fail!\\n&quot;); return false; } return true;}bool sem_wait(int sem_id) { struct sembuf buf; buf.sem_num = 0; buf.sem_op = -1; buf.sem_flg = 0; if(semop(sem_id, &amp;buf, 1) == -1) { printf(&quot;sem_wait fail! %d\\n&quot;, errno); return false; } return true;}bool sem_post(int sem_id) { struct sembuf buf; buf.sem_num = 0; buf.sem_op = +1; buf.sem_flg = 0; if(semop(sem_id, &amp;buf, 1) == -1) { printf(&quot;sem_post fail! %d\\n&quot;, errno); return false; } return true;}","link":"/2023/03/06/linux-semaphore/"},{"title":"UNIX环境高级编程 - 共享内存","text":"0. 概述共享内存允许两个或多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会成为一个进程用户空间内存的一部分，因此这种IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。 为使用一个共享内存段通常需要执行下面的步骤。 调用 shmget()创建一个新共享内存段或取得一个既有共享内存段的标识符（即由其他进程创建的共享内存段）。这个调用将返回后续调用中需要用到的共享内存标识符。 使用 shmat()来附上共享内存段，即使该段成为调用进程的虚拟内存的一部分。 此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 shmat()调用返回的 addr 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。 1. System V 共享内存相关API12345678#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int semget(key_t key, int size, int flag);void *shmat(int shmid, void *addr, int flag);int shmdt(void *addr);int shmctl(int shmid, int cmd, struct shmid_ds *buf); shmget获得或创建一个共享内存标识符。 12int semget(key_t key, size_t size, int shmflag);// 成功返回一个共享内存标识符，失败返回－1； 第一个参数key为共享内存段命名； 第二个参数size为需要共享的内存容量。（如果共享内存已存在时，不能不大于该共享内存段的大小）； 第三个参数设置访问权限(低9位）与IPC_CREAT, IPC_EXCL 的按位或。 shmat将共享内存段连接到一个进程的地址空间中。 12void *shmat(int shm_id, const void *addr, int shmflg) ;// 成功返回共享存储段连接的实际地址，失败返回-1 第一个参数shm_id为shmget返回的共享内存标识符。 第二个参数addr指明共享内存段要连接到的地址（进程空间内部地址），通常指定为空指针(NULL)，表示让系统来选择共享内存在进程地址空间中出现的地址。 第三个参数shmflg可以设置为两个标志位（通常设置为0） SHM_RND（ 表示第二个参数指定的地址应被向下靠拢到内存页面大小的整数倍） SHM_RDONLY，要连接的共享内存段是只读的。 shmdt将共享内存从当前进程中分离。 1int shmdt(const void *shmaddr) ; //其中shmaddr为shmat返回的地址。 shmctl查看及修改共享内存段的shmid_ds结构，删除该结构以及相连的共享存储段标识。 12int shmctl(int shm_id, int command, struct shmid_ds *buf) ; // 成功返回0，失败返回-1 第一个参数shm_id为shmget返回的共享内存标识符。 第二个参数commad取值： IPC_STAT 获取当前共享内存段的shmid_ds结构 IPC_SET 把共享内存段的当前关联值设置为shmid_ds结构给出的值 IPC_RMID 从系统中删除该共享存储段。 第三个参数buf是一个结构指针，它指向共享内存模式和访问权限的结构 123456struct shmid_ds { uid_t shm_perm.uid; uid_t shm_perm.gid; mode_t shm_perm.mode; }; 2. 例子-生产者-消费者问题使用共享内存充当生产者-消费者问题的缓冲区。 生产者：producer.c 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;stdio.h&gt;#include &lt;semaphore.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;stdlib.h&gt;#define NUMBER 300#define BUFSIZE 10// critical resourceint* buffer;// semaphoresem_t* empty;sem_t* full;sem_t* mutex;void producer() { int buf_in = 0; for (int i = 0 ; i &lt; NUMBER; i++) { sem_wait(empty); sem_wait(mutex); buffer[buf_in] = i; buf_in = (buf_in + 1) % BUFSIZE; printf(&quot;produce %d\\n&quot;, i); fflush(stdout); sem_post(mutex); sem_post(full); }}void quitHandler(int i) { sem_unlink(&quot;empty&quot;); sem_unlink(&quot;full&quot;); sem_unlink(&quot;mutex&quot;); exit(-1);}int main() { signal(SIGINT, quitHandler); mutex = sem_open(&quot;mutex&quot;, O_CREAT , 0644, 1); full = sem_open(&quot;full&quot;, O_CREAT, 0644, 0); empty = sem_open(&quot;empty&quot;, O_CREAT, 0644, BUFSIZE); if (mutex == NULL || full == NULL || empty == NULL) { printf(&quot;error in sem_open %p %p %p\\n&quot;, mutex, full, empty); return -1; } int shmid = shmget((key_t)1121, sizeof(int) * BUFSIZE, 0666 | IPC_CREAT); void* shm = shmat(shmid, 0, 0); buffer = (int*)shm; producer(); sem_unlink(&quot;empty&quot;); sem_unlink(&quot;full&quot;); sem_unlink(&quot;mutex&quot;); return 0;} 消费者：consumer.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;stdio.h&gt;#include &lt;semaphore.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;stdlib.h&gt;#define NUMBER 300#define BUFSIZE 10// critical resourceint* buffer = NULL;// semaphoresem_t* empty;sem_t* full;sem_t* mutex;void consumer() { int buf_out = 0; int data = 0; for (int k = 0; k &lt; NUMBER; k++) { sem_wait(full); sem_wait(mutex); data = buffer[buf_out]; printf(&quot;comsume %d\\n&quot;, data); buf_out = (buf_out + 1) % BUFSIZE; fflush(stdout); sem_post(mutex); sem_post(empty); }}void quitHandler(int i) { sem_unlink(&quot;empty&quot;); sem_unlink(&quot;full&quot;); sem_unlink(&quot;mutex&quot;); exit(-1);}int main() { signal(SIGINT, quitHandler); mutex = sem_open(&quot;mutex&quot;, O_CREAT, 0644, 1); full = sem_open(&quot;full&quot;, O_CREAT, 0644, 0); empty = sem_open(&quot;empty&quot;, O_CREAT , 0644, BUFSIZE); if (mutex == NULL || full == NULL || empty == NULL) { printf(&quot;error in sem_open %p %p %p\\n&quot;, mutex, full, empty); return -1; } int shmid = shmget((key_t)1121, sizeof(int) * BUFSIZE, 0666 | IPC_CREAT); if (shmid == -1) { exit(-1); } void* shm = shmat(shmid, 0, 0); buffer = (int*)shm; consumer(); sem_unlink(&quot;empty&quot;); sem_unlink(&quot;full&quot;); sem_unlink(&quot;mutex&quot;); return 0;} 编译命令： 12gcc consumer.c -o comsumer -lpthreadgcc consumer.c -o consumer -lpthread 让消费者先在后台执行，执行命令： 12./consumer &amp;./producer 如何杀后台任务？ 12jobs -lkill -9 pid","link":"/2023/03/06/linux-shared-memory/"},{"title":"shell中的set -e &amp; set -u","text":"set -e: 表示此命令后，当某命令返回值非0时，将出错。如果是非交互环境，将直接退出，不再执行后续命令set +e: set -e的反向操作，恢复bash shell的默认行为，命令失败后继续执行后续命令 set -u: (set -o nounset), 表示此命令之后，当某命令使用了未定义变量或参数时（特殊参数“@”和“*”除外），将打印错误信息。如果是非交互环境（通常为脚本中），将直接退出，不再执行后续命令set +u: set -u的反向操作，恢复bash shell的默认行为，命令使用未定义变量或参数时，继续执行后续命令","link":"/2023/03/06/linux-shell-set/"},{"title":"UNIX环境高级编程 - UNIX基础知识","text":"所有操作系统都为运行在它之上的程序提供各种服务，典型的服务包括：执行新程序、打开文件、读写文件、分配存储空间、提供时间等。 UNIX体系结构严格来说，操作系统是一种软件，它控制计算机硬件资源，提供程序运行环境。这种软件有个专业术语名称：内核。因为它小且位于计算机体系的核心。如下图所示： 内核的接口为系统调用，系统调用包裹在内核的外围，隔离开内核以保护内核。同时，系统调用作为和内核沟通的中间桥梁。 公用函数库通常指的是C/C++的标准库，例如libc、glibc、libstdc++、libc++等标准库，不同的标准库是由于不同的系统平台或编译器厂商造成的差异，但追根究底都是使用了底层系统内核的API接口系统调用。这些公用函数库极大的方便了上层开发者的使用，也是整个计算机软件体系（无论任何编程语言）的基础。 shell也是一个软件，该软件负责人机交互，用户和shell进行“对话”，然后shell理解用户的意图来使计算机按用户的想法工作。 用户程序也可以直接使用系统调用来请求服务。 对于打印hello world于终端中，对于上面三种请求服务的方式，有： printf(&quot;hello world&quot;); echo 'hello world' 直接使用write() 登录用户名和shell由配置文件/etc/passwd决定，密码由配置文件/etc/shadow决定。 口令文件中的登录项由 : 分隔的7个字段组成： 登录名 加密口令 用户ID（数字） 组ID（数字） 注释字段 起始目录 shell程序 例如，我电脑Mac OSX中就有： 1root:*:0:0:System Administrator:/var/root:/bin/sh 文件系统UNIX文件系统是目录和文件的一种层次结构。所有东西的起点称为根目录，即“/”。 在文件系统中，目录本质上也是一个文件，其内容是目录项的记录。每个目录项都是一个文件名，还包含一些文件属性的说明信息，比如权限、大小、时间等。 创建新目录时文件系统会自动创建两个文件夹：.（点）和 ..（点点）， .（点）表示当前目录，根目录“/”下的.（点）和 ..（点点）是同一个路径，都是“/”。 由斜线“/”开头的路径都是绝对路径，反之则是相对路径。 ls(1) ls(1)指的是第一部分的ls项目，UNIX命令通常都会有一个说明手册，手册中对命令有详细说明，但随着命令功能和说明的增加，说明手册页数越来越多，之后便对命令进行了分门别类，通常是1-8总共8中分类，具体是： 1、Standard commands （标准命令）2、System calls （系统调用）3、Library functions （库函数）4、Special devices （设备说明）5、File formats （文件格式）6、Games and toys （游戏和娱乐）7、Miscellaneous （杂项）8、Administrative Commands （管理员命令） 工作目录：每个进程都有一个工作目录，一般称为当前工作目录，进程可以用chdir来更改其工作目录。 起始目录：登录时，shell程序的工作目录设置为home目录，该目录通常从/etc/passwd配置文件中获得。 输入和输出在UNIX系统中输入和输出是经过抽象的，所有的输入和输出底层系统实现都是通过文件抽象来完成的。 文件描述符：文字描述符是一个小的非负整数，内核用以标识一个特定进程正在存访的文件。当内核打 开一个现存文件或创建一个新文件时，它就返回一个文件描述符。当读、写文件时，就可使 用它。 每个程序都有默认打开的三个文件描述符： 标准输入 - fd为0 标准输出 - fd为1 标准出错 - fd为2 不带缓存的I/O：系统调用open、read、write、lseek、close，它们都使用文件描述符来操作文件，并且不带缓冲。 标准I/O：公用函数库提供的封装过的接口来间接调用系统调用，公用函数库提供的接口是带缓冲的，且无需考虑对缓冲区大小的选择。例如使用printf输出。 程序和进程程序是静态的进程，而进程是运行着的程序。程序本质上是一个存在硬盘上的可执行文件。程序被加载到内存中之后就开始执行，此时程序变成一个动态刻画抽象的进程。 进程ID：每一个进程都有一个标识符，称为进程ID，其是一个非负数，且在当前时刻是唯一的。 进程控制：有3个可以用于控制进程的系统调用：fork、exec和waitpid。其中exec是一系列函数的统称。 线程和线程ID： 一个进程内的所有线程共享当前进程的所有内存空间、文件描述符号、栈以及进程相关的属性。由于所有进程共享进程的内存空间，因此在访问共享数据时需要采取同步措施以避免数据的不一致。 同进程类似，线程也有一个ID唯一标识每一个线程，但线程的ID只在进程内部有效，进程外部则无意义。 出错处理当 UNIX 系统函数出错时，通常会返回一个负值，同时整型变量 errno 通常被设置为具有特定信息的值。 文件 &lt;errno.h&gt; 定义了 errno 以及赋予它的各种常量，这些常量以 E 字符开头 在多线程环境中，每个线程都有属于自己的局部 errno，以避免一个线程干扰另一个线程。 对于 errno 的使用要注意两条规则： 如果没有出错，则 errno 的值不会被清除.因此只有在函数的返回值指明出错了时，检查 errno 才有意义 任何函数都不会将 errno 的值清零，且在 &lt;errno.h&gt; 中定义的所有常量都不为0 strerror/perror函数:用于处理错误信息 12345#include&lt;string.h&gt;char *strerror(int errnum);#include&lt;stdio.h&gt;void perror(const char*msg); strerror: 将 errnum（通常就是 errno 值）映射为一个出错消息字符串，并且返回此字符串的指针 参数： 一个整数（通常是 errno 的值） 返回： 出错消息字符串的指针 perror: 基于 errno 的当前值，在标准错误上产生一条出错消息，然后返回。这条出错消息首先是 msg 指向的字符串，后面是冒号，后面是一个空格，后面是对应于 errno 值的出错消息，最后是一个换行符。 参数：附加的出错消息 返回：无返回。但是向标准错误上输出一条出错消息。 用户标识用户ID：用户标识也是通过ID来进行区分的，该ID称为用户ID，它是一个数字。当一个用户创建时，会在/etc/passwd文件中生成唯一的用户ID，用户不能更改这个ID，除非是root用户才允许修改。ID号码为0的用户是root用户。 组ID：用户除了用ID来进行区分，也用组来进行划分管理，相应的，其也有组ID，也是一个数字。用户的组用户ID不唯一，一个用户可以拥有多个组ID，这表明该用户加入了多个小组。组的目的是为了让多个用户共享一个资源。组相关的配置文件是/etc/group。 可以通过 getuid( ) 和 getgid( ) 函数来获得相应的用户ID和组ID。 信号信号是UNIX系统用于发送通知的一种机制，例如，若某一进程执行除法操作，其除数为0，则将名为SIGFPE的信号发送给该进程。进程收到信号通知后，有3种应对处理方法： 忽略信号。收到之后什么也不做，当做未发生一样。 按系统默认方式处理。对于除0，系统默认方式是终止该进程。 提供一个处理函数。在收到信号之后，用提供的函数来进行处理。 使用Kill -9 杀死进程 ctrl + c 中断进程 ctrl + / 退出进程 时间值UNIX 系统使用两种时间： 日历时间：自 UTC 1970年1月1日 00:00:00 以来经历过的秒数累计值。用 time_t数据类型来保存这种时间值。 进程时间：也称作CPU时间，用于度量进程使用的CPU资源。进程时间以时间滴答来计算，用clock_t数据类型保存这种时间值。 当度量一个进程的执行时间时，UNIX系统为一个进程维护了3个进程时间值： 时钟时间： 又称作墙上时钟时间，是进程运行的时间总量，其值与系统中同时运行的进程数有关 用户CPU时间：执行用户指令所用的时间量 系统CPU时间：该进程执行内核程序所经历的时间。如进程执行一个read系统调用，则内核执行该系统调用的时间计入系统 CPU 时间 用户CPU时间和系统CPU时间之和称作 CPU 时间 系统调用和库函数所有的UNIX系统都提供多种服务的入口点，由此程序可以向内核请求服务。各种UNIX都提供了良好定义、数量有限、直接进入内核的入口点。这些入口点被称为系统调用。 系统调用接口在man手册的第二部分中说明，是使用C语言定义的。 公用函数库接口在man手册的第三部分中说明，也是使用C语言定义的。它们不一定是内核的入口点，部分会间接使用一个或多个内核系统调用，而有些则完全不使用。 从实现角度看，系统调用和公用函数库有着本质区别，一个是伴随内核而产生的，是不可替换的。另一个是编译器厂商根据语言标准而实现的，可以更新和替换。但从用户角度看，它们没有太大区别，显著的区别是公用函数库更好用，功能更加强。","link":"/2023/03/06/linux-unix-base/"},{"title":"mit6.824 - MapReduce极简实现","text":"0 概述MapReduce是一种广泛运用的分布式-大数据计算编程模型，最初由Google发表，其开源实现为Hadoop。 MapReduce 的编程模型非常简单，正如名字一样，用户仅仅需要实现一个 Map 函数，一个 Reduce 函数。 Map 函数，即映射函数：它会接受一个 key-value 对，然后把这个 key-value 对转换成 0 到多个新的 key-value 对并输出出去。 1map (k1, v1) -&gt; list (k2, v2) Reduce 函数，即化简函数：它接受一个 Key，以及这个 Key 下的一组 Value，然后化简成一组新的值 Value 输出出去。 1reduce (k2, list(v2)) -&gt; list(v3) 可以解决的任务例子： 分布式 grep； 统计 URL 的访问频次； 反转网页 - 链接图； 分域名的词向量； 生成倒排索引； 分布式排序。 1 MapReduce结构一图胜千言： 2 总体设计以完成6.8242021Spring的lab1为目标。 可以通过以下git命令：clone代码： 1git clone git://g.csail.mit.edu/6.824-golabs-2021 6.824 master采用lazy分配任务方法，由worker主动去触发任务分配、任务结束等操作。master分配不同的块给不同的worker执行。 因此worker需要实现获取任务，任务结束等RPC，代码如下： 12345678910111213141516171819type GetTaskArgs struct {}type GetTaskReply struct { Type TaskType Filenames []string Task_no int NReduce int Err Errno}type FinishTaskArgs struct { Type TaskType Task_no int}type FinishTaskReply struct { Err Errno} 3 worker设计worker的工作就是不断获取任务，若任务完成则提交之。 其主要代码为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354func Worker(mapf func(string, string) []KeyValue, reducef func(string, []string) string) { // Your worker implementation here. for { args := GetTaskArgs{} reply := GetTaskReply{} log.Printf(&quot;get task request: %v\\n&quot;, args) ok := CallGetTask(&amp;args, &amp;reply) log.Printf(&quot;recv get task reply: %v\\n&quot;, reply) if !ok || reply.Type == STOP { break } // handle map fynction switch reply.Type { case MAP: if len(reply.Filenames) &lt; 1 { log.Fatalf(&quot;don't have filename&quot;) } DoMAP(reply.Filenames[0], reply.Task_no, reply.NReduce, mapf) // map complete, send msg to master finish_args := FinishTaskArgs{ Type: MAP, Task_no: reply.Task_no, } finish_reply := FinishTaskReply{} log.Printf(&quot;finish request: %v\\n&quot;, finish_args) CallFinishTask(&amp;finish_args, &amp;finish_reply) log.Printf(&quot;recv finish reply: %v\\n&quot;, finish_reply) // time.Sleep(time.Second) case REDUCE: if len(reply.Filenames) &lt; 1 { log.Fatalf(&quot;don't have filenames&quot;) } DoReduce(reply.Filenames, reply.Task_no, reducef) // reduce complete, send msg to master finish_args := FinishTaskArgs{ Type: REDUCE, Task_no: reply.Task_no, } finish_reply := FinishTaskReply{} log.Printf(&quot;finish request: %v\\n&quot;, finish_args) CallFinishTask(&amp;finish_args, &amp;finish_reply) log.Printf(&quot;recv finish reply: %v\\n&quot;, finish_reply) // time.Sleep(time.Second) case WAIT: log.Printf(&quot;wait task\\n&quot;) time.Sleep(time.Second) default: time.Sleep(time.Second) } }} 其中分MAP、REDUCE、WAIT和STOP四个状态： MAP：进行MAP操作 REDUCE：进行REDECE操作 WAIT：等待其他worker完成任务（比如等待在总体MAP任务的收尾上，以及没有更多的MAP任务可以分配了） STOP：worker停止、退出 其中最重要的为map和reduce任务的执行。 map任务的执行实现代码如下：（对应上图中的2、3、4步） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func DoMAP(filename string, task_no int, nReduce int, mapf func(string, string) []KeyValue) { file, err := os.Open(filename) if err != nil { log.Fatalf(&quot;cannot open %v&quot;, filename) } content, err := ioutil.ReadAll(file) if err != nil { log.Fatalf(&quot;cannot read %v&quot;, filename) } file.Close() kva := mapf(filename, string(content)) sort.Sort(ByKey(kva)) log.Println(&quot;encode to json&quot;) files := make([]*os.File, nReduce) encoders := make([]*json.Encoder, nReduce) for i := 0; i &lt; nReduce; i++ { ofile, err := ioutil.TempFile(&quot;&quot;, &quot;mr-tmp*&quot;) if err != nil { log.Fatalf(&quot;cannot create temp file&quot;) } defer ofile.Close() encoder := json.NewEncoder(ofile) encoders[i] = encoder files[i] = ofile } var index int for _, kv := range kva { index = ihash(kv.Key) % nReduce err = encoders[index].Encode(&amp;kv) if err != nil { log.Fatalf(&quot;cannot encode %v&quot;, kv) } } // atomically rename for i := 0; i &lt; nReduce; i++ { filename_tmp := fmt.Sprintf(&quot;mr-%d-%d&quot;, task_no, i) err := os.Rename(files[i].Name(), filename_tmp) if err != nil { log.Fatalf(&quot;cannot rename %v to %v&quot;, files[i].Name(), filename_tmp) } }} 比较有意思的是map需要通过一个hash函数将相同的条目分布在同一输出文件中： 1234567891011121314func ihash(key string) int { h := fnv.New32a() h.Write([]byte(key)) return int(h.Sum32() &amp; 0x7fffffff)}var index intfor _, kv := range kva { index = ihash(kv.Key) % nReduce err = encoders[index].Encode(&amp;kv) if err != nil { log.Fatalf(&quot;cannot encode %v&quot;, kv) }} reduce任务的执行实现代码如下：（对应上图中的5、6步） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354func DoReduce(filenames []string, task_no int, reducef func(string, []string) string) { // read data from mid-file kva := make([]KeyValue, 0) for _, filename := range filenames { file, err := os.Open(filename) if err != nil { log.Fatalf(&quot;cannot open %v&quot;, filename) } defer file.Close() dec := json.NewDecoder(file) for { var kv KeyValue if err := dec.Decode(&amp;kv); err != nil { break } kva = append(kva, kv) } } sort.Sort(ByKey(kva)) // call Reduce on each distinct key in kva[], // and print the result to mr-out-0. ofile, err := ioutil.TempFile(&quot;&quot;, &quot;mr-out-tmp*&quot;) if err != nil { log.Fatalf(&quot;cannot create temp file&quot;) } defer ofile.Close() i := 0 for i &lt; len(kva) { j := i + 1 for j &lt; len(kva) &amp;&amp; kva[j].Key == kva[i].Key { j++ } values := []string{} for k := i; k &lt; j; k++ { values = append(values, kva[k].Value) } output := reducef(kva[i].Key, values) // this is the correct format for each line of Reduce output. fmt.Fprintf(ofile, &quot;%v %v\\n&quot;, kva[i].Key, output) i = j } output_filename := fmt.Sprintf(&quot;mr-out-%d&quot;, task_no) err = os.Rename(ofile.Name(), output_filename) if err != nil { log.Fatalf(&quot;cannot rename %v to %v&quot;, ofile.Name(), output_filename) }} 按道理应该是要在GFS上读写文件的，条件不允许，就直接采用UNIX的文件系统了。 4 master设计master的设计还是比较简单的，只包含很少的信息： 1234567type Coordinator struct { tasks []Task nReduce int nMap int status CoordinatorStatus mu sync.Mutex} 对所需要进行的任务信息进行定义，如下： 1234567891011121314type TaskStatus intconst ( idle TaskStatus = iota in_progress completed)type Task struct { tno int filenames []string status TaskStatus startTime time.Time} 其主要就是接受worker的两个RPC请求。 获取任务的RPC handler实现如下： 对于长时间（10s）未完成的任务，重新制定一个worker执行此任务。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051func (c *Coordinator) GetTask(args *GetTaskArgs, reply *GetTaskReply) error { c.mu.Lock() defer c.mu.Unlock() finish_flag := c.IsAllFinish() if finish_flag { c.NextPhase() } for i := 0; i &lt; len(c.tasks); i++ { if c.tasks[i].status == idle { log.Printf(&quot;send task %d to worker\\n&quot;, i) reply.Err = SuccessCode reply.Task_no = i reply.Filenames = c.tasks[i].filenames if c.status == MAP_PHASE { reply.Type = MAP reply.NReduce = c.nReduce } else if c.status == REDUCE_PHASE { reply.NReduce = 0 reply.Type = REDUCE } else { log.Fatal(&quot;unexpected status&quot;) } c.tasks[i].startTime = time.Now() c.tasks[i].status = in_progress return nil } else if c.tasks[i].status == in_progress { curr := time.Now() if curr.Sub(c.tasks[i].startTime) &gt; time.Second*10 { log.Printf(&quot;resend task %d to worker\\n&quot;, i) reply.Err = SuccessCode reply.Task_no = i reply.Filenames = c.tasks[i].filenames if c.status == MAP_PHASE { reply.Type = MAP reply.NReduce = c.nReduce } else if c.status == REDUCE_PHASE { reply.NReduce = 0 reply.Type = REDUCE } else { log.Fatal(&quot;unexpected status&quot;) } c.tasks[i].startTime = time.Now() return nil } } } reply.Err = SuccessCode reply.Type = WAIT return nil} 完成任务的RPC handler实现如下： 12345678910111213func (c *Coordinator) FinishTask(args *FinishTaskArgs, reply *FinishTaskReply) error { c.mu.Lock() defer c.mu.Unlock() if args.Task_no &gt;= len(c.tasks) || args.Task_no &lt; 0 { reply.Err = ParaErrCode return nil } c.tasks[args.Task_no].status = completed if c.IsAllFinish() { c.NextPhase() } return nil} 检查全部任务是否完成，完成就进入下一个阶段： 123456789101112131415161718192021func (c *Coordinator) IsAllFinish() bool { for i := len(c.tasks) - 1; i &gt;= 0; i-- { if c.tasks[i].status != completed { return false } } return true}func (c *Coordinator) NextPhase() { if c.status == MAP_PHASE { log.Println(&quot;change to REDUCE_PHASE&quot;) c.MakeReduceTasks() c.status = REDUCE_PHASE } else if c.status == REDUCE_PHASE { log.Println(&quot;change to FINISH_PHASE&quot;) c.status = FINISH_PHASE } else { log.Println(&quot;unexpected status change!&quot;) }} 客户端查看MapReduce任务是否完成： 12345678func (c *Coordinator) Done() bool { c.mu.Lock() defer c.mu.Unlock() if c.status == FINISH_PHASE { return true } return false} 5 客户端如何使用呢？写两个函数（Map和Reduce）就行啦： 1234567891011121314151617181920212223242526272829303132//// The map function is called once for each file of input. The first// argument is the name of the input file, and the second is the// file's complete contents. You should ignore the input file name,// and look only at the contents argument. The return value is a slice// of key/value pairs.//func Map(filename string, contents string) []mr.KeyValue { // function to detect word separators. ff := func(r rune) bool { return !unicode.IsLetter(r) } // split contents into an array of words. words := strings.FieldsFunc(contents, ff) kva := []mr.KeyValue{} for _, w := range words { kv := mr.KeyValue{w, &quot;1&quot;} kva = append(kva, kv) } return kva}//// The reduce function is called once for each key generated by the// map tasks, with a list of all the values created for that key by// any map task.//func Reduce(key string, values []string) string { // return the number of occurrences of this word. return strconv.Itoa(len(values))} 6 附录详细代码可以参考： 仓库 commit","link":"/2023/03/06/mit6-824-mapreduce/"},{"title":"UNIX环境高级编程 - UNIX标准及实现","text":"在过去的近25年时间，人们为了UNIX的标准化做出了种种努力，这使得程序在不同版本的UNIX系统之间的移植相当容易。 UNIX标准化ISO C1989年，C语言首个标准得到批准，即C89。次年，一个带有小改动的版本标准被批准其为C90。因此，C89和C90通常指同一种语言。 在2000年三月，ANSI采纳了ISO/IEC 9899:1999标准，即C99。 在2011年12月，ANSI采纳了ISO/IEC 9899:2011标准，即C11，它是C程序语言的现行标准。 按照ISO C标准定义的头文件将C语言公用函数库划分成了24个部分。POSIX.1标准包括这些头文件以及一些额外的头文件。 IEEE POSIXPOSIX是由IEEE制订的一系列标准，其指的是可移植操作系统接口，它说明的是接口而不是实现。 POSIX.1标准包括ISO C标准库汗水(上图)以及一些额外的头文件（下图）。 Single UNIX SpecificationSingle UNIX Specification（SUS，单一UNIX规范），它是POSIX.1标准的一个超集，他定义了一些附加接口扩展POSIX.1规范提供的功能。 UNIX系统实现ISO C、IEEE POSIX、Single UNIX Specification是三个不同的组织，第一个组织负责对C语言进行标准化，后两个组织负责对UNIX系统接口进行标准化。 这三个组织制定了概念上的规范，但实现是由厂商进行的。几个知名实现发行版如下： SVR4：AT&amp;T实现 BSD：UCB实现 FreeBSD：开源（基于4.4BSD-Lite） Linux：Linus在1991年从Minix改写而来，开源 Mac OS X：Apple，又称Darwin系统 Solaris：SUN，基于SVR4 限制UNIX 系统实现定义了很多幻数和常量。有两种类型的限制是必须的： 编译时限制，如 short int 最大值是多少 通常编译时限制可以在头文件中定义；运行时限制则要求进程调用一个函数获得限制值。 运行时限制，如文件名最长多少个字符 某些限制在一个给定的 UNIX 实现中可能是固定的（由头文件定义），在另一个 UNIX 实现中可能是动态的（需要由进程调用一个函数获得限制值）。如文件名的最大字符数在不同的操作系统中，是属于动态/静态限制。因此提供了三种限制： 编译时限制（由头文件给定） 与文件或者目录无关的运行时限制（由 sysconf函数给定） 与文件或者目录相关的运行时限制（由 pathconf函数以及fpathconf函数给定） ISO C 限制ISO C 所有编译时限制都在头文件 &lt;limits.h&gt; 中,如整型大小。 这些限制常量在一个给定的操作系统中不会改变 关于浮点数的最大最小值的编译时限制，在&lt;float.h&gt;头文件中定义 &lt;stdio.h&gt; 头文件还定义了三个编译时限制： FOPEN_MAX：可同时打开的标准I/O 流限制的最小数 TMP_MAX：由tmpnam函数产生的唯一文件名的最大个数 FILENAME_MAX：虽然 ISO C 定义了该常量，但是要避免使用。而要用 POSIX 提供的 NAME_MAX和 PATH_MAX 常量 POSIX 限制POSIX定义了很多涉及操作系统实现限制的常量。这些常量大多数在&lt;limits.h&gt;中，也有的按照具体条件定义在其他头文件中。 获取运行时限制123456#include&lt;unistd.h&gt;long sysconf(int name); long pathconf(const char*pathname,int name);long fpathconf(int fd,int name); // 若成功，返回相应值；若出错，返回-1 参数： name：指定的限制值。name参数是系统定义的常量 以 _SC_开头的常量用于 sysconf函数 以 -PC_开头的常量用于pathconf和fpathconf函数 pathname：文件名 fd：打开文件的文件描述符 失败的情况： 若name参数并不是一个合适的常量，则这三个函数返回-1，并将 errno设置为 EINVAL 有些name会返回一个不确定的值，这通过返回 -1 来体现，同时不改变errno","link":"/2023/03/06/linux-unix-standard/"},{"title":"mit6.S081 - Xv6 and Unix utilities","text":"sleep Implement the UNIX program sleep for xv6; your sleep should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file user/sleep.c. 描述：实现一个提供sleep功能的unix程序。 解决思路：系统已经实现了sleep函数，直接调用即可。 代码： 12345678910111213141516171819#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;intmain(int argc, char *argv[]){ int ticks_num; if(argc != 2){ fprintf(2, &quot;Usage: sleep times\\n&quot;); exit(1); } ticks_num = atoi(argv[1]); sleep(ticks_num); exit(0);} pingpong Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “: received ping”, where is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “: received pong”, and exit. Your solution should be in the file user/pingpong.c. 描述：使用管道（pipe）实现ping-pong（即使用pipe实现父进程子进程之间的通信） 解决思路：fork + pipe + write/read即可，比较简单，要注意pipe会创建两个fd（读/写），fork后子进程会继承文件描述符。 代码： 12345678910111213141516171819202122232425262728#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;intmain(int argc, char *argv[]){ int p[2]; // read, write char buf[2]; if(argc != 1){ fprintf(2, &quot;Usage: pingpong\\n&quot;); exit(1); } pipe(p); if (fork() == 0) { // child read(p[0], buf, 1); fprintf(1, &quot;%d: received ping\\n&quot;, getpid()); write(p[1], &quot;c&quot;, 1); exit(0); } else { // father write(p[1], &quot;c&quot;, 1); read(p[0], buf, 1); fprintf(1, &quot;%d: received pong\\n&quot;, getpid()); } exit(0);} primes Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down this page and the surrounding text explain how to do it. Your solution should be in the file user/primes.c. 描述：使用pipe实现素数筛。 解决思路：父进程产生2-35的数，然后子进程按以下算法进行筛选即可。 123456p = get a number from left neighborprint ploop: n = get a number from left neighbor if (p does not divide n) send n to right neighbor 代码：（若BUFSIZE过大会panic，排查后发现是stack只有一页。。。） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#define MAX_SEQ 35#define BUFSIZE 100int getline(int fd, char *buf, int max){ int i, cc; char c; for (i = 0; i + 1 &lt; max;) { cc = read(fd, &amp;c, 1); if (cc &lt; 1) { return 0; } if (c == '\\n' || c == '\\r') break; buf[i++] = c; } buf[i] = '\\0'; return i;}int getnum(char *buf, int *pos){ int num = 0, i = *pos; while(buf[i] &gt;= '0' &amp;&amp; buf[i] &lt;= '9') { num = num * 10 + buf[i] - '0'; i++; } *pos = i - 1; return num;}int primer(int read_fd){ char buf[BUFSIZE]; int len = getline(read_fd, buf, BUFSIZE); // printf(&quot;%s\\n&quot;, buf); close(read_fd); int pipe_fd[2]; pipe(pipe_fd); int i = 0, first_print_flag = 1; int is_have = 0; int first_num = getnum(buf, &amp;i), num_tmp; printf(&quot;prime %d\\n&quot;, first_num); for (i = 0; i &lt; len; ++i) { if (buf[i] &gt;= '0' &amp;&amp; buf[i] &lt;= '9') { num_tmp = getnum(buf, &amp;i); if (num_tmp % first_num == 0) { continue; } is_have = 1; break; } } if (is_have) { if (fork() == 0) { // child close(pipe_fd[1]); primer(pipe_fd[0]); exit(0); } else { close(pipe_fd[0]); for (i = 0; i &lt; len; ++i) { if (buf[i] &gt;= '0' &amp;&amp; buf[i] &lt;= '9') { num_tmp = getnum(buf, &amp;i); if (num_tmp % first_num == 0) { continue; } if (first_print_flag) { fprintf(pipe_fd[1], &quot;%d&quot;, num_tmp); first_print_flag = 0; } else { fprintf(pipe_fd[1], &quot; %d&quot;, num_tmp); } } } fprintf(pipe_fd[1], &quot;\\n&quot;, num_tmp); close(pipe_fd[1]); wait(0); } } else { close(pipe_fd[0]); close(pipe_fd[1]); } return 0;}int main(int argc, char *argv[]){ int pipe_fd[2]; // read, write if (argc != 1) { fprintf(2, &quot;Usage: primes\\n&quot;); exit(1); } pipe(pipe_fd); if (fork() == 0) { // child close(pipe_fd[1]); primer(pipe_fd[0]); exit(0); } else { // father close(pipe_fd[0]); for (int i = 2; i &lt;= MAX_SEQ; ++i) { fprintf(pipe_fd[1], &quot;%d&quot;, i); if (i != MAX_SEQ) { fprintf(pipe_fd[1], &quot; &quot;, i); } else { fprintf(pipe_fd[1], &quot;\\n&quot;, i); } } close(pipe_fd[1]); wait(0); } exit(0);} find Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file user/find.c. 描述：实现find。 解决思路：魔改ls即可，改成dfs实现。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/fs.h&quot;char*fmtname(char *path){ char *p; // Find first character after last slash. for(p=path+strlen(path); p &gt;= path &amp;&amp; *p != '/'; p--) ; p++; return p;}voidfind(char *path, char *target){ struct stat st; char buf[512], *p; int fd; struct dirent de; if (stat(path, &amp;st) &lt; 0) { fprintf(2, &quot;find: cannot stat %s\\n&quot;, path); return; } switch(st.type){ case T_FILE: if (strcmp(fmtname(path), target) == 0) { printf(&quot;%s\\n&quot;, path); } break; case T_DIR: if((fd = open(path, 0)) &lt; 0){ fprintf(2, &quot;find: cannot open %s\\n&quot;, path); return; } strcpy(buf, path); p = buf+strlen(buf); *p++ = '/'; // many records while(read(fd, &amp;de, sizeof(de)) == sizeof(de)){ if(de.inum == 0) continue; if (!strcmp(&quot;.&quot;, de.name) || !strcmp(&quot;..&quot;, de.name)) { continue; } memmove(p, de.name, strlen(de.name)); p[strlen(de.name)] = 0; find(buf, target); } close(fd); break; }}intmain(int argc, char *argv[]){ if(argc != 3){ fprintf(2, &quot;Usage: find path keyword\\n&quot;); exit(1); } find(argv[1], argv[2]); exit(0);} xargs Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file user/xargs.c. 描述：实现xargs。 解决思路：对每行进行处理，因此加上上面的getline函数然后搭配上fork和exec就行（和shell类似）。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/param.h&quot;#define MAX_LEN 512int getline(char *buf, int max){ int i, cc; char c; for(i=0; i+1 &lt; max; ){ cc = read(0, &amp;c, 1); if(cc &lt; 1) { return 0; } if(c == '\\n' || c == '\\r') break; buf[i++] = c; } buf[i] = '\\0'; printf(&quot;str: %s\\n&quot;, buf); return 1;}intmain(int argc, char *argv[]){ // echo hello too | xargs echo bye char buffer[MAX_LEN]; char* argv_tmp[MAXARG]; // minus &quot;xargs&quot; memcpy(argv_tmp, argv + 1, (argc - 1) * sizeof(char*)); while (getline(buffer, MAX_LEN)) { if (fork() == 0) { argv_tmp[argc - 1] = buffer; exec(argv_tmp[0], argv_tmp); exit(0); } else { wait(0); } } exit(0);}","link":"/2023/03/06/mit6-s081-lab1/"},{"title":"操作系统 - 进程API","text":"概述进程的基本操作接口： 进程创建：fork (spawn, vfork, clone) 进程执行：exec 进程间同步：wait 进程退出：exit/abort 进程创建：fork()fork()语义：为调用进程创建一个一模一样的新进程，fork后的两个进程均为独立进程（调用进程为父进程，新进程为子进程）。 函数原型： 1234#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t fork(void); // 出错返回-1，子进程返回0，父进程返回子进程PID fork()调用的特点： 调用一次、返回两次 并发执行 相同但独立的地址空间 共享文件 fork为进程之间建立了父进程和子进程的关系，在进程之间建立了树型结构。 多个进程可以属于同一个进程组： 子进程默认与父进程属于同一个进程组 可以向同一进程组中的所有进程发送信号 主要用于shell程序中 写时拷贝（Copy-On-Write）：只拷贝内存映射，不拷贝实际内存 性能较好：一条映射至少对应一个4K的页面 调用exec的情况里，减少了无用的拷贝 进程的执行：exec()exec()语义：为进程指定可执行文件和参数。在fork之后调用exec，可以在载入可执行文件后会重置地址空间。 函数原型： 1234#include &lt;unistd.h&gt;//成功不返回，错误返回-1int execve(const char *filename, char *const argv[], char *const envp[]); exec()调用一次，并从不返回。 exec()的执行过程： exec()函数加载并运行可执行文件filename，以参数列表argv和环境变量列表envp为参数。 argv变量指向一个以null 结尾的指针数组，其中每个指针都指向一个参数字符串。按照惯例，argv [0]是可执行目标文件的名字。 envp变量指向一个以 null 结尾的指针数组，其中每个指针指向一个环境变量字符串，每个串都是形如name=value的名字一值对。 程序加载的过程： 创建内存映像 在程序头部表的引导下，加载器将可执行文件的片(chunk)复制到代码段和数据段。 加载器跳转到程序的入口点,也就是_start 函数的地址（系统目标文件 ctrl.o中定义）。 start 函数调用系统启动函数__libc_start_main（定义在libc.so 中）。 __libc_start_main初始化执行环境，调用用户层的 main 函数,处理 main函数的返回值,并且在需要的时候把控制返回给内核。 加载的过程（另一种描述）： 加载器删除子进程现有的虚拟內存段,并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零。通过将虛拟地址空间中的页映射到可执行文件的页大小的片(chunk),新的代码和数据段被初始化为可执行文件的内容。最后,加载器跳转到_start地址,它最终会调用应用程序的 main 函数。除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制。直到 CPU 引用一个被映射的虛拟页时才会进行复制，此时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。 main函数原型： 123int main(int argc, char **argv, char **envp);// 或者等价的int main(int argc, char *argv [], char *envp[); 当main函数开始执行时，用户栈的结构如下图。stack的中间是envp[]和argv[]表示的指针数组，每个指针指向一个底端的变量字符串；stack的顶端是系统启动函数libc_start_main。 回收子进程：wait()语义：等待子进程终止或停止。可以使用 wait()系统调用（或者更完整的兄弟接口 waitpid()）。 wait()函数原型：父进程一旦调用了wait就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。 1234#include &lt;sys/types.h&gt;/* 提供类型pid_t的定义*/#include &lt;wait.h&gt;int wait(int *status) waitpid()函数原型： 12345#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;//:如果成功,返回子进程的 PID,如果 WNOHANG,则为0,如果其他错误,则为-1。pid t waitpid(pid_t pid, int *statusp, int options); 例子创建一个子进程，统计一个文件的词数，然后父进程等待子进程介绍，回收之。 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/wait.h&gt;intmain(int argc, char *argv[]){ printf(&quot;hello world (pid:%d)\\n&quot;, (int) getpid()); int rc = fork(); if (rc &lt; 0) { // fork failed; exit fprintf(stderr, &quot;fork failed\\n&quot;); exit(1); } else if (rc == 0) { // child (new process) printf(&quot;hello, I am child (pid:%d)\\n&quot;, (int) getpid()); char *myargs[3]; myargs[0] = strdup(&quot;wc&quot;); // program: &quot;wc&quot; (word count) myargs[1] = strdup(&quot;p3.c&quot;); // argument: file to count myargs[2] = NULL; // marks end of array execvp(myargs[0], myargs); // runs word count printf(&quot;this shouldn't print out&quot;); } else { // parent goes down this path (original process) int wc = wait(NULL); printf(&quot;hello, I am parent of %d (wc:%d) (pid:%d)\\n&quot;, rc, wc, (int) getpid()); } return 0;} 运行后有结果： Why’s the design?为什么系统设计者要设计如此奇怪的接口（fork + exec），来完成简单的、 创建新进程的任务？ LAMPSON 定律：做对事（Get it right）。抽象和简化都不能替代做对事。 事实证明，这种分离 fork()及 exec()的做法对构建 UNIX shell 非常有用，因为这给了 shell 在 fork 之后 exec 之前运行代码的机会，这些代码可以在运行新程序前改变环境，从而让一系列有趣的功能很容易实现（比如重定向）。 1wc p3.c &gt; newfile.txt 重定向的工作原理：子进程向标准输出文件描述符的写入被透明地转向新打开的文件（可以使用dup2()函数）。 因此有如下代码（运行之，结果被存储在一个文件中）： 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;assert.h&gt;#include &lt;sys/wait.h&gt;intmain(int argc, char *argv[]){ int rc = fork(); if (rc &lt; 0) { // fork failed; exit fprintf(stderr, &quot;fork failed\\n&quot;); exit(1); } else if (rc == 0) { // child: redirect standard output to a file close(STDOUT_FILENO); open(&quot;./p4.output&quot;, O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU); // now exec &quot;wc&quot;... char *myargs[3]; myargs[0] = strdup(&quot;wc&quot;); // program: &quot;wc&quot; (word count) myargs[1] = strdup(&quot;p4.c&quot;); // argument: file to count myargs[2] = NULL; // marks end of array execvp(myargs[0], myargs); // runs word count } else { // parent goes down this path (original process) int wc = wait(NULL); assert(wc &gt;= 0); } return 0;} UNIX 管道也是用类似的方式实现的，但用的是 pipe()系统调用。在这种情况下，一个 进程的输出被链接到了一个内核管道（pipe）上，另一个进程的输入也被连接到了同一个管道上。前一个进程的输出无缝地作为后一个进程的输入，许多命令可以用这种方式串联在一起，共同完成某项任务。 1grep -o foo file | wc -l。 reference[1] 操作系统导论（ostep [2] 深入理解计算机系统 [3] 上海交通大学并行与分布式系统研究所-进程","link":"/2023/03/06/os-ostep-process-api/"},{"title":"mit6.S081 - xv6-debug","text":"窗口1作为xv6的运行窗口。 1make CPUS=1 qemu-gdb 窗口2作为gdb调试窗口。 1234567gdb-multiarch kernel/kernel# 进入gdb后执行set confirm offset architecture riscv:rv64set riscv use-compressed-breakpoints yestarget remote localhost:25000 一些tips： 12345678910111213141516171819202122232425262728293031323334# 调试用户态程序file user/_ls# 打开汇编/c源代码窗口，退出ctrl+x alayout split# 查看某地址对应指令x/i 0x630# 16进制打印p/x 1536# 打印寄存器的值p $a0i r a0# 查看栈帧bti f num# 单步执行（不进函数）n# 单步执行（进函数）s# 汇编单步执行（不进函数）ni# 汇编单步执行（进函数）si# 打断点b label# 删除断点delete breakpointsdelete num 一些不错的资料：gdb技巧。","link":"/2023/03/06/mit6-s081-xv6-debug/"},{"title":"STL - 分配器 allocators","text":"1 C++ 内存配置操作和释放操作123class FOO{};FOO *pf = new FOO; delete pf; 对于上述代码，其在底层执行内容为： line 2：new操作，首先调用::operator new分配内存 （2）调用Foo::Foo() 构造对象内容; ::operator new底层调用malloc分配内存。 line 3：delete操作，首先调用Foo::~Foo()将对象析构 （2）调用::operator delete释放内存; ::operator delete底层调用free释放内存。 出于分工的考量，STL 的allocators决定将这两个阶段分开。分别用 4 个函数来实现： 内存的配置：alloc::allocate(); 对象的构造：::construct(); 对象的析构：::destroy(); 内存的释放：alloc::deallocate(); 2 construct()和destroy()construct()和destroy()主要负责对象的构造与析构。 construct()的源码为： 1234template &lt;class T1, class T2&gt;inline void construct(T1* p, const T2&amp; value) { new (p) T1(value); //用placement new在 p 所指的对象上创建一个对象，value是初始化对象的值。} destory()的源码为： 1234567891011121314151617181920212223242526272829template &lt;class T&gt;inline void destroy(T* pointer) { pointer-&gt;~T(); //只是做了一层包装，将指针所指的对象析构---通过直接调用类的析构函数}template &lt;class ForwardIterator&gt; //destory的泛化版，接受两个迭代器为参数inline void destroy(ForwardIterator first, ForwardIterator last) { __destroy(first, last, value_type(first)); //调用内置的 __destory(),value_type()萃取迭代器所指元素的型别}template &lt;class ForwardIterator, class T&gt;inline void __destroy(ForwardIterator first, ForwardIterator last, T*) { typedef typename __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor; __destroy_aux(first, last, trivial_destructor()); //trival_destructor()相当于用来判断迭代器所指型别是否有 trival destructor}template &lt;class ForwardIterator&gt;inline void //如果无 trival destructor ，那就要调用destroy()函数对两个迭代器之间的对象元素进行一个个析构__destroy_aux(ForwardIterator first, ForwardIterator last, __false_type) { for ( ; first &lt; last; ++first) destroy(&amp;*first);}template &lt;class ForwardIterator&gt; //如果有 trival destructor ，则什么也不用做。这更省时间inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type) {}inline void destroy(char*, char*) {} //针对 char * 的特化版inline void destroy(wchar_t*, wchar_t*) {} //针对 wchar_t*的特化版 construct()比较好理解，就是直接调用new操作。 destory()的话就比较复杂，主要在于其有很多的特化版本（泛化、特化、偏特化可以百度了解），主要有以下版本： 泛化版本 __destroy() （ForwardIterator, ForwardIterator）: 根据是否是trival destructor（无关痛痒的析构函数）来进行选择 1.1 特化版本（false）：__destroy_aux(ForwardIterator first, ForwardIterator last, __false_type)，即for循环一个个调用析构函数来析构。 1.2 特化版本（true）：__destroy_aux(ForwardIterator, ForwardIterator, __true_type) {}，无关痛痒，什么都不做 特化版本：（T *）对于传入一个对象的指针，直接调用析构函数 特化版本：（char *, char *）char*型，什么都不做 特化版本：（wchar_t *,wchar_t *）wchar_t *型，什么都不做 有这么多特化版本的原因还是因为trival destructor，对于trival destructor执行和不执行都一样，因此去执行那些trival destructor是很吃力不讨好的。 3 allocate()和deallocate()allocate()和deallocate()主要负责与内存分配与释放相关的动作。 在STL源码中，allocate转调用::operator new实现，deallocate转调用::operator delete实现。 调用链路可理解为： 调用allocate分配内存-&gt;调用::operator new分配内存-&gt;调用malloc分配内存 调用deallocate释放内存-&gt;调用::operator delete释放内存-&gt;调用free释放内存 SGI对空间的配置和释放的设计哲学为： 向 system heap 要求空间 考虑多线程状态 考虑内存不足时的应变措施 考虑过多“小型区块”可能造成的内存碎片问题。 考虑到小型区块会导致内存破碎问题，SGI STL设计了一个双层级配置器。 其代码如下： 123456# ifdef __USE_MALLOCtypedef __malloc_alloc_template&lt;0&gt; malloc_alloc;typedef malloc_alloc alloc; //使用第一级配置器# elsetypedef __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, 0&gt; alloc; // 使用第二级配置器# endif 因为SGI使用了双层级配置器，因此需要对外提供一个接口，从而符合标准： 12345678910111213template&lt;class T, class Alloc&gt;class simple_alloc {public: static T *allocate(size_t n) { return 0 == n? 0 : (T*) Alloc::allocate(n * sizeof (T)); } static T *allocate(void) { return (T*) Alloc::allocate(sizeof (T)); } static void deallocate(T *p, size_t n) { if (0 != n) Alloc::deallocate(p, n * sizeof (T)); } static void deallocate(T *p) { Alloc::deallocate(p, sizeof (T)); }}; 对于足够大和足够小的定义决定了应该使用哪一级配置器，对于SGI STL而言，小于等于128bytes视为足够小。当配置区块超过 128 bytes时，调用第一级配置器。当配置区块小于 128 bytes时，采取第二级配置器。 第一层配置器直接使用malloc()和free()。 第二层配置器则使用 memory pool 的方式。 3.1 第一级配置器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//以下是第一级配置器template &lt;int inst&gt;class __malloc_alloc_template {private://以下函数用来处理内存不足的情况static void *oom_malloc(size_t);static void *oom_realloc(void *, size_t);static void (* __malloc_alloc_oom_handler)();public:static void * allocate(size_t n){ void *result = malloc(n); //第一级配置器，直接使用malloc() //如果内存不足，则调用内存不足处理函数oom_alloc()来申请内存 if (0 == result) result = oom_malloc(n); return result;}static void deallocate(void *p, size_t /* n */){ free(p); //第一级配置器直接使用 free()}static void * reallocate(void *p, size_t /* old_sz */, size_t new_sz){ void * result = realloc(p, new_sz); //第一级配置器直接使用realloc() //当内存不足时，则调用内存不足处理函数oom_realloc()来申请内存 if (0 == result) result = oom_realloc(p, new_sz); return result;}//设置自定义的out-of-memory handle就像set_new_handle()函数static void (* set_malloc_handler(void (*f)()))(){ void (* old)() = __malloc_alloc_oom_handler; __malloc_alloc_oom_handler = f; return(old);}};template &lt;int inst&gt;void (* __malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)() = 0; //内存处理函数指针为空，等待客户端赋值template &lt;int inst&gt;void * __malloc_alloc_template&lt;inst&gt;::oom_malloc(size_t n){ void (* my_malloc_handler)(); void *result; for (;;) { //不断尝试释放、配置、再释放、再配置 my_malloc_handler = __malloc_alloc_oom_handler; //设定自己的oom(out of memory)处理函数 if (0 == my_malloc_handler) { __THROW_BAD_ALLOC; } //如果没有设定自己的oom处理函数，毫不客气的抛出异常 (*my_malloc_handler)(); //设定了就调用oom处理函数 result = malloc(n); //再次尝试申请 if (result) return(result); }}template &lt;int inst&gt;void * __malloc_alloc_template&lt;inst&gt;::oom_realloc(void *p, size_t n){ void (* my_malloc_handler)(); void *result; for (;;) { my_malloc_handler = __malloc_alloc_oom_handler; if (0 == my_malloc_handler) { __THROW_BAD_ALLOC; } //如果自己没有定义oom处理函数，则编译器毫不客气的抛出异常 (*my_malloc_handler)(); //执行自定义的oom处理函数 result = realloc(p, n); //重新分配空间 if (result) return(result); //如果分配到了，返回指向内存的指针 }} 上述代码的流程为： 通过allocate()申请内存，通过deallocate()来释放内存，通过reallocate()重新分配内存。 当allocate()或reallocate()分配内存不足时会调用oom_malloc()或oom_remalloc()来处理。 当oom_malloc() 或 oom_remalloc()还是没能分配到申请的内存时，会转入以下两步中的一步： 3.1 调用用户自定义的内存分配不足处理函数(这个函数通过set_malloc_handler() 来设定)，然后继续申请内存。 3.2 如果用户未定义内存分配不足处理函数，程序就会抛出bad_alloc异常或利用exit(1)终止程序。 3.2 第二级配置器在第二级配置器中，SGI 第二层配置器定义了一个 free-lists，这个free-list是一个数组，各自管理大小分别为8,16,24,32,40….128bytes的小额区块。 free-list节点结构为： 1234union obj{ union obj * free_list_link; char client_date[1]; }; 第二级配置器的部分实现源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192template &lt;bool threads, int inst&gt;class __default_alloc_template {private: // Really we should use static const int x = N // instead of enum { x = N }, but few compilers accept the former.# ifndef __SUNPRO_CC enum {__ALIGN = 8}; //小型区块上调边界 enum {__MAX_BYTES = 128}; // 小型区块的上界 enum {__NFREELISTS = __MAX_BYTES/__ALIGN}; // free-list的节点个数# endif // 将bytes上调至8的倍数 static size_t ROUND_UP(size_t bytes) { return (((bytes) + __ALIGN-1) &amp; ~(__ALIGN - 1)); }__PRIVATE: union obj { union obj * free_list_link; char client_data[1]; /* The client sees this. */ };private: //16个free-list static obj * __VOLATILE free_list[__NFREELISTS]; //根据大小计算该用哪个区块，32-&gt;3 static size_t FREELIST_INDEX(size_t bytes) { return (((bytes) + __ALIGN-1)/__ALIGN - 1); } // Returns an object of size n, and optionally adds to size n free list. static void *refill(size_t n); // Allocates a chunk for nobjs of size &quot;size&quot;. nobjs may be reduced // if it is inconvenient to allocate the requested number. static char *chunk_alloc(size_t size, int &amp;nobjs); // Chunk allocation state. static char *start_free; //内存池起始位置，只在chunk_alloc()中变化。 static char *end_free; //内存池结束位置，只在chunk_alloc()中变化。 static size_t heap_size;public: /* n must be &gt; 0 */ static void * allocate(size_t n) { obj * __VOLATILE * my_free_list; obj * __RESTRICT result; if (n &gt; (size_t) __MAX_BYTES) { return(malloc_alloc::allocate(n)); } my_free_list = free_list + FREELIST_INDEX(n); // Acquire the lock here with a constructor call. // This ensures that it is released in exit or during stack // unwinding.# ifndef _NOTHREADS /*REFERENCED*/ lock lock_instance;# endif result = *my_free_list; if (result == 0) { void *r = refill(ROUND_UP(n)); return r; } *my_free_list = result -&gt; free_list_link; return (result); }; /* p may not be 0 */ static void deallocate(void *p, size_t n) { obj *q = (obj *)p; obj * __VOLATILE * my_free_list; if (n &gt; (size_t) __MAX_BYTES) { malloc_alloc::deallocate(p, n); return; } my_free_list = free_list + FREELIST_INDEX(n); // acquire lock# ifndef _NOTHREADS /*REFERENCED*/ lock lock_instance;# endif /* _NOTHREADS */ q -&gt; free_list_link = *my_free_list; *my_free_list = q; // lock is released here } static void * reallocate(void *p, size_t old_sz, size_t new_sz);} ; 第二级配置器的结构： 3.2.1 allocate()allocate()的源码： 1234567891011121314151617181920static void * allocate(size_t n){ obj * __VOLATILE * my_free_list; obj * __RESTRICT result; //要申请的空间大于128bytes就调用第一级配置 if (n &gt; (size_t) __MAX_BYTES) { return(malloc_alloc::allocate(n)); } //寻找 16 个free lists中恰当的一个 my_free_list = free_list + FREELIST_INDEX(n); result = *my_free_list; if (result == 0) { //没找到可用的free list，准备新填充free list void *r = refill(ROUND_UP(n)); return r; } *my_free_list = result -&gt; free_list_link; return (result);}; ROUND_UP函数源码如下，其作用为：将要申请的内存字节数上调为8的倍数。 123static size_t ROUND_UP(size_t bytes) { return (((bytes) + __ALIGN-1) &amp; ~(__ALIGN - 1));} refill函数源码如下，其作用为：向内存池申请20块大小为n的一大块内存，将其挂在free-list上，并返回之。这个refill函数如allocate中所描述，就是在没找到可用的free-list时使用的，即我想要一块大小为32bytes的内存，然而发现没有了，此时就调用refill，去申请20个32bytes的内存以供使用。 12345678910111213141516171819202122232425262728293031/* Returns an object of size n, and optionally adds to size n free list.*//* We assume that n is properly aligned. *//* We hold the allocation lock. */template &lt;bool threads, int inst&gt;void* __default_alloc_template&lt;threads, inst&gt;::refill(size_t n){ int nobjs = 20; char * chunk = chunk_alloc(n, nobjs); obj * __VOLATILE * my_free_list; obj * result; obj * current_obj, * next_obj; int i; if (1 == nobjs) return(chunk); my_free_list = free_list + FREELIST_INDEX(n); /* Build free list in chunk */ result = (obj *)chunk; *my_free_list = next_obj = (obj *)(chunk + n); for (i = 1; ; i++) { current_obj = next_obj; next_obj = (obj *)((char *)next_obj + n); if (nobjs - 1 == i) { current_obj -&gt; free_list_link = 0; break; } else { current_obj -&gt; free_list_link = next_obj; } } return(result);} 3.2.2 deallocate()deallocate()的实现则较为简单，等同于一个链表插入操作，源码如下： 12345678910111213141516static void deallocate(void *p, size_t n){ obj *q = (obj *)p; obj * __VOLATILE * my_free_list; //如果要释放的字节数大于128，则调第一级配置器 if (n &gt; (size_t) __MAX_BYTES) { malloc_alloc::deallocate(p, n); return; } //寻找对应的位置 my_free_list = free_list + FREELIST_INDEX(n); //以下两步将待释放的块加到链表上 q -&gt; free_list_link = *my_free_list; *my_free_list = q;} 参考文献： [1] 侯捷.STL源码剖析[M].武汉：华中科技大学出版社，2002.6：43-69. [2] https://www.cnblogs.com/zhuwbox/p/3699977.html","link":"/2023/03/05/stl-allocators/"},{"title":"STL - array源码分析","text":"array底层就是一个定长数组，给定长数组加上迭代器相关的东西，就可以让他像一个容器，符合容器的性质。 12345678910111213141516171819202122232425262728293031323334#define _NOEXCEPT noexcepttemplate&lt;class _Tp, size_t _Size&gt;struct array { // types: typedef _Tp value_type; typedef value_type &amp;reference; typedef value_type *pointer; typedef value_type *iterator; typedef ptrdiff_t difference_type; typedef size_t size_type; _Tp __elems_[_Size]; const value_type *data() const _NOEXCEPT { return __elems_; } // iterators: iterator begin() _NOEXCEPT { return iterator(data()); } iterator end() _NOEXCEPT { return iterator(data() + _Size); } reference operator[](size_type __n) _NOEXCEPT { return __elems_[__n]; } reference at(size_type __n);}template&lt;class _Tp, size_t _Size&gt;typename array&lt;_Tp, _Size&gt;::referencearray&lt;_Tp, _Size&gt;::at(size_type __n) { if (__n &gt;= _Size) __throw_out_of_range(&quot;array::at&quot;); return __elems_[__n];} 偏特化版本：(对size为0情况进行处理) 123456789101112131415161718192021template&lt;class _Tp&gt;struct array&lt;_Tp, 0&gt; { // types: typedef _Tp value_type; typedef value_type &amp;reference; typedef value_type *iterator; typedef value_type *pointer; typedef ptrdiff_t difference_type; typedef size_t size_type; typedef typename conditional&lt;is_const&lt;_Tp&gt;::value, const char, char&gt;::type _CharType; struct _ArrayInStructT { _Tp __data_[1]; }; _ALIGNAS_TYPE(_ArrayInStructT) _CharType __elems_[sizeof(_ArrayInStructT)]; value_type *data() _NOEXCEPT { return reinterpret_cast&lt;value_type *&gt;(__elems_); }}","link":"/2023/03/05/stl-array/"},{"title":"STL - STL概述","text":"1 STL概述 容器 Containers：STL内部封装好的数据结构，一种class template，常用的包括vector、list、deque、set、map、multiset、multimap等 分配器 Allocators：负责空间配置与管理。是一个实现了动态空间配置、空间管理、空间释放的class template。一般SGI STL为每一个容器都指定其缺省的空间配置器为alloc（SGI配置器） 算法 Algorithms：一种function template，常用的有sort、search、copy、erase等 迭代器 Iterators：泛型指针，是一种智能指针，是一种将operator*，operator-&gt;，operator++，operator–等指针相关操作予以重载的class template。所有STL容器都附带自己的迭代器 适配器 Adapters：一种用来修饰容器(container)或仿函数(functor)或迭代器(iterator)接口的东西。如queue和stack。它们的底部完全借助deque，所有操作都由底层的deque供应。改变functor接口者，称为functor adapter，改变container接口者，称为container adapter；改变iterator接口者，称为iterator adapter。 仿函数 Functors：行为类似函数，就是使一个类的使用看上去象一个函数，具有可配接性。它的具体实现就是通过在类中重载了operator()，使这个类具有了类似函数的行为，就是一个仿函数类了。一般函数指针、回调函数可视为狭义的仿函数。分为算术运算、关系运算、逻辑运算三大类。这部分内建的仿函数，均放在头文件里，使用时需引入头文件。 给出如下示例，在例子中，对应上述六大组件有： 容器：vector 分配器：allocator 迭代器：begin(),end() 算法：count_if 适配器：not1,bind2nd 仿函数：less 123456789void test_all_components(){ int ia[7] = { 27, 210, 12, 47, 109, 83, 40 }; vector&lt;int,allocator&lt;int&gt;&gt; vi(ia,ia+7); cout &lt;&lt; count_if(vi.begin(), vi.end(), not1(bind2nd(less&lt;int&gt;(), 40)));//5 cout &lt;&lt; endl; }","link":"/2023/03/05/stl-intro/"},{"title":"STL - list源码分析","text":"list概述list底层为非连续区间，即链表（实质上是一个双向循环链表） list每次插入或者删除一个元素，就配置和释放一个元素空间，对于任何位置的原属插入或原属移除，list永远为常数时间。 list的节点首先要知道，list本身和list的节点是不同的，如果我们声明一个list，里面放了100W个元素，然后执行sizeof，会发现sizeof的结果并不是100W。这就是因为容器所管理的内存空间大小和容器本身的大小是不一样的。 又如下测试代码： 1234567#include &lt;list&gt;int main(){ std::list&lt;int&gt; test (100); printf(&quot;sizeof: %d | size: %d | sizeof(int *) : %d\\n&quot;, sizeof(test), test.size(), sizeof(int*)); // ans: sizeof: 24 | size: 100 | sizeof(int *) : 8} 我的电脑为64位机，指针大小为8，可以看出，对list进行sizeof操作，其为24，而不是100，这也就能映衬上文所说的“容器所管理的内存空间大小和容器本身的大小是不一样的”。那么这24个byte是什么呢？这就得慢慢分析源代码了。 list的节点（node）定义如下，由一个指向前一个节点的指针，指向后一个节点的指针，和数据三个部分构成： 1234567template &lt;class T&gt;struct __list_node { typedef void* void_pointer; void_pointer next; void_pointer prev; T data;}; list的迭代器list的底层节点不能保证其在内存中连续存在，因此list的迭代器是不可能实现随机访问的，只能靠next和prev两根指针的移动来进行操作。这样的迭代器是双向迭代器（bidirectional_iterator），即只能向前和向后移动。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152template&lt;class T, class Ref, class Ptr&gt;struct __list_iterator { // 定义相应型别 typedef __list_iterator&lt;T, T&amp;, T*&gt; iterator; typedef __list_iterator&lt;T, Ref, Ptr&gt; self; typedef bidirectional_iterator_tag iterator_category; typedef T value_type; typedef Ptr pointer; typedef Ref reference; typedef __list_node&lt;T&gt;* link_type; typedef size_t size_type; typedef ptrdiff_t difference_type; // 拥有一个指向对应结点的指针 link_type node; // 构造函数 __list_iterator() {} __list_iterator(link_type x) : node(x) {} __list_iterator(const iterator&amp; x) : node(x.node) {} // 重载了iterator必须的操作符 // 解引用，取数据 reference operator*() const { return (*node).data; } // 指针使用-&gt;访问数据成员 pointer operator-&gt;() const { return &amp;(operator*()); } // ++iter，iter通过next指向下一个元素 self&amp; operator++() { node = (link_type)((*node).next); return *this; } self operator++(int){ self tmp = *this; ++*this; return tmp; } // --iter，iter通过prev指向上一个元素 self&amp; operator--() { node = (link_type)((*node).prev); return *this; } self operator--(int){ self tmp = *this; --*this; return tmp; } bool operator==(const self&amp; x) const { return node == x.node; } bool operator!=(const self&amp; x) const { return node != x.node; }}; list有一个重要的性质：插入（insert）和接合（splice）操作不回造成原有的list迭代器失效，这在vector是不成立的。list的元素删除操作（erase）也只会让指向“被删除元素”的迭代器失效，其他迭代器不受影响。 list的数据结构list的底层数据结构就是一个双向循环链表，要表示这个双向循环链表十分的简单，就用一个节点（node）即可（这样可以说明为什么上面sizeof(list)=24了，一个指针8字节（64位机），prev、next2个指针和一个，这里有个坑，以后再补呜呜呜）。我们在数据结构中学过，一般链表有一个头节点，在list中也是一样的，只不过为了满足STL迭代器前闭后开这个特性，使得begin()为node-&gt;next，end()为node。可结合代码与图一起理解。 1234567891011121314151617181920template &lt;class T, class Alloc = alloc&gt;class list {protected: typedef void* void_pointer; typedef __list_node&lt;T&gt; list_node; typedef simple_alloc&lt;list_node, Alloc&gt; list_node_allocator;public: typedef T value_type; typedef value_type* pointer; typedef value_type&amp; reference; typedef list_node* link_type; typedef size_t size_type; typedef ptrdiff_t difference_type;public: // 定义迭代器类型 typedef __list_iterator&lt;T, T&amp;, T*&gt; iterator;protected: link_type node; // 空白结点 链表尾结点 // ...}; 根据上图，不难得出关于迭代器的几个操作如下： 1234567891011121314// node 指向尾节点的下一位置，因此 node 符合STL对 end 的定义。iterator begin() { return (link_type)((*node).next); }iterator end() { return node; } bool empty() const { return node-&gt;next == node; }size_type size() const { size_type result = 0; distance(begin(), end(), result); // 全局函数，求begin()和end()之间的距离，有对于bidirectional_iterator的特化版本 return result;}// 取头节点的内容reference front() { return *begin(); } // 取尾节点的内容reference back() { return *(--end()); } list的构造与析构直接上构造函数和析构函数吧，看代码就能说明问题！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354template &lt;class T, class Alloc = alloc&gt;class list {public: // 默认构造函数，产生一个空链表 list() { empty_initialize(); }protected: // 初始化 void empty_initialize() { node = get_node(); // 配置一個节点空间，令 node 指向它。 node-&gt;next = node; // 令node 头尾都指向自己，不设元素值。 node-&gt;prev = node; } // 析构函数 ~list() { clear(); // 清楚所有节点 put_node(node); // 把list里边的node释放掉 } // 实现在下面，清除所有节点 void clear(); // 为结点分配内存 link_type get_node() { return list_node_allocator::allocate(); } // 回收内存 void put_node(link_type p) { list_node_allocator::deallocate(p); } // 构造node link_type create_node(const T&amp; x) { link_type p = get_node(); construct(&amp;p-&gt;data, x); return p; } // 销毁node void destroy_node(link_type p) { destroy(&amp;p-&gt;data); put_node(p); }};// 清除所有节点template &lt;class T, class Alloc&gt; void list&lt;T, Alloc&gt;::clear(){ link_type cur = (link_type) node-&gt;next; // begin() while (cur != node) { // 访问每一个节点 link_type tmp = cur; cur = (link_type) cur-&gt;next; destroy_node(tmp); // 摧毁（析构并释放）一个节点 } // 恢复 node 原始状态 node-&gt;next = node; node-&gt;prev = node;} list的其他操作list成员函数的实现其实就是对环状双向链表的操作。 首先是insert、erase、transfer的实现，关于插入删除大部分都调用这三个函数，实际上就是改变结点pre跟next指针的指向。 123456789101112131415161718192021222324252627282930313233iterator insert(iterator position, const T&amp; x) { link_type tmp = create_node(x); // 改变四个指针的指向 实际就是双向链表元素的插入 tmp-&gt;next = position.node; tmp-&gt;prev = position.node-&gt;prev; (link_type(position.node-&gt;prev))-&gt;next = tmp; position.node-&gt;prev = tmp; return tmp;}iterator erase(iterator position) { // 改变四个指针的指向 实际就是双向链表的元素删除 link_type next_node = link_type(position.node-&gt;next); link_type prev_node = link_type(position.node-&gt;prev); prev_node-&gt;next = next_node; next_node-&gt;prev = prev_node; destroy_node(position.node); return iterator(next_node);}// 将[first, last)插入到position位置(可以是同一个链表)void transfer(iterator position, iterator first, iterator last) { if (position != last) { // 实际上也是改变双向链表结点指针的指向 具体操作看下图 (*(link_type((*last.node).prev))).next = position.node; (*(link_type((*first.node).prev))).next = last.node; (*(link_type((*position.node).prev))).next = first.node; link_type tmp = link_type((*position.node).prev); (*position.node).prev = (*last.node).prev; (*last.node).prev = (*first.node).prev; (*first.node).prev = tmp; }} list的对外接口： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091void push_front(const T&amp; x) { insert(begin(), x); }void push_back(const T&amp; x) { insert(end(), x); }void pop_front() { erase(begin()); }void pop_back() { iterator tmp = end(); erase(--tmp);}void swap(list&lt;T, Alloc&gt;&amp; x) { __STD::swap(node, x.node); }// splice有很多重载版本// 將 x 接合於 position 所指位置之前。x 必須不同於 *this。void splice(iterator position, list&amp; x) { if (!x.empty()) transfer(position, x.begin(), x.end());}// 將 i 所指元素接合於 position 所指位置之前。position 和i 可指向同一個list。void splice(iterator position, list&amp;, iterator i) { iterator j = i; ++j; if (position == i || position == j) return; transfer(position, i, j);}// 將 [first,last) 內的所有元素接合於 position 所指位置之前。// position 和[first,last)可指向同一個list，// 但position不能位於[first,last)之內。void splice(iterator position, list&amp;, iterator first, iterator last) { if (first != last) transfer(position, first, last);}// merge函数实现跟归并排序中合并的操作类似template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::merge(list&lt;T, Alloc&gt;&amp; x) { iterator first1 = begin(); iterator last1 = end(); iterator first2 = x.begin(); iterator last2 = x.end(); // 注意：前提是，两个list都递增排列 while (first1 != last1 &amp;&amp; first2 != last2) if (*first2 &lt; *first1) { iterator next = first2; transfer(first1, first2, ++next); first2 = next; } else ++first1; if (first2 != last2) transfer(last1, first2, last2);}// reserse函数每次都调用transfer将结点插入到begin()之前template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::reverse() { if (node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) return; iterator first = begin(); ++first; while (first != end()) { iterator old = first; ++first; transfer(begin(), old, first); }}// list必须使用自己的sort()成员函数 因为STL算法中的sort()只接受RamdonAccessIterator// 该函数采用的是quick sorttemplate &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::sort() { // 空串和长度为1的 不用排序 if (node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) return; // 一些新的 lists，暂存 list&lt;T, Alloc&gt; carry; list&lt;T, Alloc&gt; counter[64]; int fill = 0; while (!empty()) { carry.splice(carry.begin(), *this, begin()); int i = 0; while(i &lt; fill &amp;&amp; !counter[i].empty()) { counter[i].merge(carry); carry.swap(counter[i++]); } carry.swap(counter[i]); if (i == fill) ++fill; } for (int i = 1; i &lt; fill; ++i) counter[i].merge(counter[i-1]); swap(counter[fill-1]);}","link":"/2023/03/05/stl-list/"},{"title":"STL - 番外1 什么？sizeof(list&lt;int&gt;)竟然是24","text":"之前写了这样一段代码， 1234printf(&quot;%d | %d \\n&quot;, sizeof(std::list&lt;int&gt;), sizeof(std::list&lt;long long&gt;));/*24 | 24 */ 首先我们需要知道list是个什么东东： 点进std::list，可以看到以下代码，可以看出list这玩意貌似没有成员？但他继承了一个 __list_imp&lt;_Tp, _Alloc&gt;： 123456template &lt;class _Tp, class _Alloc /*= allocator&lt;_Tp&gt;*/&gt;class _LIBCPP_TEMPLATE_VIS list : private __list_imp&lt;_Tp, _Alloc&gt;{ ...} 点进__list_imp可以看到这个代码，有一个__end_，我们离真相又近了一点了，__end_是__node_base类型的，可以看到前边有个typedef： 1234567891011template &lt;class _Tp, class _Alloc&gt;class __list_imp{protected: typedef _Tp value_type; typedef typename __alloc_traits::void_pointer __void_pointer; typedef __list_node_base&lt;value_type, __void_pointer&gt; __node_base; __node_base __end_; ...} 点进__list_node_base，看看这是个啥玩意。哦豁，发现了两个指针！ 12345678910struct __list_node_base{ typedef __list_node_pointer_traits&lt;_Tp, _VoidPtr&gt; _NodeTraits; typedef typename _NodeTraits::__node_pointer __node_pointer; typedef typename _NodeTraits::__base_pointer __base_pointer; typedef typename _NodeTraits::__link_pointer __link_pointer; __link_pointer __prev_; __link_pointer __next_;}; 注意，这是个父结构体，再看看他子结构体的实现，如下： 1234567891011121314template &lt;class _Tp, class _VoidPtr&gt;struct __list_node : public __list_node_base&lt;_Tp, _VoidPtr&gt;{ _Tp __value_; typedef __list_node_base&lt;_Tp, _VoidPtr&gt; __base; typedef typename __base::__link_pointer __link_pointer; _LIBCPP_INLINE_VISIBILITY __link_pointer __as_link() { return static_cast&lt;__link_pointer&gt;(__base::__self()); }}; 好啊，终于找到了list的数据成员了，两根指针，一个数据，类似于以下形式： 123456template&lt;class T&gt;struct test { T* prev; T* next; T t;} 但是回到正题，为什么std::list是24呢？ 我的机子是64位机，指针是8bytes，int是4个字节，8*2+4 = 20，没毛病，20。 但是输出为什么是24呢？ 遇到这种问题，我们一般就需要从编译器角度考虑了（首先可以肯定，这肯定不是我的问题！） 结构体对齐，嗯结构体对齐，这是编译器考虑的范畴。 内存对齐的作用： 字节对齐主要是为了提高内存的访问效率，比如intel 32位cpu，每个总线周期都是从偶地址开始读取32位的内存数据，如果数据存放地址不是从偶数开始，则可能出现需要两个总线周期才能读取到想要的数据，因此需要在内存中存放数据时进行对齐。 结论1：一般情况下，结构体所占的内存大小并非元素本身大小之和。 结论2：结构体内存大小应按最大元素大小对齐，如果最大元素大小超过模数，应按模数大小对齐。 这里的模数就需要编译器来操作啦！ 我们试试取消内存对齐试试： 12345678910111213141516171819#include &lt;list&gt;template&lt;class T&gt;struct test { T* prev; T* next; T t;}__attribute__((__packed__)) ;int main(){ printf(&quot;%d | %d \\n&quot;, sizeof(int), sizeof(long long)); printf(&quot;%d | %d \\n&quot;, sizeof(std::list&lt;int&gt;), sizeof(std::list&lt;long long&gt;)); printf(&quot;%d | %d \\n&quot;, sizeof(test&lt;int&gt;), sizeof(test&lt;long long&gt;));}/*4 | 8 24 | 24 20 | 24*/ 可以发现，test已经是20了，说明list为24的原因就是因为内存对齐所致。 内存对齐的相关知识可以参考：https://www.zhihu.com/question/27862634 详细的内存对齐内容，将在以后探讨….","link":"/2023/03/05/stl-memory-question/"},{"title":"STL - 番外2 优先队列默认是大根堆？","text":"stl中默认堆为大根堆，大根堆的定义为： 1priority_queue&lt;int&gt; q; 根据源码中的定义，有如下代码： 123456789101112131415template &lt;class _Tp, class _Container = vector&lt;_Tp&gt;, class _Compare = less&lt;typename _Container::value_type&gt; &gt;class _LIBCPP_TEMPLATE_VIS priority_queue{public: typedef _Container container_type; typedef _Compare value_compare; typedef typename container_type::value_type value_type; typedef typename container_type::reference reference; typedef typename container_type::size_type size_type;protected: container_type c; value_compare comp;} 从最开头我们可以看出，声明优先队列时，第一参数为类型，第二参数为容器，第三参数为比较函数（默认小于）。 那么问题来了，为什么默认的这个cmp仿函数为小于的堆，是个大根堆（堆顶元素为最大值）？ 建堆时都是一步步push()的，查看源码，可以看到如下函数： 1234567891011// 类里边的声明void push(value_type&amp;&amp; __v);// push实现template &lt;class _Tp, class _Container, class _Compare&gt;inlinevoidpriority_queue&lt;_Tp, _Container, _Compare&gt;::push(value_type&amp;&amp; __v){ c.push_back(_VSTD::move(__v)); _VSTD::push_heap(c.begin(), c.end(), comp);} 从上述代码可以看出，优先队列的push操作就是往容器内push_back一个数，然后执行一个push_heap()操作。 查看push_heap()操作，可以看到如下代码： 12345678template &lt;class _RandomAccessIterator, class _Compare&gt;inline _LIBCPP_INLINE_VISIBILITYvoidpush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp){ typedef typename __comp_ref_type&lt;_Compare&gt;::type _Comp_ref; __sift_up&lt;_Comp_ref&gt;(__first, __last, __comp, __last - __first);} 其又掉用了__sift_up()函数，学过堆的小伙伴应该对这个up操作十分熟悉吧！ __sift_up()函数实现如下： 123456789101112131415161718192021222324252627282930313233343536template &lt;class _Compare, class _RandomAccessIterator&gt;void__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp, typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type __len){ typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type value_type; if (__len &gt; 1) { // ((__len - 1) -1) / 2; __len = (__len - 2) / 2; _RandomAccessIterator __ptr = __first + __len; if (__comp(*__ptr, *--__last)) { value_type __t(_VSTD::move(*__last)); do { *__last = _VSTD::move(*__ptr); __last = __ptr; if (__len == 0) break; __len = (__len - 1) / 2; __ptr = __first + __len; } while (__comp(*__ptr, __t)); *__last = _VSTD::move(__t); } }}template &lt;class _Tp&gt;inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPRtypename remove_reference&lt;_Tp&gt;::type&amp;&amp;move(_Tp&amp;&amp; __t) _NOEXCEPT{ typedef _LIBCPP_NODEBUG_TYPE typename remove_reference&lt;_Tp&gt;::type _Up; return static_cast&lt;_Up&amp;&amp;&gt;(__t);} 从__sift_up()函数的代码我们可以看出：这个cmp仿函数时一直传进来了的，而且是根据 __comp(*__ptr, __t)一直在执行某操作的。 这里就要涉及到heap的up操作了。 heap的up，简而言之，就是把元素和他的父亲节点（/2便是父亲节点，完全二叉树性质）比较，如果符合某性质，就将该节点上移。 以上源码类似于如下代码： 12345678910void sift-up ( MaxHeap H){ i = H-&gt;size; item = H-&gt;Element [i]; for ( ; H -&gt; Element [ i/2 ] &lt; item; i /= 2 ) // 与父结点做比较，i / 2 表示的就是父结点的下标 { H -&gt; Element [ i ] = H -&gt; Element [ i/2 ]; // 向下过滤结点 } H -&gt; Element [ i ] = item ; //若for循环完成后,i更新为父节点i，然后将 item 插入} 对于less的话，就是满足小于，则将节点上移，这样就形成了一个大根堆。 所以大小根堆可以以以下方式声明。 1234// 大根堆 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q;// 小根堆 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;","link":"/2023/03/05/stl-priority-queue/"},{"title":"操作系统 - 线程","text":"概述线程（thread），又被称为轻量级进程（Lightweight Process, LWP）是程序执行流的最小单位，也是调度的基本单位。 为什么需要线程？ 创建进程的开销较大：包括了数据、代码、堆、栈等 进程的隔离性过强：进程间交互可以通过进程间通信（IPC），但开销较大 进程内部无法支持并行 线程相较于进程，是一种更加轻量级的运行时抽象。 线程只包含运行时的状态：线程执行状态（运行、就绪等）、线程上下文（PC等寄存器集合）、栈。 一个进程可以包含多个线程：多个线程共享同一地址空间。 多线程进程的地址空间 每个线程拥有自己的栈。 内核中也有为线程准备的内核栈。 其它区域（数据、代码、堆）共享。 用户态线程与内核态线程根据线程是否受内核管理，可以将线程分为两类： 内核态线程 内核可见，受内核管理 由内核创建，线程相关信息存放在内核中 用户态线程 内核不可见，不受内核直接管理 在应用态创建，线程相关信息主要存放在应用数据中 与内核线程相比，用户态线程更加轻量级，创建开销更小，但功能也较为受限，与内核态相关的操作（系统调用）需要内核态线程协助才能完成。 线程模型线程模型表示了用户态线程与内核态线程之间的联系。 多对一模型：多个用户态线程对应一个内核态线程 一对一模型：一个用户态线程对应一个内核态线程 多对多模型：多个用户态线程对应多个内核态线程 指标 多对一模型 一对一模型 多对多模型 概念 将多个用户态线程映射给单一的内核线程 每个用户线程映射单独的内核线程 N个用户态线程映射到M个内核态线程（N &gt; M） 优点 高效的上下文切换和无限制的线程数量内核管理简单 用户线程和内核线程一致可扩展性好 解决了可扩展性问题（多对一）和线程过多问题（一对一） 缺点 可扩展性差，无法适应多核机器的发展一个用户线程阻塞，导致内核线程阻塞，其他线程也无法执行 os会限制内核线程数量，因此用户线程数量受到限制内核线程上下文切换开销大 管理复杂 实际情况 在主流操作系统中被弃用用于各种用户态线程库中 主流操作系统(Windows、Linux、OS X)都采用一对一模型 在虚拟化中得到了广泛应用 相关数据结构：TCB 线程控制块一对一模型的TCB可以分为两部分 内核态：与PCB结构类似 Linux中进程与线程使用的是同一种数据结构（task_struct） 上下文切换中会使用 应用态：可以由线程库定义 Linux：pthread结构体 Windows：TIB（Thread Information Block） 可以认为是内核TCB的扩展 TLS 线程本地存储不同线程可能会执行相同的代码（线程不具有独立的地址空间，多线程共享代码段）。 对于全局变量，不同线程可能需要不同的拷贝（用于标明系统调用错误的errno）。 使用TLS可以很方便的实现线程内的全局变量。 线程库允许定义每个线程独有的数据 __thread int id; 会为每个线程定义一个独有的id变量 每个线程的TLS结构相似 可通过TCB索引 TLS寻址模式：基地址＋偏移量 X86: 段页式 (fs寄存器) AArch64: 特殊寄存器tpidr_el0 reference[1] 上海交通大学并行与分布式系统研究所-进程 [2] 操作系统导论（ostep） [3] 操作系统-精髓与设计原理 [4] 现代操作系统 [5] 程序员的自我修养","link":"/2023/03/06/os-ostep-thread/"},{"title":"STL - STL的编程范式","text":"2 STL的编程范式OOP(Object-Oriented Programming)：面向对象 数据和操作在同一个类;OOP企图将datas和methods关联在一起 12345template&lt;class T, class Alloc = alloc&gt;class list{ ... void sort();} GP(Generic Programming)：泛型编程 datas和methods分隔开，即algorithm和contains分隔开，通过iterator交互。 12template&lt;typename _RandomAccessIterator&gt;inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __end) STL采用GP的原因： Containers和Algorithms团队刻个字闭门造车，Iterators团队沟通。 Algorithms通过Iterators确定操作范围，并通过Iterators取用Containers元素。 例子： 有算法（Algorithms）如下： 1234template&lt;class T&gt;inline const min T&amp;(const T&amp; a, const T&amp; b){ return b &lt; a ? b : a;} 如果要对一个自定义类进行大小比较，则可以重载**&lt;**，或者写个Compare函数。这样，算法就有了其通用性，而无需关心容器是什么。 泛化、特化、偏特化特化即特殊化，即设计者认为对于制定类型，使用特定版本更好。 全特化就是限定死模板实现的具体类型。 偏特化就是如果这个模板有多个类型，那么只限定其中的一部分。 优先级：全特化类&gt;偏特化类&gt;主版本模板类 123456789101112131415161718192021222324252627//泛化Template &lt;class type&gt; Struct __type_traits{typedef __true_type this_dummy_member_must_be_first; };//特化1Template &lt; &gt; Struct __type_traits&lt;int&gt;{typedef __true_type this_dummy_member_must_be_first; };//特化2Template &lt; &gt; Struct __type_traits&lt;double&gt;{typedef __true_type this_dummy_member_must_be_first; };//__type_traits&lt;FOO&gt;:: this_dummy_member_must_be_first; 使用的是泛化的内容//泛化Template &lt;class T, class Alloc = alloc&gt; Class vecor{};//偏特化(个数偏特化，第一个特化，第二个不特化)Template &lt;class Alloc&gt;Class vector&lt;bool, Alloc&gt;{};//泛化Template &lt;class Iterator&gt;Struct iterator_traits {};//偏特化1（范围偏特化，只能是传入指针）Template &lt;class T&gt;Struct iterator_traits&lt;T*&gt;{};//偏特化2Template &lt;class T&gt;Struct iterator_traits&lt;const T*&gt;{}; 为什么list不能使用::sort函数 list底层数据结构为链表，不支持随机访问（random access），所以list这个Containers中，有自带的sort方法。 ::sort接口为： 12345sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp){ typedef typename __comp_ref_type&lt;_Compare&gt;::type _Comp_ref; _VSTD::__sort&lt;_Comp_ref&gt;(__first, __last, _Comp_ref(__comp));} list.sort为，可以看到为链表的归并排序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162template &lt;class _Tp, class _Alloc&gt;template &lt;class _Comp&gt;typename list&lt;_Tp, _Alloc&gt;::iteratorlist&lt;_Tp, _Alloc&gt;::__sort(iterator __f1, iterator __e2, size_type __n, _Comp&amp; __comp){ switch (__n) { case 0: case 1: return __f1; case 2: if (__comp(*--__e2, *__f1)) { __link_pointer __f = __e2.__ptr_; base::__unlink_nodes(__f, __f); __link_nodes(__f1.__ptr_, __f, __f); return __e2; } return __f1; } size_type __n2 = __n / 2; iterator __e1 = _VSTD::next(__f1, __n2); iterator __r = __f1 = __sort(__f1, __e1, __n2, __comp); iterator __f2 = __e1 = __sort(__e1, __e2, __n - __n2, __comp); if (__comp(*__f2, *__f1)) { iterator __m2 = _VSTD::next(__f2); for (; __m2 != __e2 &amp;&amp; __comp(*__m2, *__f1); ++__m2) ; __link_pointer __f = __f2.__ptr_; __link_pointer __l = __m2.__ptr_-&gt;__prev_; __r = __f2; __e1 = __f2 = __m2; base::__unlink_nodes(__f, __l); __m2 = _VSTD::next(__f1); __link_nodes(__f1.__ptr_, __f, __l); __f1 = __m2; } else ++__f1; while (__f1 != __e1 &amp;&amp; __f2 != __e2) { if (__comp(*__f2, *__f1)) { iterator __m2 = _VSTD::next(__f2); for (; __m2 != __e2 &amp;&amp; __comp(*__m2, *__f1); ++__m2) ; __link_pointer __f = __f2.__ptr_; __link_pointer __l = __m2.__ptr_-&gt;__prev_; if (__e1 == __f2) __e1 = __m2; __f2 = __m2; base::__unlink_nodes(__f, __l); __m2 = _VSTD::next(__f1); __link_nodes(__f1.__ptr_, __f, __l); __f1 = __m2; } else ++__f1; } return __r;}","link":"/2023/03/05/stl-programming-style/"},{"title":"STL - 番外0 vector resize reserve比较","text":"vector resize reserve比较size：Returns the number of elements in the vector 目前存在的元素数。即： 元素个数 capacity：Return size of allocated storage capacity 容器能存储数据的个数。 即：容器容量 reserve原型： 1void reserve (size_type n); 作用： Request a change in capacity Requests that the vector capacity be at least enough to contain n elements. If n is greater than the current vector capacity, the function causes the container to reallocate its storage increasing its capacity to n (or greater). In all other cases, the function call does not cause a reallocation and the vector capacity is not affected. This function has no effect on the vector size and cannot alter its elements. resize原型： 12void resize (size_type n);void resize (size_type n, const value_type&amp; val); 作用： Change size Resizes the container so that it contains n elements. If n is smaller than the current container size, the content is reduced to its first n elements, removing those beyond (and destroying them). If n is greater than the current container size, the content is expanded by inserting at the end as many elements as needed to reach a size of n. If val is specified, the new elements are initialized as copies of val, otherwise, they are value-initialized. If n is also greater than the current container capacity, an automatic reallocation of the allocated storage space takes place. Notice that this function changes the actual content of the container by inserting or erasing elements from it. 通过以上说明我们可以得知： resize改变的是容器的大小（包括capacity和size），reserve则是改变的capacity，size没有改变。 reserve是容器预留空间，但在空间内不真正创建元素对象，所以在没有添加新的对象之前，不能引用容器内的元素。 resize了以后，容器中就有了相关的元素（对象），是可以引用容器内的元素的。 我们通过以下的一个测试函数，来探讨下我们为什么要使用reserve： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void growPushBack(vector&lt;int&gt; &amp;vec){ int size = 0, cap = 0; for(int i = 0; i &lt; 600; i++){ cap = vec.capacity(); size = vec.size(); if(cap == size){ cout &lt;&lt; endl; cout &lt;&lt; &quot;after push, capacity will mul 2&quot; &lt;&lt; endl; cout &lt;&lt; &quot;before: &quot; &lt;&lt; vec.capacity() &lt;&lt; &quot; address: &quot; &lt;&lt; &amp;*(vec.begin()) &lt;&lt; endl; } vec.push_back(i); if(cap == size){ cout &lt;&lt; &quot;after: &quot; &lt;&lt; vec.capacity() &lt;&lt; &quot; address: &quot; &lt;&lt; &amp;*(vec.begin()) &lt;&lt; endl; } }}int main(){ vector&lt;int&gt; vecIntA; //声明vector后未使用reserve，直接进行push_back操作 cout &lt;&lt; &quot;Making vecIntA growing:(empty opt)&quot; &lt;&lt; endl; cout &lt;&lt; &quot;size: &quot; &lt;&lt; vecIntA.size() &lt;&lt; endl; cout &lt;&lt; &quot;capacity: &quot; &lt;&lt; vecIntA.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;begin:&quot; &lt;&lt;&amp;*(vecIntA.begin()) &lt;&lt; endl; growPushBack(vecIntA); cout &lt;&lt; &quot;\\n\\n-----\\n\\n&quot; &lt;&lt; endl; vector&lt;int&gt; vecIntB; //声明vecIntB后用reserve来执行其容量为50 vecIntB.reserve(50); cout &lt;&lt; &quot;Making vecIntB growing:(reserve) &quot; &lt;&lt; endl; cout &lt;&lt; &quot;size: &quot; &lt;&lt; vecIntB.size() &lt;&lt; endl; cout &lt;&lt; &quot;capacity: &quot; &lt;&lt; vecIntB.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;begin:&quot; &lt;&lt;&amp;*(vecIntB.begin()) &lt;&lt; endl; growPushBack(vecIntB); cout &lt;&lt; &quot;\\n\\n-----\\n\\n&quot; &lt;&lt; endl; vector&lt;int&gt; vecIntC; //声明vecIntC后用resize来执行其容量为50 vecIntC.resize(50); cout &lt;&lt; &quot;Making vecIntC growing: (resize)&quot; &lt;&lt; endl; cout &lt;&lt; &quot;size: &quot; &lt;&lt; vecIntC.size() &lt;&lt; endl; cout &lt;&lt; &quot;capacity: &quot; &lt;&lt; vecIntC.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;begin:&quot; &lt;&lt;&amp;*(vecIntC.begin()) &lt;&lt; endl; growPushBack(vecIntC); return 0;} 输出结果为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677Making vecIntA growing:(empty opt)size: 0capacity: 0begin:0x0after push, capacity will mul 2before: 0 address: 0x0after: 1 address: 0x7fb4a4604080after push, capacity will mul 2before: 1 address: 0x7fb4a4604080after: 2 address: 0x7fb4a4604090after push, capacity will mul 2before: 2 address: 0x7fb4a4604090after: 4 address: 0x7fb4a4604080after push, capacity will mul 2before: 4 address: 0x7fb4a4604080after: 8 address: 0x7fb4a46040a0after push, capacity will mul 2before: 8 address: 0x7fb4a46040a0after: 16 address: 0x7fb4a46040c0after push, capacity will mul 2before: 16 address: 0x7fb4a46040c0after: 32 address: 0x7fb4a4604100after push, capacity will mul 2before: 32 address: 0x7fb4a4604100after: 64 address: 0x7fb4a4604180after push, capacity will mul 2before: 64 address: 0x7fb4a4604180after: 128 address: 0x7fb4a4604280after push, capacity will mul 2before: 128 address: 0x7fb4a4604280after: 256 address: 0x7fb4a5808200-----Making vecIntB growing:(reserve) size: 0capacity: 50begin:0x7fb4a4604180after push, capacity will mul 2before: 50 address: 0x7fb4a4604180after: 100 address: 0x7fb4a4704080after push, capacity will mul 2before: 100 address: 0x7fb4a4704080after: 200 address: 0x7fb4a4704210-----Making vecIntC growing: (resize)size: 50capacity: 50begin:0x7fb4a4704080after push, capacity will mul 2before: 50 address: 0x7fb4a4704080after: 100 address: 0x7fb4a4704530after push, capacity will mul 2before: 100 address: 0x7fb4a4704530after: 200 address: 0x7fb4a47046c0Process finished with exit code 0 由运行结果可知，通过push_back操作，容器中的元素数量（size）一直在增加，当容器中的元素个数（size）达到了capacity值时，capacity是呈指数级增大的（2^n）（注意：此处不同编译器是不一样的，有的编译器是增加目前capacity的一半，即乘以1.5；有的是增加目前capacity，即乘以2），当发生扩容操作时，系统会发生以下操作： 开辟2*capacity的新空间 将原vector中的元素拷贝至新地址 释放原vector的capacity空间 根据输出容器的begin迭代器在内存中的地址，可以知道，容器是换了位置的（在内存中的位置发生了变化）。 为了支持快速的随机访问，vector容器的元素以连续方式存放，每一个元素都紧挨着前一个元素存储。设想一下，当vector添加一个元素时，为了满足连续存放这个特性，都需要重新分配空间、拷贝元素、撤销旧空间，这样性能难以接受。因此STL实现者在对vector进行内存分配时，其实际分配的容量要比当前所需的空间多一些。就是说，vector容器预留了一些额外的存储区，用于存放新添加的元素，这样就不必为每个新元素重新分配整个容器的内存空间。 push_back的具体实现： 当数组中增加一个元素x的时候，先判断是否还有备用空间；如果还有备用空间，则将当前指针的值设为x，并将当前的指针加1；若备用空间已经用完，如果之前的空间为0，则重新分配大小为1的空间，否则将空间扩容为之前的两倍，然后将旧容器中的值重新拷贝到新空间中，并重新分配起始指针和当前指针。所以使用vector需要注意的一点就是尽量不要动态给它分配空间。而且空间重新分配之后，之前的所有指针都会失效（特别要注意）。两倍扩容的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243void push_back(const T&amp; x) { if (finish != end_of_storage) { //若当前还有备用空间 construct(finish, x); //将当前水位的值设为x ++finish; //提升水位 } else insert_aux(end(), x); }template &lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert_aux(iterator position, const T&amp; x) { if (finish != end_of_storage) { construct(finish, *(finish - 1)); ++finish; T x_copy = x; copy_backward(position, finish - 2, finish - 1); *position = x_copy; } else { const size_type old_size = size(); //获取之前数组的大小 const size_type len = old_size != 0 ? 2 * old_size : 1; //将当前数组的容量扩大为原来的两倍 iterator new_start = data_allocator::allocate(len); //重新分配新数组的起始迭代器 iterator new_finish = new_start; __STL_TRY { new_finish = uninitialized_copy(start, position, new_start); //将旧数组的值重新分配给当前的新数组 construct(new_finish, x); //将当前数组的水位的值设为x ++new_finish; //提升新数组的水位 new_finish = uninitialized_copy(position, finish, new_finish); //这语句感觉可有可无，因为它根本就不会执行，position即last，而finish也是last } # ifdef __STL_USE_EXCEPTIONS catch(...) { //如果重新构造的新数组出现异常，则销毁当前新创建的数组，并释放内存空间 destroy(new_start, new_finish); data_allocator::deallocate(new_start, len); throw; }# endif /* __STL_USE_EXCEPTIONS */ destroy(begin(), end()); //将旧数组的空间释放掉 deallocate(); start = new_start; //new_start记录新数组的起始位置 finish = new_finish; //重新设置当前水位的指针 end_of_storage = new_start + len; //设置新数组的容量 }} 综上，出于性能的考虑，我们在提前可以知道vector size的情况下，可以提前resize或reserve，这样可以减少扩容时拷贝所付出的时间。","link":"/2023/03/05/stl-resize-or-reserve/"},{"title":"Ubuntu18.04 静态IP","text":"查看本机的网关(重要，涉及到连接互联网问题) 1route -n 查看本机IP信息 1ifconfig 修改配置文件 1sudo vim /etc/netplan/01-network-manager-all.yaml 按照上文查询到的信息进行修改： 1234567891011# Let NetworkManager manage all devices on this systemnetwork: version: 2 renderer: networkd ethernets: ens33: dhcp4: no addresses: [192.168.48.130/24] gateway4: 192.168.48.2 nameservers: addresses: [8.8.8.8, 114.114.114.114] 重启网络服务： 1sudo netplan apply","link":"/2023/03/06/ubuntu-static-ip/"},{"title":"Ubuntu18.04 ssh免密码登陆","text":"Ubuntu18.04 ssh免密码登陆： 客户端（发起ssh端）配置好ssh公私钥。 12# 连按三个回车即可，生成的key在~/.ssh下ssh-keygen -t rsa -C &quot;your mail&quot; 服务器端（ssh服务器端）启动ssh。 12345678# 未安装ssh server则先安装之sudo apt install openssh-server# 启动sshdsudo service ssh start# 查看sshd启动与否ps -aux | grep ssh 将客户端的key复制到服务器端。 1ssh-copy-id ubuntu@192.168.48.130","link":"/2023/03/06/ubuntu-ssh-login/"},{"title":"hitos - lab3 进程运行轨迹的跟踪与统计解答","text":"实验内容进程从创建（Linux下调用fork()）到结束的整个过程就是进程的生命期，进程在其生命期中的运行轨迹实际上就表现为进程状态的多次切换，如进程创建以后会成为就绪态；当该进程被调度以后会切换到运行态；在运行的过程中如果启动了一个文件读写操作，操作系统会将该进程切换到阻塞态（等待态）从而让出CPU；当文件读写完毕以后，操作系统会在将其切换成就绪态，等待进程调度算法来调度该进程执行…… 本次实验包括如下内容： 基于模板“process.c”编写多进程的样本程序，实现如下功能： 所有子进程都并行运行，每个子进程的实际运行时间一般不超过30秒； 父进程向标准输出打印所有子进程的id，并在所有子进程都退出后才退出； 在Linux 0.11上实现进程运行轨迹的跟踪。基本任务是在内核中维护一个日志文件/var/process.log，把从操作系统启动到系统关机过程中所有进程的运行轨迹都记录在这一log文件中。 在修改过的0.11上运行样本程序，通过分析log文件，统计该程序建立的所有进程的等待时间、完成时间（周转时间）和运行时间，然后计算平均等待时间，平均完成时间和吞吐量。可以自己编写统计程序，也可以使用python脚本程序—— stat_log.py ——进行统计。 修改0.11进程调度的时间片，然后再运行同样的样本程序，统计同样的时间数据，和原有的情况对比，体会不同时间片带来的差异。 实验手册：参考 实验过程编写样本程序所谓样本程序，就是一个生成各种进程的程序。我们的对0.11的修改把系统对它们的调度情况都记录到log文件中。在修改调度算法或调度参数后再运行完全一样的样本程序，可以检验调度算法的优劣。理论上，此程序可以在任何Unix/Linux上运行，所以建议在Ubuntu上调试通过后，再拷贝到0.11下运行。 process.c编写： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;sys/times.h&gt;#include &lt;sys/wait.h&gt;#define HZ 100const int sum_time = 30;void cpuio_bound(int last, int cpu_time, int io_time);int main(int argc, char * argv[]){ int num = sum_time / 2; pid_t pid; int i = 0; for (i = 0; i &lt;= num; i++) { pid = fork(); if (pid == 0) { cpuio_bound(sum_time, i, sum_time - i); return 0; } else if (pid &gt; 0){ printf (&quot;the %d-th child process id: %d\\n&quot;, i, pid); } else { printf (&quot;fork error!&quot;); } } do { wait(NULL); } while (num--); return 0;}/* * 此函数按照参数占用CPU和I/O时间 * last: 函数实际占用CPU和I/O的总时间，不含在就绪队列中的时间，&gt;=0是必须的 * cpu_time: 一次连续占用CPU的时间，&gt;=0是必须的 * io_time: 一次I/O消耗的时间，&gt;=0是必须的 * 如果last &gt; cpu_time + io_time，则往复多次占用CPU和I/O * 所有时间的单位为秒 */void cpuio_bound(int last, int cpu_time, int io_time){ struct tms start_time, current_time; clock_t utime, stime; int sleep_time; while (last &gt; 0) { /* CPU Burst */ times(&amp;start_time); /** 其实只有t.tms_utime才是真正的CPU时间。但我们是在模拟一个 * 只在用户状态运行的CPU大户，就像“for(;;);”。所以把t.tms_stime * 加上很合理。*/ do { times(&amp;current_time); utime = current_time.tms_utime - start_time.tms_utime; stime = current_time.tms_stime - start_time.tms_stime; } while ( ( (utime + stime) / HZ ) &lt; cpu_time ); last -= cpu_time; if (last &lt;= 0 ) break; /* IO Burst */ /* 用sleep(1)模拟1秒钟的I/O操作 */ sleep_time=0; while (sleep_time &lt; io_time) { sleep(1); sleep_time++; } last -= sleep_time; }} log文件操作系统启动后先要打开/var/process.log，然后在每个进程发生状态切换的时候向log文件内写入一条记录，其过程和用户态的应用程序没什么两样。然而，因为内核状态的存在，使过程中的很多细节变得完全不一样。 打开log文件为了能尽早开始记录，应当在内核启动时就打开log文件。内核的入口是init/main.c中的main()。fork时会继承文件句柄，因此可以在进程0直接打开日志文件，这样子进程都拥有打开日志文件的句柄了。 123456789setup((void *) &amp;drive_info);(void) open(&quot;/dev/tty0&quot;,O_RDWR,0);(void) dup(0);(void) dup(0);(void) open(&quot;/var/process.log&quot;, O_CREAT | O_TRUNC | O_WRONLY, 0666);if (!fork()) { /* we count on this going ok */ init();} 写log文件log文件将被用来记录进程的状态转移轨迹。所有的状态转移都是在内核进行的。在内核状态下，write()功能失效，只能调用printk()。编写可在内核调用的write()的难度较大，所以这里直接给出源码。它主要参考了printk()和sys_write()而写成的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;linux/sched.h&gt;#include &lt;sys/stat.h&gt;static char logbuf[1024];int fprintk(int fd, const char *fmt, ...){ va_list args; int count; struct file * file; struct m_inode * inode; va_start(args, fmt); count=vsprintf(logbuf, fmt, args); va_end(args); if (fd &lt; 3) /* 如果输出到stdout或stderr，直接调用sys_write即可 */ { __asm__(&quot;push %%fs\\n\\t&quot; &quot;push %%ds\\n\\t&quot; &quot;pop %%fs\\n\\t&quot; &quot;pushl %0\\n\\t&quot; &quot;pushl $logbuf\\n\\t&quot; /* 注意对于Windows环境来说，是_logbuf,下同 */ &quot;pushl %1\\n\\t&quot; &quot;call sys_write\\n\\t&quot; /* 注意对于Windows环境来说，是_sys_write,下同 */ &quot;addl $8,%%esp\\n\\t&quot; &quot;popl %0\\n\\t&quot; &quot;pop %%fs&quot; ::&quot;r&quot; (count),&quot;r&quot; (fd):&quot;ax&quot;,&quot;cx&quot;,&quot;dx&quot;); } else /* 假定&gt;=3的描述符都与文件关联。事实上，还存在很多其它情况，这里并没有考虑。*/ { if (!(file=task[0]-&gt;filp[fd])) /* 从进程0的文件描述符表中得到文件句柄 */ return 0; inode=file-&gt;f_inode; __asm__(&quot;push %%fs\\n\\t&quot; &quot;push %%ds\\n\\t&quot; &quot;pop %%fs\\n\\t&quot; &quot;pushl %0\\n\\t&quot; &quot;pushl $logbuf\\n\\t&quot; &quot;pushl %1\\n\\t&quot; &quot;pushl %2\\n\\t&quot; &quot;call file_write\\n\\t&quot; &quot;addl $12,%%esp\\n\\t&quot; &quot;popl %0\\n\\t&quot; &quot;pop %%fs&quot; ::&quot;r&quot; (count),&quot;r&quot; (file),&quot;r&quot; (inode):&quot;ax&quot;,&quot;cx&quot;,&quot;dx&quot;); } return count;} 使用： 12345//向stdout打印正在运行的进程的IDfprintk(1, &quot;The ID of running process is %ld&quot;, current-&gt;pid); //向log文件输出fprintk(3, &quot;%ld\\t%c\\t%ld\\n&quot;, current-&gt;pid, 'R', jiffies); 跟踪进程运行轨迹jiffies，滴答jiffies在kernel/sched.c文件中定义为一个全局变量： 1long volatile jiffies=0; 它记录了从开机到当前时间的时钟中断发生次数。在kernel/sched.c文件中的sched_init()函数中，时钟中断处理函数被设置为： 1set_intr_gate(0x20,&amp;timer_interrupt); 而在kernel/system_call.s文件中将timer_interrupt定义为： 1234timer_interrupt: …… incl jiffies #增加jiffies计数值 …… 这说明jiffies表示从开机时到现在发生的时钟中断次数，这个数也被称为“滴答数”。 另外，在kernel/sched.c中的sched_init()中有下面的代码： 123outb_p(0x36, 0x43); //设置8253模式outb_p(LATCH&amp;0xff, 0x40);outb_p(LATCH&gt;&gt;8, 0x40); 这三条语句用来设置每次时钟中断的间隔，即为LATCH，而LATCH是定义在文件kernel/sched.c中的一个宏： 12#define LATCH (1193180/HZ)#define HZ 100 //在include/linux/sched.h中 再加上PC机8253定时芯片的输入时钟频率为1.193180MHz，即1193180/每秒，LATCH=1193180/100，时钟每跳11931.8下产生一次时钟中断，即每1/100秒（10ms）产生一次时钟中断，所以jiffies实际上记录了从开机以来共经过了多少个10ms。 寻找状态切换点有5个状态，分别是创建（N)、运行（R)、就绪（J)、睡眠（W)、退出（E)。 在 fork.c、sche.c、exit.c文件中添加相应的print语句即可。 关注state 改变的时机即可。 fork.c： 1234567891011121314151617int copy_process(int nr,long ebp,long edi,long esi,long gs,long none, long ebx,long ecx,long edx, long fs,long es,long ds, long eip,long cs,long eflags,long esp,long ss){ p = (struct task_struct *) get_free_page(); ... p-&gt;state = TASK_UNINTERRUPTIBLE; ... p-&gt;start_time = jiffies; fprintk (3, &quot;%ld\\t%c\\t%ld\\n&quot;, p-&gt;pid, 'N', jiffies); ... p-&gt;state = TASK_RUNNING; /* do this last, just in case */ fprintk (3, &quot;%ld\\t%c\\t%ld\\n&quot;, p-&gt;pid, 'J', jiffies); return last_pid;} sche.c： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394void schedule(void){ int i,next,c; struct task_struct ** p;/* check alarm, wake up any interruptible tasks that have got a signal */ for(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p) if (*p) { if ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) { (*p)-&gt;signal |= (1&lt;&lt;(SIGALRM-1)); (*p)-&gt;alarm = 0; } if (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp; (*p)-&gt;state==TASK_INTERRUPTIBLE) { (*p)-&gt;state=TASK_RUNNING; fprintk(3, &quot;%d\\t%c\\t%d\\n&quot;, (*p)-&gt;pid, 'J', jiffies); } } /* this is the scheduler proper: */ ... // NEXT IS NEXT PROCESS WILL RUN! if (task[next]-&gt;pid != current-&gt;pid) { if (current-&gt;state == TASK_RUNNING) { fprintk(3, &quot;%d\\t%c\\t%d\\n&quot;, current-&gt;pid, 'J', jiffies); } fprintk(3, &quot;%d\\t%c\\t%d\\n&quot;, task[next]-&gt;pid, 'R', jiffies); } switch_to(next);}int sys_pause(void){ current-&gt;state = TASK_INTERRUPTIBLE; if (current-&gt;pid != 0) { fprintk(3, &quot;%d\\t%c\\t%d\\n&quot;, current-&gt;pid, 'W', jiffies); } schedule(); return 0;}void sleep_on(struct task_struct **p){ struct task_struct *tmp; if (!p) return; if (current == &amp;(init_task.task)) panic(&quot;task[0] trying to sleep&quot;); tmp = *p; *p = current; current-&gt;state = TASK_UNINTERRUPTIBLE; fprintk(3, &quot;%d\\t%c\\t%d\\n&quot;, current-&gt;pid, 'W', jiffies); schedule(); if (tmp) { tmp-&gt;state=0; fprintk(3, &quot;%d\\t%c\\t%d\\n&quot;, tmp-&gt;pid, 'J', jiffies); }}void interruptible_sleep_on(struct task_struct **p){ struct task_struct *tmp; if (!p) return; if (current == &amp;(init_task.task)) panic(&quot;task[0] trying to sleep&quot;); tmp=*p; *p=current;repeat: current-&gt;state = TASK_INTERRUPTIBLE; fprintk(3, &quot;%d\\t%c\\t%d\\n&quot;, current-&gt;pid, 'W', jiffies); schedule(); if (*p &amp;&amp; *p != current) { (**p).state=0; fprintk(3, &quot;%d\\t%c\\t%d\\n&quot;, (**p).pid, 'J', jiffies); goto repeat; } *p=NULL; if (tmp) { tmp-&gt;state=0; fprintk(3, &quot;%d\\t%c\\t%d\\n&quot;, tmp-&gt;pid, 'J', jiffies); }}void wake_up(struct task_struct **p){ if (p &amp;&amp; *p) { (**p).state=0; fprintk(3, &quot;%d\\t%c\\t%d\\n&quot;, (**p).pid, 'J', jiffies); *p=NULL; }} exit.c: 1234567891011121314151617181920212223242526272829int do_exit(long code){ int i; free_page_tables(get_base(current-&gt;ldt[1]),get_limit(0x0f)); free_page_tables(get_base(current-&gt;ldt[2]),get_limit(0x17)); ... current-&gt;state = TASK_ZOMBIE; fprintk(3, &quot;%ld\\t%c\\t%ld\\n&quot;, current-&gt;pid, 'E', jiffies); schedule(); return (-1); /* just to suppress warnings */}int sys_waitpid(pid_t pid,unsigned long * stat_addr, int options){ ... if (flag) { if (options &amp; WNOHANG) return 0; current-&gt;state=TASK_INTERRUPTIBLE; fprintk(3, &quot;%ld\\t%c\\t%ld\\n&quot;, current-&gt;pid, 'W', jiffies); schedule(); if (!(current-&gt;signal &amp;= ~(1&lt;&lt;(SIGCHLD-1)))) goto repeat; else return -EINTR; } return -ECHILD;} 修改时间片对于时间片counter,由于时间片的初始化操作为：p-&gt;counter = p-&gt;priority只与优先级priority有关，所以只需要修改priority即可在定义priority宏中修改即可 123#define INIT_TASK \\ { 0,15,15,// 上述三个值分别对应 state、counter 和 priority; 实验结果把process.c放在linux0.11上编译运行，如下： 然后是获得log，把log从linux0.11中移出来即可。 使用默认的分析程序对时间片为10、15、20的情况进行分析： process-10.log: 123456789101112131415161718Process Turnaround Waiting CPU Burst I/O Burst 7 3383 88 0 3295 8 4772 1481 100 3190 9 6051 2770 200 3080 10 7230 3960 300 2970 11 8309 5049 400 2860 12 9288 6038 500 2750 13 10168 6927 600 2640 14 10947 7716 700 2530 15 11626 8406 800 2420 16 12088 8905 900 2283 17 12532 9394 1000 2137 18 12875 9783 1100 1991 19 13136 10072 1200 1863 20 13297 10262 1300 1735 21 13367 10351 1400 1616 22 13356 10340 1500 1515Average: 10151.56 6971.38 process-15.log: 12345678910111213141516171819Process Turnaround Waiting CPU Burst I/O Burst 7 3403 238 0 3165 8 4632 1481 100 3050 9 5991 2841 200 2950 10 7240 4090 300 2850 11 8199 5064 400 2735 12 9244 6108 500 2635 13 10178 7042 600 2535 14 10877 7747 700 2430 15 11601 8476 800 2325 16 12214 9095 900 2218 17 12617 9529 1000 2087 18 13014 9943 1100 1970 19 13301 10248 1200 1853 20 13442 10412 1300 1730 21 13528 10511 1400 1616 22 13516 10500 1500 1515Average: 10187.31 7082.81Throughout: 0.12/s process-20.log: 12345678910111213141516171819Process Turnaround Waiting CPU Burst I/O Burst 7 3913 313 0 3600 8 5272 1691 100 3480 9 6531 2970 200 3360 10 7690 4150 300 3240 11 8749 5229 400 3120 12 9709 6208 500 3000 13 10568 7087 600 2880 14 11327 7867 700 2760 15 11967 8546 800 2621 16 12451 9125 900 2426 17 12815 9604 1000 2210 18 13117 9983 1100 2033 19 13358 10264 1200 1894 20 13498 10443 1300 1755 21 13538 10522 1400 1616 22 13517 10501 1500 1515Average: 10501.25 7156.44Throughout: 0.12/s 可以发现，时间片为10的时候平均周转时间和平均等待时间竟然是最短的！ linux还说这是个很好的调度函数呢。。（看来也不是太好。。。 但是，对时间片为10的情况仔细分析，可以发现：父进程没有一次性创建16子进程，另外的是时间片中断后创建的。 后续的进程新建的时间晚很多，这就拉低了平均数！！ 时间片为15时，是一次性fork出的： 时间片为20时也是一样： 相较于20的时间片，15明显更优；若是考虑上时间片为10得拉到平均值效果，15的时间片其实也是更优的选择。 所以呢，时间片为15还是最佳的方案（创建少点进程，效果会更明显），linux老爷子还是做过相关实验的。。。 遇到的问题如果有自己搭建环境做实验，然后linux崩了的（kernel panic ），可以尝试使用实验楼的环境，可能自己的环境是有问题的。 reference[1] 实验指导书","link":"/2023/03/06/linux-hitos-lab3/"},{"title":"STL - deque源码分析","text":"deque概述deque是一种双向开口的“连续”线性空间（即可以在头尾两端分别做元素的插入和删除操作）。 deque与vector的差别： deque允许在常数时间内对头端进行元素的插入和删除操作，vector尾部插入和删除常数时间，头部操作O（n）时间 deque没有容量概念，不需要和vector一样进行老三样：申请新空间-&gt;复制元素-&gt;释放旧空间 deque的Ramdon Access Iterator进行过特殊设计，复杂度比vector高。 deque的中控器底层内存分布deque的“连续”空间只是在逻辑上连续的，实际上deque是由一段一段的定量连续空间构成。一旦有必要在deque的头端或尾端增加新空间，便配置一段定量的连续空间，串接在整个deque的头端或尾端。 deque的核心任务是维护 分段的定量连续空间整体连续的假象，并提供随机存取的接口，避免vector的申请新空间-&gt;复制元素-&gt;释放旧空间，但其代价是deque的迭代器架构较复杂。 中控器正如上面那张图看到的，对于分段的定量连续空间，我们需要一个map（就是一小段连续空间，和数组类似）来指示他（就像一个包租婆有很多房子，手里得有一个地图，找到他的每个房子） 1234567891011121314template &lt;class T, class Alloc = alloc, size_t BufSiz = 0&gt; class deque {public: // Basic types typedef T value_type; typedef value_type* pointer; typedef value_type&amp; reference; typedef size_t size_type; typedef ptrdiff_t difference_type;protected: // Internal typedefs typedef pointer* map_pointer;protected: map_pointer map;//指向指针数组 T** 类似于二维数组 T*指向一个缓冲区，T**就是这个map size_type map_size;//指针数组元素个数} deque的迭代器迭代器结构deque是分段连续空间，维护“整体连续”假象的任务就落在了operator++和operator–两个运算上了。 我们可以想象，一个iterator指向一个缓冲区（buffer）内元素时，当到了一个buffer的末端则需要跳到下一个buffer，到了buffer的头端则需要跳转到前一个buffer，这里则需要我们前面所说的map来调节。如何知道我们是否在buffer的头尾端呢？这就需要iterator保存这个buffer的begin和end了。 综上，deque的iterator需要以下元素： 指向当前元素的指针 指向当前buffer头端的指针 指向当前buffer尾端的指针 指向map中控的指针 SGI STL中源码如下： 123456789101112131415161718192021222324252627282930313233343536template &lt;class T, class Ref, class Ptr, size_t BufSiz&gt;struct __deque_iterator { // 未继承 std::iterator typedef __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator; typedef __deque_iterator&lt;T, const T&amp;, const T*, BufSiz&gt; const_iterator; static size_t buffer_size() {return __deque_buf_size(BufSiz, sizeof(T)); }#else /* __STL_NON_TYPE_TMPL_PARAM_BUG */template &lt;class T, class Ref, class Ptr&gt;struct __deque_iterator { // 未继承 std::iterator typedef __deque_iterator&lt;T, T&amp;, T*&gt; iterator; typedef __deque_iterator&lt;T, const T&amp;, const T*&gt; const_iterator; static size_t buffer_size() {return __deque_buf_size(0, sizeof(T)); }#endif // 未继承 std::iterator，所以必须自己写五个必要的迭代器相应型别 typedef random_access_iterator_tag iterator_category; // (1) typedef T value_type; // (2) typedef Ptr pointer; // (3) typedef Ref reference; // (4) typedef size_t size_type; typedef ptrdiff_t difference_type; // (5) typedef T** map_pointer; typedef __deque_iterator self; // 保持与容器的联结 T* cur; // 此迭代器所指之缓冲区中的现行（current）元素 T* first; // 此迭代器所指之缓冲区头 T* last; // 此迭代器所指之缓冲区尾（含备用空间） map_pointer node; __deque_iterator(T* x, map_pointer y) : cur(x), first(*y), last(*y + buffer_size()), node(y) {} __deque_iterator() : cur(0), first(0), last(0), node(0) {} __deque_iterator(const iterator&amp; x) : cur(x.cur), first(x.first), last(x.last), node(x.node) {}} 其中用来决定缓冲区大小的函数buffer_size()，调用__deque_buf_size() 123456789// 如果 n 不为 0，传回 n，表示 buffer size 由使用者自定。// 如果 n 为 0，表示buffer size 使用预设值，那么// 如果 sz（元素大小，sizeof(value_type)）小于 512，传回 512/sz，// 如果 sz 不小于 512，传回 1。inline size_t __deque_buf_size(size_t n, size_t sz){ return n != 0 ? n : (sz &lt; 512 ? size_t(512 / sz) : size_t(1));} 有了迭代器，缓存区，中控map，我们的deque的原型就出来啦： 迭代器操作迭代器到buffer边缘，则需要请求中控map，看怎么跳转buffer。 12345void set_node(map_pointer new_node) { node = new_node; first = *new_node; last = first + difference_type(buffer_size());} 解引用操作： 12reference operator*() const { return *cur; }pointer operator-&gt;() const { return &amp;(operator*()); } 计算两迭代器之间距离： 12345// 两个iterator相减，计算距离difference_type operator-(const self&amp; x) const { return difference_type(buffer_size()) * (node - x.node - 1) + (cur - first) + (x.last - x.cur);} 迭代器的++、–操作： 123456789101112131415161718192021222324252627282930// 参考 More Effective C++, item6: Distinguish between prefix and// postfix forms of increment and decrement operators.self&amp; operator++() { ++cur; // 切换至下一个元素。 if (cur == last) { // 如果已达所在缓冲区的尾端， set_node(node + 1); // 就切换至下一个节点（亦即缓冲区） cur = first; // 的第一个元素。 } return *this;}self operator++(int) { self tmp = *this; ++*this; return tmp;}self&amp; operator--() { if (cur == first) { // 如果已达所在缓冲区的头端， set_node(node - 1); // 就切换至前一个节点（亦即缓冲区） cur = last; // 的最后一个元素。 } --cur; // 切换至前一个元素。 return *this;}self operator--(int) { self tmp = *this; --*this; return tmp;} 迭代器+一个数值访问实现： 123456789101112131415161718192021222324252627282930313233343536// 參考 More Effective C++, item22: Consider using op= instead of// stand-alone op.self operator+(difference_type n) const { self tmp = *this; return tmp += n; // 调用operator+=}self&amp; operator+=(difference_type n) { difference_type offset = n + (cur - first); if (offset &gt;= 0 &amp;&amp; offset &lt; difference_type(buffer_size())) // 目标位置在同一缓冲区內 cur += n; else { // 目标位置不在同一缓冲区內 difference_type node_offset = offset &gt; 0 ? offset / difference_type(buffer_size()) : -difference_type((-offset - 1) / buffer_size()) - 1; // 切换至正确的节点（亦即缓冲区） set_node(node + node_offset); // 切换至正确的元素 cur = first + (offset - node_offset * difference_type(buffer_size())); } return *this;}// 參考 More Effective C++, item22: Consider using op= instead of // stand-alone op.self operator-(difference_type n) const { self tmp = *this; return tmp -= n; // 调用operator-=}self&amp; operator-=(difference_type n) { return *this += -n; }// 以上利用operator+= 来完成 operator-= 随机访问实现，模拟连续空间： 123//随机存取实现reference operator[](difference_type n) const { return *(*this + n); }// 以上调用operator*, operator+ 迭代器的比较操作： 12345bool operator==(const self&amp; x) const { return cur == x.cur; }bool operator!=(const self&amp; x) const { return !(*this == x); }bool operator&lt;(const self&amp; x) const { return (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node);} deque的数据结构deque除了维护一个map中控和map中控大小外，还维护了start、finish两个迭代器，分别指向第一个buffer的第一个元素和最后buffer的最后一个元素的下一个位置（左闭右开）。map中控大小的作用是：一旦节点不足，就得配置一块更大的map。 deque的数据结构如下： 1234567891011121314151617181920212223template &lt;class T, class Alloc = alloc, size_t BufSiz = 0&gt; class deque {public: // Basic types typedef T value_type; typedef value_type* pointer; typedef value_type&amp; reference; typedef size_t size_type; typedef ptrdiff_t difference_type;protected: // Internal typedefs typedef pointer* map_pointer; static size_type buffer_size() {//返回 return __deque_buf_size(BufSiz, sizeof(value_type)); } static size_type initial_map_size() { return 8; }protected: // Data members map_pointer map;//指向指针数组 size_type map_size;//指针数组元素个数 iterator start;//开始迭代器，其中cur指向头部元素 iterator finish;//结束迭代器，其中cur指向尾部元素后面的一个元素} deque的基本对外接口： 123456789101112131415161718192021222324252627282930public: // Basic accessorsiterator begin() { return start; }iterator end() { return finish; }const_iterator begin() const { return start; }const_iterator end() const { return finish; }reference operator[](size_type n) { return start[difference_type(n)]; // 调用 __deque_iterator&lt;&gt;::operator[]}const_reference operator[](size_type n) const { return start[difference_type(n)];}reference front() { return *start; } // 调用 __deque_iterator&lt;&gt;::operator*reference back() { iterator tmp = finish; --tmp; // 调用 __deque_iterator&lt;&gt;::operator-- return *tmp; // 调用 __deque_iterator&lt;&gt;::operator*}size_type size() const { return finish - start; }// 以上调用iterator::operator-size_type max_size() const { return size_type(-1); }bool empty() const { return finish == start; } deque的构造与内存管理deque的ctordeque自行定义了两个空间配置器： 12345protected: // Internal typedefs// 专属之空间配置器，每次配置一个元素大小typedef simple_alloc&lt;value_type, Alloc&gt; data_allocator;// 专属之空间配置器，每次配置一个指标大小typedef simple_alloc&lt;pointer, Alloc&gt; map_allocator; 并有如下构造函数： 12345deque(size_type n, const value_type&amp; value) : start(), finish(), map(0), map_size(0){ fill_initialize(n, value);} fill_initialize()负责产生并安排好deque的结构，并将元素的初值设置好： 123456789101112131415template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::fill_initialize(size_type n, const value_type&amp; value) { create_map_and_nodes(n); // 把deque的结构都产生并安排好 map_pointer cur; __STL_TRY { // 为每个节点的缓冲区設定初值 for (cur = start.node; cur &lt; finish.node; ++cur) uninitialized_fill(*cur, *cur + buffer_size(), value); // 最后一个节点的设定稍有不同（因为尾端可能有备用空间，不必设初值） uninitialized_fill(finish.first, finish.cur, value); } catch(...) { // &quot;commit or rollback&quot; ：若非全部成功，就一个不留。 } 其中create_map_and_nodes()复制产生并安排好deque的结构： 123456789101112131415161718192021222324252627282930313233343536template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::create_map_and_nodes(size_type num_elements) { // 需要节点数=(元素个数/每个缓冲区可容纳的元素个数)+1 // 如果刚好整除，會多配一个节点。 size_type num_nodes = num_elements / buffer_size() + 1; // 一个 map 要管理几个节点。最少8个，最多是 “所需节点数加2” // （前后各預留一个，扩充時可用）。 map_size = max(initial_map_size(), num_nodes + 2); map = map_allocator::allocate(map_size); // 以上配置出一个 “具有 map_size个节点” 的map。 // 以下令nstart和nfinish指向map所拥有之全部节点的最中央区段。 // 保持在最中央，可使头尾两端的扩充能量一样大。每个节点可对应一个缓冲区。 map_pointer nstart = map + (map_size - num_nodes) / 2; map_pointer nfinish = nstart + num_nodes - 1; map_pointer cur; __STL_TRY { // 为map內的每个現用节点配置缓冲区。所有缓冲区加起来就是deque的空间 // （最后一个缓冲区可能留有一些余裕）。 for (cur = nstart; cur &lt;= nfinish; ++cur) *cur = allocate_node(); } catch(...) { // &quot;commit or rollback&quot; ：若非全部成功，就一个不留。 } // 为deque内的两个迭代器start和end 設定正确的内容。 start.set_node(nstart); finish.set_node(nfinish); start.cur = start.first; // first, cur都是public finish.cur = finish.first + num_elements % buffer_size(); // 前面说过，如果刚好整除，会多配一个节点。 // 此时即令cur指向這多配的一個节点（所对应之缓冲区）的起点。} push_back() &amp; push_front()12345678910public: // push_* and pop_*void push_back(const value_type&amp; t) { if (finish.cur != finish.last - 1) { // 最后缓冲区尚有一个以上的备用空间 construct(finish.cur, t); // 直接在备用空间上建构元素 ++finish.cur; // 調整最后缓冲区的使用状态 } else // 最后缓冲区已无（或只剩一个）元素备用空间。 push_back_aux(t);} 尾端只有一个元素备用空间时，push_back调用push_back_aux()，先设置一整块的buffer，再设置新元素内容，然后更改finish： 1234567891011121314// 只有当 finish.cur == finish.last – 1 时才会被呼叫。// 也就是说只有当最后一个缓冲区只剩一个备用元素空間时才会被呼叫。template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::push_back_aux(const value_type&amp; t) { value_type t_copy = t; reserve_map_at_back(); // 若符合某种条件則必須重换一个map *(finish.node + 1) = allocate_node(); // 配置一个新节点（缓冲区） __STL_TRY { construct(finish.cur, t_copy); // 设值 finish.set_node(finish.node + 1); // 改变finish，令其指向新节点 finish.cur = finish.first; // 設定 finish 的状态 } __STL_UNWIND(deallocate_node(*(finish.node + 1)));} push_front()和push_back()同理： 123456789101112131415161718192021222324252627282930void push_front(const value_type&amp; t) { if (start.cur != start.first) { // 第一缓冲区尚有备用空間 construct(start.cur - 1, t); // 直接在备用空間上建构元素 --start.cur; // 调整第一缓冲区的使用状态 } else // 第一缓冲区已无备用空間 push_front_aux(t);}// 只有当start.cur == start.first時才会被呼叫。// 也就是说只有当第一个缓冲区沒有任何备用元素時才会被呼叫。template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::push_front_aux(const value_type&amp; t) { value_type t_copy = t; reserve_map_at_front(); // 若符合某种条件則必須重换一个map *(start.node - 1) = allocate_node(); // 配置一个新节点（缓冲区） __STL_TRY { start.set_node(start.node - 1); // 改变start，令其指向新节点 start.cur = start.last - 1; // 设定 start的状态 construct(start.cur, t_copy); // 设值 } catch(...) { // &quot;commit or rollback&quot; ：若非全部成功，就一个不留。 start.set_node(start.node + 1); start.cur = start.first; deallocate_node(*(start.node - 1)); throw; }} 其中，整治map的操作reserve_map_at_back()和reserve_map_at_front()为调用reallocate_map()： 12345678910111213void reserve_map_at_back (size_type nodes_to_add = 1) { if (nodes_to_add + 1 &gt; map_size - (finish.node - map)) // 如果 map 尾端的节点备用空间不足 // 符合以上条件則必須重换一个map（配置更大的，拷贝原來的，释放原來的） reallocate_map(nodes_to_add, false);}void reserve_map_at_front (size_type nodes_to_add = 1) { if (nodes_to_add &gt; start.node - map) // 如果 map 前端的节点备用空间不足 // 符合以上条件則必須重换一个map（配置更大的，拷贝原來的，释放原來的） reallocate_map(nodes_to_add, true);} reallocate_map()函数实现为： 12345678910111213141516171819202122232425262728293031323334template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::reallocate_map(size_type nodes_to_add, bool add_at_front) { size_type old_num_nodes = finish.node - start.node + 1; size_type new_num_nodes = old_num_nodes + nodes_to_add; map_pointer new_nstart; if (map_size &gt; 2 * new_num_nodes) { new_nstart = map + (map_size - new_num_nodes) / 2 + (add_at_front ? nodes_to_add : 0); if (new_nstart &lt; start.node) copy(start.node, finish.node + 1, new_nstart); else copy_backward(start.node, finish.node + 1, new_nstart + old_num_nodes); } else { size_type new_map_size = map_size + max(map_size, nodes_to_add) + 2; // 配置一块空間，准备给新map使用。 map_pointer new_map = map_allocator::allocate(new_map_size); new_nstart = new_map + (new_map_size - new_num_nodes) / 2 + (add_at_front ? nodes_to_add : 0); // 把原map 內容拷贝过来。 copy(start.node, finish.node + 1, new_nstart); // 释放原map map_allocator::deallocate(map, map_size); // 设定新map的起始位址与大小 map = new_map; map_size = new_map_size; } // 重新设定迭代器 start 和 finish start.set_node(new_nstart); finish.set_node(new_nstart + old_num_nodes - 1);} deque的元素操作pop_back() &amp; pop_front()pop操作和push操作相反，pop是要把元素拿掉，push需要考虑加入buffer，而pop则需要考虑释放buffer。 12345678910111213141516171819202122232425262728293031323334353637383940void pop_back() { if (finish.cur != finish.first) { // 最后缓冲区有一个（或更多）元素 --finish.cur; // 调整指标，相当于排除了最后元素 destroy(finish.cur); // 将最后元素析构 } else // 最后缓冲区没有任何元素 pop_back_aux(); // 這里将进行缓冲区的释放工作}// 只有当finish.cur == finish.first时才會被呼叫。template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::pop_back_aux() { deallocate_node(finish.first); // 释放最后一个缓冲区 finish.set_node(finish.node - 1); // 调整 finish 的状态，使指向 finish.cur = finish.last - 1; // 上一个缓冲区的最后一个元素 destroy(finish.cur); // 将该元素析构。}void pop_front() { if (start.cur != start.last - 1) { // 第一缓冲区有一个（或更多）元素 destroy(start.cur); // 将第一元素析构 ++start.cur; // 调整指标，相当于排除了第一元素 } else // 第一缓冲区僅有一个元素 pop_front_aux(); // 這里将进行缓冲区的释放工作}// 只有当start.cur == start.last - 1时才會被呼叫。template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::pop_front_aux() { destroy(start.cur); // 将第一缓冲区的第一个元素析构。 deallocate_node(start.first); // 释放第一缓冲区。 start.set_node(start.node + 1); // 调整 start 的状态，使指向 start.cur = start.first; // 下一个缓冲区的第一个元素。} clear()clear()用于清空deque，deque在初始的时候有一个buffer，因此clear之后，也应该有一个buffer。 1234567891011121314151617181920212223// 注意，最終需要保留一個緩衝區。這是deque 的策略，也是deque 的初始狀態。template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::clear() { // 以下針對頭尾以外的每一個緩衝區（它們一定都是飽滿的） for (map_pointer node = start.node + 1; node &lt; finish.node; ++node) { // 將緩衝區內的所有元素解構。注意，呼叫的是destroy() 第二版本，見2.2.3節 destroy(*node, *node + buffer_size()); // 釋放緩衝區記憶體 data_allocator::deallocate(*node, buffer_size()); } if (start.node != finish.node) { // 至少有頭尾兩個緩衝區 destroy(start.cur, start.last); // 將頭緩衝區的目前所有元素解構 destroy(finish.first, finish.cur); // 將尾緩衝區的目前所有元素解構 // 以下釋放尾緩衝區。注意，頭緩衝區保留。 data_allocator::deallocate(finish.first, buffer_size()); } else // 只有一個緩衝區 destroy(start.cur, finish.cur); // 將此唯一緩衝區內的所有元素解構 // 注意，並不釋放緩衝區空間。這唯一的緩衝區將保留。 finish = start; // 調整狀態} erase()erase()函数可以清除一个iterator的内容，也可以清除一个范围的内容。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 清除 pos 所指的元素。pos 為清除點。iterator erase(iterator pos) { iterator next = pos; ++next; difference_type index = pos - start; // 清除點之前的元素個數 if (index &lt; (size() &gt;&gt; 1)) { // 如果清除點之前的元素比較少， copy_backward(start, pos, next); // 就搬移清除點之前的元素 pop_front(); // 搬移完畢，最前一個元素贅餘，去除之 } else { // 清除點之後的元素比較少， copy(next, finish, pos); // 就搬移清除點之後的元素 pop_back(); // 搬移完畢，最後一個元素贅餘，去除之 } return start + index;}template&lt;class T, class Alloc, size_t BufSize&gt;deque&lt;T, Alloc, BufSize&gt;::iterator deque&lt;T, Alloc, BufSize&gt;::erase(iterator first, iterator last) { if (first == start &amp;&amp; last == finish) { // 如果清除區間就是整個 deque clear(); // 直接呼叫 clear() 即可 return finish; } else { difference_type n = last - first; // 清除區間的長度 difference_type elems_before = first - start; // 清除區間前方的元素個數 if (elems_before &lt; (size() - n) / 2) { // 如果前方的元素比較少， copy_backward(start, first, last); // 向後搬移前方元素（覆蓋清除區間） iterator new_start = start + n; // 標記 deque 的新起點 destroy(start, new_start); // 搬移完畢，將贅餘的元素解構// 以下將贅餘的緩衝區釋放 for (map_pointer cur = start.node; cur &lt; new_start.node; ++cur) data_allocator::deallocate(*cur, buffer_size()); start = new_start; // 設定 deque 的新起點 } else { // 如果清除區間後方的元素比較少 copy(last, finish, first); // 向前搬移後方元素（覆蓋清除區間） iterator new_finish = finish - n; // 標記 deque 的新尾點 destroy(new_finish, finish); // 搬移完畢，將贅餘的元素解構// 以下將贅餘的緩衝區釋放 for (map_pointer cur = new_finish.node + 1; cur &lt;= finish.node; ++cur) data_allocator::deallocate(*cur, buffer_size()); finish = new_finish; // 設定 deque 的新尾點 } return start + elems_before; }} insert()insert()功能：在某一点之前插入一个元素，并设定其值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 在position 處安插一個元素，其值為 xiterator insert(iterator position, const value_type &amp;x) { if (position.cur == start.cur) { // 如果安插點是deque 最前端 push_front(x); // 交給push_front 去做 return start; } else if (position.cur == finish.cur) { // 如果安插點是deque 最尾端 push_back(x); // 交給push_back 去做 iterator tmp = finish; --tmp; return tmp; } else { return insert_aux(position, x); // 交給 insert_aux 去做 }}template&lt;class T, class Alloc, size_t BufSize&gt;typename deque&lt;T, Alloc, BufSize&gt;::iteratordeque&lt;T, Alloc, BufSize&gt;::insert_aux(iterator pos, const value_type &amp;x) { difference_type index = pos - start; // 安插點之前的元素個數 value_type x_copy = x; if (index &lt; size() / 2) { // 如果安插點之前的元素個數比較少 push_front(front()); // 在最前端加入與第一元素同值的元素。 iterator front1 = start; // 以下標示記號，然後進行元素搬移... ++front1; iterator front2 = front1; ++front2; pos = start + index; iterator pos1 = pos; ++pos1; copy(front2, pos1, front1); // 元素搬移 } else { // 安插點之後的元素個數比較少 push_back(back()); // 在最尾端加入與最後元素同值的元素。 iterator back1 = finish; // 以下標示記號，然後進行元素搬移... --back1; iterator back2 = back1; --back2; pos = start + index; copy_backward(pos, back2, back1); // 元素搬移 } *pos = x_copy; // 在安插點上設定新值 return pos;}","link":"/2023/03/05/stl-deque/"},{"title":"STL - vector源码分析","text":"vector概述向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。 vector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率，即“配置新空间/数据移动/释放旧空间”的这个过程。 vector的主要定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// alloc 是SGI STL的空间配置器template&lt;class T,class Alloc=alloc&gt;class vector{ public: //vector的嵌套型别定义 typedef T value_type; typedef value_type* pointer; typedef value_type* iterator; typedef value_type* reference; typedef size_t size_type; typedef ptrdiff_t difference_type; protected: //simple_alloc 是SGI STL的空间配置器 typedef simple_alloc&lt;value_type,Alloc&gt; data_allocator; iterator start;//表示目前使用空间的头 iterator finish;//表示目前使用空间的尾 iterator end_of_storage;//表示目前可用空间的尾 void insert_aux(iterator position,const T&amp; x); void deallocate(){ if(start) data_allocator::deallocate(start,end_of_storage-start); } void fill_initialize(size_type n,const T&amp; value) { start=allocate_and_fill(n,value); finish=start+n; end_of_storage=finsih; } public: iterator begin(){return start;} iterator end(){return finish;} size_type size() const {return size_type(end()-begin());} size_type capacity() const {return size_type(end_of_storage-begin());} bool empty() const {return begin()==end();} reference operator[](size_type n) {return *(begin()+n);} vector():start(0),finish(0),end_of_storage(0){} vector(size_type n,const T&amp; value){fill_initialize(n,value);} vector(int n,const T&amp; value){fill_initialize(n,value);} vector(long n,const T&amp; value){fill_initialize(n,value);} explicit vector(size_type n){fill_initialize(n,T());} ~vector(){ destroy(start,finish); deallocate(); } reference front(){return *begin();}//第一个元素 reference back() {return *(end()-1);}//最后一个元素 void push_back(const T&amp; x){//将元素插入至最尾端 if(finish!=end_of_storage){ construct(finish,x); ++finish; } else insert_aux(end(),x); } void pop_back(){//将最尾端元素取出 --finish; destroy(finish);//全局函数 } iterator erase(iterator position){//清除某位置上的元素 if(position+1 !=end) { copy(position+1,finish,position);//后续元素往前移动 } --finish; destroy(finish); return position; } void resize(size_type new_size,const T&amp; x) { if(new_size&lt;size()) erase(begin()+new_size,end()); else insert(end(),new_size-size(),x); } void resize(size_type new_size){resize(new_size,T());} void clear() {erase(begin(),end());} protected: //配置空间并填满内容 iterator allocate_and_fill(size_type n,const T&amp; x) { iterator result=data_allocator::allocate(n); uninitialized_fill_n(result,n,x); return result; }}; 这么大一串代码看着头有点晕，那就上个图来表示吧： vector的迭代器vector维护的是一个连续的线性空间,由于是连续线性空间,所以其迭代器所要进行的一些操作比如:operator*,operator-&gt;,operator+,operator-,operator++,operator–等等普通的指针都可以满足所以vector的迭代器就是普通指针。通过普通指针也可让vector随机存取(所以vector的迭代器是Random Access Iterator). 迭代器的类型有5种： 123456输入迭代器input_iterator： 只读，且只能一次读操作，支持操作：++p,p++,!=,==,=*p,p-&gt;；输出迭代器output_iterator： 只写，且只能一次写操作，支持操作：++p,p++；正向迭代器forward_iterator： 可多次读写，支持输入输出迭代器的所有操作；双向迭代器bidirectional_iterator： 支持正向迭代器的所有操作，且支持操作：--p,--p；随机访问迭代器random_access_iterator： 除了支持双向迭代器操作外，还支持：p[n],p+n,n+p,p-n,p+=n,p-=n,p1-p2,p1&lt;p2,p1&gt;p2,p1&gt;=p2,p1&lt;=p2； vector源码中迭代器的定义如下： 123456template&lt;class T,class Alloc=alloc&gt;class vector{ public: typedef T value_type; typedef value_type* iterator;//vector的迭代器是普通指针}; 其实，iterator就是一个指针，即有以下代码。 12vector&lt;int&gt;::iterator ivite; // int*vector&lt;Shape&gt;::iterator svite; //Shape* vector的数据结构正如上面看到的，vector的数据结构如下代码，就是三根指针。vector所表示的是一片线形的连续空间，就相当于一个array，它以start和finish分别指向头和尾（左闭右开），表示连续区间内目前已经使用的范围，并以迭代器end_of_storage指向整块连续空间的尾端。 12345678template&lt;class T,class Alloc=alloc&gt;class vector{...protected: iterator start; iterator finish; iterator end_of_storage;}; 还是上面那张图：结合图像，我们可以看到，[start,finish)这块区域，就是已经放了元素的区域;而[finish,end_of_storage)这块区域则是没有放元素的备用空间。此时vector的大小是size，也就是finish-start，end_of_storage-start则是vector目前总共能放的元素个数。如果finish==end_of_storage，则说明现在这个vector是满了的，我们需要对其扩充空间。即：“配置新空间-&gt;数据移动-&gt;释放旧空间”这个动作，参考下图。 通过这三个迭代器,就可以实现很多操作,比如提供首尾标示,大小,容量,空容器判断,[ ]运算符,最前端元素,最后端元素等。 1234567891011121314template &lt;class T,class Alloc=alloc&gt;class vector{...public: iterator begin(){return start;} iterator end(){return finish;} size_type size() const {return size_type(end()-begin());} size_type capacity() const {return size_type(end_of_storage-begin());} bool empty() const {return begin()==end();} reference operator[](size_type n){return *(begin()+n);} reference front(){return *begin();} reference back() {return *(end()-1);}...}; vector的构造与析构vector提供了许多构造函数： 12345678910111213141516171819202122//默认构造函数vector():start(0),finish(0),end_of_storage(0){}//指定大小和初值vector(size_type n,const T&amp; value){fill_initialize(n,value);}vector(int n,const T&amp; value){fill_initialize(n,value);}vector(long n,const T&amp; value){fill_initialize(n,value);}explicit vector(size_type n){fill_initialize(n,T());} void fill_initialize(size_type n,const T&amp; value){ start=allocate_and_fill(n,value); finish=start+n; end_of_storage=finsih;}//配置空间并填满内容iterator allocate_and_fill(size_type n,const T&amp; x){ iterator result=data_allocator::allocate(n); uninitialized_fill_n(result,n,x); return result;} 对于指定大小和初值的构造方式，其是调用了fill_initialize()，fill_initialize()又调用了uninitialized_fill_n()，uninitialized_fill_n()会根据第一个参数的类别来判断是采用fill_n()还是反复调用construct()来完成vector的构造。 析构函数为：实现了调用析构函数和释放内存空间两个步骤。 1234~vector(){ destroy(start,finish); //全局函数，如果不是trival destructor，则一个个调用析构函数 deallocate(); // deallocate() is a member function of vector class} vector的扩容机制”配置新空间-&gt;数据移动-&gt;释放旧空间“这个动作一般发生于push_back()元素时，push_back()函数的作用为：将新元素插入到vector的尾端。该函数首先检查是否还有备用空间，如果有，则直接在备用空间上构造，并调整迭代器finish，使vector增大；如果没有备用空间了，则去扩充空间（配置新空间-&gt;数据移动-&gt;释放旧空间）。 push_back()的源码如下（此为GNU）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void push_back(const T&amp; x) { if (finish != end_of_storage) { //若当前还有备用空间 construct(finish, x); //将当前水位的值设为x ++finish; //提升水位 } else insert_aux(end(), x); }template &lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert_aux(iterator position, const T&amp; x) { if (finish != end_of_storage) { construct(finish, *(finish - 1)); ++finish; T x_copy = x; copy_backward(position, finish - 2, finish - 1); *position = x_copy; } else { const size_type old_size = size(); //获取之前数组的大小 //以上原则，如果原大小为0，则配置1（个元素） //如果原大小不为0，则配置原大小的两倍 //前半段用来放置原数据，后半段用来放置新数据 const size_type len = old_size != 0 ? 2 * old_size : 1; iterator new_start = data_allocator::allocate(len); //重新分配新数组的起始迭代器 iterator new_finish = new_start; __STL_TRY { new_finish = uninitialized_copy(start, position, new_start); //将旧数组的值重新分配给当前的新数组 construct(new_finish, x); //将当前数组的水位的值设为x ++new_finish; //提升新数组的水位 new_finish = uninitialized_copy(position, finish, new_finish); //这语句感觉可有可无，因为它根本就不会执行，position即last，而finish也是last } # ifdef __STL_USE_EXCEPTIONS catch(...) { //如果重新构造的新数组出现异常，则销毁当前新创建的数组，并释放内存空间 destroy(new_start, new_finish); data_allocator::deallocate(new_start, len); throw; }# endif /* __STL_USE_EXCEPTIONS */ destroy(begin(), end()); //将旧数组的空间释放掉 deallocate(); start = new_start; //new_start记录新数组的起始位置 finish = new_finish; //重新设置当前水位的指针 end_of_storage = new_start + len; //设置新数组的容量 }} 所谓动态增加大小，并不是在原空间之后接续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。 因此，对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了。 需要注意的是：不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。 vector的一些其他操作：pop_back,erase,clear,insert pop_back()源码:即finish回退一步，然后调用析构函数即可。 12345//将尾端元素拿掉，并调整大小void pop_back(){ --finish;//将尾端标记往前移动一格，表示将放弃尾端元素 destroy(finish);} erase()与clear()源码：要注意这里第一个erase的last并不会删除，制定first和last，删除的区间为[first,last)，因为stl的迭代器都是左闭右开的。 12345678910111213141516171819202122//清除[first,last)中的所有元素iterator erase(iterator first,iterator last){ //将[last,finish)前移动到[first,finish-(last-first)） iterator i=copy(last,finish,first); //析构之 destroy(i,finish); //调整水位 finish=finish-(last-first); return first;}//清除某位置上的元素iterator erase(iterator position){ if(position+1 !=end){ copy(position+1,finish,position);//后续元素往前移动 } --finish; destroy(finish); return position;}void clear() {erase(begin(),end());} erase()左闭右开测试程序，由此例可得出ed所指向内容不会被erase()，也可以这么想：如果传入end()为last，end()是不可以被析构的，所以last也不会被析构。 12345678910int main(){ vector&lt;int&gt; a = {0,1,2,3,4,5,6}; auto bg = ++a.begin(); // bg指向1 auto ed = --a.end(); --ed; // ed指向5 a.erase(bg,ed); for(auto &amp;i : a){ // ans : 0 5 6 cout &lt;&lt; i &lt;&lt; &quot; &quot;; }} insert()源码：和erase()类似，就是中间断开增加元素，需要拷贝很多值，效率较低。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//下面是vector::insert()实现内容//从position开始，插入n个元素，元素初值为xtemplate&lt;class T,class Alloc&gt;void vector&lt;T,Alloc&gt;::insert(iterator position,size_type n,const T&amp; x){ if(n!=0) { //当n！=0才进行以下操作 if(size_type(end_of_storage-finish)&gt;=n) { //备用空间大于等于“新增元素个数” T x_copy=x; //以下计算插入点之后的现有元素个数 const size_type elems_after=finish-position; iterator old_finish=finish; if(elems_after&gt;n) { //“插入点之后的现有元素个数”大于“新增元素个数” uninitialized_copy(finish-n,finish,finish); finish+=n;//将vector尾端标记后移 copy_backward(position,old_finish-n,old_finish); fill(position,position+n,x_copy);//从插入点开始填入新值 } else{ //“插入点之后的现有元素个数”小于等于“新增元素个数” uninitialized_fill_n(finish,n-eles_after,x_copy); finish+=n-elems_after; uninitialized_copy(position,old_finish,finish); finish+=elems_after; fill(position,old_finish,x_copy); } } else{ //备用空间小于“新增元素个数”（那就必须配置额外的内存） //首先决定新长度：旧长度的两倍，或旧长度+新增元素个数 const size_type old_size=size(); const size_type len=old_size+max(old_size,n); //配置新的vector空间 iterator new_start=data_allocator::allocate(n); iterator new_finish=new_start; __STL_TRY{ //以下首先将旧vector的插入点之前的元素复制到新空间 new_finish=uninitialized_copy(start,position,new_start); //以下再将新增元素（初值皆为n）填入新空间 new_finish=uninitialized_fill_n(new_finish,n,x); //以下再将旧vector的插入点之后的元素复制到新空间 new_finish=uninitialized_copy(position,finish,new_finish); } #ifdef __STL_USE_EXCEPTIONS catch(...){ //如有异常发生，实现“commit or rollback” semantics destroy(new_start,new_finish); data_allocator::deallocate(new_start,len); throw; } #endif /*__STL_USE_EXCEPTIONS*/ //以下清除并释放旧的vector destroy(start,finish); deallocate(); //以下调整水位标记 start=new_start; finish=new_finish; end_of_storage=new_start+len; } }} vector常见question： 为什么要成倍的扩容而不是一次增加一个固定大小的容量呢？ 可参考：https://www.drdobbs.com/c-made-easier-how-vectors-grow/184401375 1234567891011121314以成倍方式增长 假定有 n 个元素,倍增因子为 m；完成这 n 个元素往一个 vector 中的 push_back 操作，需要重新分配内存的次数大约为 logm(n)；第 i 次重新分配将会导致复制 m^(i) (也就是当前的vector.size() 大小)个旧空间中元素;n 次 push_back 操作所花费的时间复制度为O(n): m / (m - 1)，这是一个常量，均摊分析的方法可知，vector 中 push_back 操作的时间复杂度为常量时间.一次增加固定值大小 假定有 n 个元素,每次增加k个；第i次增加复制的数量为为：100in 次 push_back 操作所花费的时间复杂度为O(n^2): 均摊下来每次push_back 操作的时间复杂度为O(n)；总结：对比可以发现采用采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容 为什么是以两倍的方式扩容而不是三倍四倍，或者其他方式呢？ 可参考：https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md 其实VC的1.5倍扩容是更佳的。 It is well known that std::vector grows exponentially (at a constant factor) in order to avoid quadratic growth performance. The trick is choosing a good factor. Any factor greater than 1 ensures O(1) amortized append complexity towards infinity. But a factor that’s too small (say, 1.1) causes frequent vector reallocation, and one that’s too large (say, 3 or 4) forces the vector to consume much more memory than needed. The initial HP implementation by Stepanov used a growth factor of 2; i.e., whenever you’d push_back into a vector without there being room, it would double the current capacity. This was not a good choice: it can be mathematically proven that a growth factor of 2 is rigorously the worst possible because it never allows the vector to reuse any of its previously-allocated memory. Despite other compilers reducing the growth factor to 1.5, gcc has staunchly maintained its factor of 2. This makes std::vector cache- unfriendly and memory manager unfriendly. ​ 当使用2作为倍数增长时，每次扩展的尺寸的刚好大于之前所分配的总和。换而言之，之前分配的内存空间不可以被使用，对缓存不友好。 1.5倍增长和2倍增长对比： 3. vector与list的区别与应用？区别：应用：vector 拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在 乎插入和删除的效率，使用 vector。list 拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用 list。 resize和reserve区别？ 参考：https://www.cnblogs.com/cxl-/p/14482639.html vector？ vector是vector的一个特化版本，之前一个byte存一个bool，在vector的设计中一个byte存8个bool，用一个bit来表示true和false。 详细的以后再说。 参考文献： [1] https://blog.csdn.net/vjhghjghj/article/details/88713401 [2] https://blog.csdn.net/sinat_33442459/article/details/75142672 [3] https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md [4] https://www.drdobbs.com/c-made-easier-how-vectors-grow/184401375 [5] 侯捷.STL源码剖析[M].武汉：华中科技大学出版社，2002.6：115-128.","link":"/2023/03/05/stl-vector/"},{"title":"missing semester - 学习笔记（汇总）","text":"MIT - The Missing Semester of Your CS Education 课程笔记汇总，该课程介绍了一些实际开发所需要使用到的小东西。： The shell Shell Tools and Scripting Editors (Vim) Data Wrangling Command-line Environment Version Control (Git) Debugging and Profiling Metaprogramming Security and Cryptography Potpourri","link":"/2023/03/07/missing-sum/"},{"title":"操作系统 - 比例份额调度","text":"概述比例份额（proportional-share）调度程序（又称公平份额（fair-share）调度程序）。比例份额算法基于一个简单的想法：调度程序的最终目标，是确保每个工作获得一定比例的CPU时间，而不是优化周转时间和响应时间。 彩票调度（lottery scheduling）是比例份额调度程序的一个例子。基本思想很简单：每隔一段时间，都会举行一次彩票抽奖，以确定接下来应该运行哪个进程。越是应该频繁运行的进程，越是应该拥有更多地赢得彩票的机会。 彩票调度概念与实现彩票数表示份额彩票调度中的彩票数（ticket）代表了进程（或用户或其他）占有某个资源的份额。一个进程拥有的彩票数占总彩票数的百分比，就是它占有资源的份额。 通过不断定时地（比如，每个时间片）抽取彩票（调度程序知道彩票总数，取之间一随机数即可），彩票调度从概率上（但不是确定的） 获得这种份额比例。 例子： 假设有两个进程A和B，A拥有75张彩票，B拥有25张。因此我们希望A占用75%的CPU时间，而B占用25%。 随着这两个工作运行的时间越长，它们得到的 CPU 时间比例就会越接近期望。 彩票机制 彩票货币（ticket currency） 这种方式允许拥有一组彩票的用户以他们喜欢的某种货币，将彩票分给自己的不同工作。之后操作系统再自动将这种货币兑换为正确的全局彩票。 彩票转让（ticket transfer） 通过转让，一个进程可以临时将自己的彩票交给另一个进程。这种机制在客户端/服务端交互的场景中尤其有用。 彩票通胀（ticket inflation）。利用通胀，一个进程可以临时提升或降低自己拥有的彩票数量。通胀可以用于进程之间相互信任的环境。在竞争环境中，进程之间互相不信任，这种机制就没什么意义。 实现只需要一个不错的随机数生成器来选择中奖彩票和一个记录系统中所有进程的数据结构（一个列表），以及所有彩票的总数就可以实现彩票调度。 假定我们用列表记录进程。 123456789101112131415161718// counter: used to track if we've found the winner yetint counter = 0;// winner: use some call to a random number generator to// get a value, between 0 and the total # of ticketsint winner = getrandom(0, totaltickets);// current: use this to walk through the list of jobsnode_t *current = head;// loop until the sum of ticket values is &gt; the winnerwhile (current) { counter = counter + current-&gt;tickets; if (counter &gt; winner) break; // found the winner current = current-&gt;next;}// 'current' is the winner: schedule it... 如果用数组形式，可以采取前缀和+二分实现。 步长调度虽然随机方式可以使得调度程序的实现简单（且大致正确），但偶尔并不能产生正确的比例，尤其在工作运行时间很短的情况下。由于这个原因，Waldspurger提出了步长调度（stride scheduling），一个确定性的公平分配算法。 步长调度中的每个工作都有自己的步长，这个值与票数值成反比（取各票数的一个较大公倍数/各票数）。 当需要进行调度时，选择目前拥有最小行程值的进程，并且在运行之后将该进程的行程值增加一个步长。 下面是Waldspurger给出的伪代码： 1234current = remove_min(queue); // pick client with minimum passschedule(current); // use resource for quantumcurrent-&gt;pass += current-&gt;stride; // compute next pass using strideinsert(queue, current); // put back into the queue 可以使用优先队列实现之。 与彩票调度的对比彩票调度有一个步长调度没有的优势——不需要全局状态。 假如一个新的进程在步长调度执行过程中加入系统，应该怎么设置它的行程值呢？如果设置成0，新来的进程就独占CPU了。 彩票调度算法不需要对每个进程记录全局状态，只需要用新进程的票数更新全局的总票数就可以了。 因此彩票调度算法能够更合理地处理新加入的进程。 总结彩票调度和步长调度并没有作为CPU调度程序被广泛使用，原因如下： 不能很好地适合I/O； 最难的票数分配问题并没有确定的解决方式， 比例份额调度程序只有在这些问题可以相对容易解决的领域更有用（例如容易确定份额比例）。例如在虚拟（virtualized）数据中心中，你可能会希望分配1/4的CPU周期给Windows虚拟机，剩余的给Linux系统，比例分配的方式可以更简单高效。 reference[1] 操作系统导论（ostep）","link":"/2023/03/07/os-ostep-lottery-scheduling/"},{"title":"操作系统 - 多级反馈队列","text":"概述1962年，Corbato首次提出多级反馈队列，应用于兼容时分共享系统（CTSS）。Corbato因在CTSS中的贡献和后来在Multics中的贡献，获得了ACM颁发的图灵奖（Turing Award）。该调度程序经过多年的一系列优化，出现在许多现代操作系统中。 多级反馈队列需要解决两方面的问题： 优化周转时间（T 周转时间= T 完成时间−T 到达时间 ） 降低响应时间（T 响应时间= T 首次运行−T 到达时间 ） 设计规则定义MLFQ 中有许多独立的队列（queue），每个队列有不同的优先级（priority level）。任何时刻，一个工作只能存在于一个队列中。 规则 1：如果 A 的优先级 &gt; B 的优先级，运行 A（不运行 B）。 规则 2：如果 A 的优先级 = B 的优先级，轮转运行 A 和 B。 规则 3：工作进入系统时，放在最高优先级（最上层队列）。 规则 4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）。 规则 5：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。 调度原则规则1和规则2为基础规则，保证了高优先级的先运行，同等优先级的轮转执行。 改变优先级规则3描述了多级反馈队列的初始状态，即一个进程进入队列时，先将其放入最高优先级队列中。 规则4描述了多级反馈队列的下调优先级（down）原则，采用时间配额制度(在MLFQ 的每层队列提供更完善的 CPU 计时方式（accounting）。 调度程序应该记录一个进程在某一层中消耗的总时间，而不是在调度时重新计时)，可以防止某些恶意程序几乎独占CPU。 提升优先级规则5的存在是为了避免饥饿（starvation）问题。解决方法是周期性地提升（boost）所有工作的优先级。 总结MLFQ不需要对工作的运行方式有先验知识，而是通过观察工作的运行来给出对应的优先级。通过这种方式，MLFQ可以同时满足各种工作的需求：对于短时间运行的交互型工作，获得类似于SJF/STCF的很好的全局性能，同时对长时间运行的CPU密集型负载也可以公平地、不断地稳步向前。 因此，许多系统使用某种类型的MLFQ作为自己的基础调度程序，包括类BSD UNIX系统、Solaris以及Windows NT和其后的Window系列操作系统。 Linux Real-Time Scheduler，使用Multi-level Queue优先级调度 每个任务有自己的优先级、具体策略 具体策略可根据任务需求针对性选择 SCHED_RR:任务执行一定时间片后挂起 SCHED_FIFO:任务执行至结束 reference[1] 操作系统导论（ostep） [2] 上海交通大学并行与分布式系统研究所-进程/线程调度","link":"/2023/03/07/os-ostep-multi-feedback-scheduling/"},{"title":"Linux各文件夹作用","text":"/bin - 基本命令二进制文件 /sbin - 基本的系统二进制文件，通常是root运行的 /dev - 设备文件，通常是硬件设备接口文件 /etc - 主机特定的系统配置文件 /home - 系统用户的主目录 /lib - 系统软件通用库 /opt - 可选的应用软件 /sys - 包含系统的信息和配置 /tmp - 临时文件( /var/tmp ) 通常重启时删除 /usr/ - 只读的用户数据 /usr/bin - 非必须的命令二进制文件 /usr/sbin - 非必须的系统二进制文件，通常是由root运行的 /usr/local/bin - 用户编译程序的二进制文件 /var -变量文件 像日志或缓存","link":"/2023/03/07/linux-folder-effect/"},{"title":"missing semester - The shell","text":"shell如何寻找诸如echo、date的命令？shell 是一个编程环境，所以它具备变量、条件、循环和函数。在 shell 中执行命令时，实际上是在执行一段 shell 可以解释执行的简短代码。如果用户要求 shell 执行某个指令，但是该指令并不是 shell 所了解的编程关键字，那么它会去查询 环境变量 （environment variable）$PATH，它会列出当 shell 接到某条指令时，进行程序搜索的路径。 当执行 echo 命令时，shell 了解到需要执行 echo 这个程序，随后它便会在 $PATH 中搜索由 : 所分割的一系列目录，基于名字搜索该程序。当找到该程序时便执行。 确定某个程序名代表的是哪个具体的程序，可以使用 which 程序。 Navigating in the shell以Linux/Mac OS为例说明文件系统的使用： 路径 / 代表的是系统的根目录。 如果某个路径以 / 开头，那么它是一个 绝对路径。 其他的路径都是 相对路径 。相对路径是指相对于当前工作目录的路径，当前工作目录可以使用 pwd 命令来获取。 切换目录需要使用 cd 命令。 在路径中，. 表示的是当前目录，而 .. 表示上级目录（空目录中也包含.和.. ）。 一般来说，当运行一个程序时，如果没有指定路径，则该程序会在当前目录下执行。 大多数的命令接受标记（Flag）和选项（带有值的标记）（Option），它们以 - 开头，并可以改变程序的行为。通常，在执行程序时使用 -h 或 --help 标记可以打印帮助信息，以便了解有哪些可用的标记或选项。 这个参数可以打印出更加详细地列出目录下文件或文件夹的信息。 第一个字符 d 表示 missing 是一个目录。 然后接下来的九个字符，每三个字符构成一组（rwx）。它们分别代表了文件所有者（missing），用户组（users） 以及其他所有人具有的权限。其中 - 表示该用户不具备相应的权限。 为了进入某个文件夹，用户需要具备该文件夹以及其父文件夹的“搜索”权限（以“可执行”：x）权限表示。 为了列出它的包含的内容，用户必须对该文件夹具备读权限（r）。 命令 完成动作 注意事项 pwd 打印当前工作目录 cd 切换目录 cd -: 切换空间 ls 查看指定目录下包含哪些文件 mv 重命名或移动文件 source-&gt;dest cp 拷贝文件 source-&gt;dest rm 删除文件 删除文件夹需要使用-r（递归）标记 mkdir 新建文件夹 空格间隔会创建多个文件夹 rmdir 删除文件夹 只能删除空文件夹 Connecting programs在 shell 中，程序有两个主要的“流”： 输入流：当程序尝试读取信息时，它们会从输入流中进行读取。 输出流：当程序打印信息时，它们会将信息输出到输出流中。 通常，一个程序的输入输出流都是终端（程序会默认打开0-2三个fd表示输入、输出、错误）。 符号 动作 &lt; file1 重定向file1至输入流 &gt; file2 重定向file2至输出流 &gt;&gt; file3 向一个文件追加内容 command1 ` ` command2 A versatile and powerful tool对于大多数的类 Unix 系统，根用户（root user）是非常特殊的。 根用户几乎不受任何限制，他可以创建、读取、更新和删除系统中的任何文件。 通常在我们并不会以根用户的身份直接登录系统，因为这样可能会因为某些错误的操作而破坏系统。 在需要的时候使用 sudo 命令。顾名思义，它的作用是可以以 su（super user 或 root 的简写）的身份执行一些操作。 当遇到拒绝访问（permission denied）的错误时，通常是因为此时必须是根用户才能操作。 对于|、&gt;、和 &lt;，需要注意一点，sudo需要加在对应程序前（修改显示器亮度，前者不行，后者可以，tee用于读取标准输入的数据，并将其内容输出成文件）。 12345$ sudo echo 3 &gt; brightnessAn error occurred while redirecting file 'brightness'open: Permission denied$ echo 3 | sudo tee brightness Exercises 在 /tmp 下新建一个名为 missing 的文件夹。 用 man 查看程序 touch 的使用手册。 用 touch 在 missing 文件夹中新建一个叫 semester 的文件。 将以下内容一行一行地写入 semester 文件： 12#!/bin/shcurl --head --silent https://missing.csail.mit.edu 做法1:(\\代表转义) 12echo \\#\\!/bin/sh &gt; semesterecho &quot;curl --head --silent https://missing.csail.mit.edu&quot; &gt;&gt; semester 做法2:(用单引号括住字符(“ ‘)保留了引号内每个字符的文字值) Enclosing characters in single quotes (‘’’) preserves the literal value of each character within the quotes. A single quote may not occur between single quotes, even when preceded by a backslash. 12echo '#!/bin/sh' &gt; semesterecho &quot;curl --head --silent https://missing.csail.mit.edu&quot; &gt;&gt; semester 尝试执行这个文件。例如，将该脚本的路径（./semester）输入到您的shell中并回车。如果程序无法执行，请使用 ls 命令来获取信息并理解其不能执行的原因。 查看 chmod 的手册(例如，使用 man chmod 命令) 使用 chmod 命令改变权限，使 ./semester 能够成功执行 使用 | 和 &gt; ，将 semester 文件输出的最后更改日期信息，写入主目录下的 last-modified.txt 的文件中","link":"/2023/03/07/missing-the-shell/"},{"title":"missing semester - Shell Tools and Scripting","text":"Shell Scripting变量、赋值、字符串在Bash中为变量赋值的语法是foo=bar，访问变量中存储的数值，其语法为 $foo。 需要注意的是，foo = bar （使用空格隔开）是不能正确工作的，因为解释器会调用程序foo 并将 = 和 bar作为参数。(在shell脚本中使用空格会起到分割参数的作用) Bash中的字符串通过' 和 &quot;分隔符来定义，但是它们的含义并不相同。 以'定义的字符串为原义字符串，其中的变量不会被转义。 以&quot;定义的字符串会将变量值进行替换。 12345foo=barecho &quot;$foo&quot;# 打印 barecho '$foo'# 打印 $foo 函数bash 支持函数，它可以接受参数并基于参数进行操作。 下面这个函数是一个例子，它会创建一个文件夹并使用cd进入该文件夹。 1234mcd () { mkdir -p &quot;$1&quot; cd &quot;$1&quot;} Bash中使用特殊变量来表示参数、错误代码和相关变量： $0 - 脚本名 $1 到 $9 - 脚本的参数。 $1 是第一个参数，依此类推。 $@ - 所有参数 $# - 参数个数 $? - 前一个命令的返回值 $$ - 当前脚本的进程识别码 !! - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 sudo !!再尝试一次。 $_ - 上一条命令的最后一个参数。如果你正在使用的是交互式shell，你可以通过按下 Esc 之后键入 . 来获取这个值。 命令通常使用 STDOUT来返回输出值，使用STDERR 来返回错误及错误码，便于脚本以更加友好的方式报告错误。 返回码或退出状态是脚本/命令之间交流执行状态的方式。返回值0表示正常执行，其他所有非0的返回值都表示有错误发生。 布尔运算退出码可以搭配&amp;&amp; (与操作符) 和 || (或操作符)使用，用来进行条件判断，决定是否执行其他程序。它们都属于短路运算符（short-circuiting） 。 同一行的多个命令可以用;分隔。（命令之间没有关系） 程序 true 的返回码永远是0，false 的返回码永远是1。（true肯定成功执行、false肯定执行失败） 1234567891011121314false || echo &quot;Oops, fail&quot;# Oops, failtrue || echo &quot;Will not be printed&quot;#true &amp;&amp; echo &quot;Things went well&quot;# Things went wellfalse &amp;&amp; echo &quot;Will not be printed&quot;#false ; echo &quot;This will always run&quot;# This will always run 命令替换 与 进程替换（process substitution） $( CMD ) 命令替换 (command substitution)：通过 $( CMD ) 这样的方式来执行CMD 这个命令时，它的输出结果会替换掉 $( CMD ) 。例如，如果执行 for file in $(ls) ，shell首先将调用ls ，然后遍历得到的这些返回值。 &lt;( CMD ) 进程替换(process substitution) ：&lt;( CMD ) 会执行 CMD 并将结果输出到一个临时文件中，并将 &lt;( CMD ) 替换成临时文件名。这在我们希望返回值通过文件而不是STDIN传递时很有用。例如： diff &lt;(ls foo) &lt;(ls bar) 会显示文件夹 foo 和 bar 中文件的区别。 $( CMD )替换为输出结果；而&lt;( CMD ) 是替换以一个临时文件名。区别的例子： 12345678# $( CMD )stat $(which vim)# 16777232 1152921500312785999 -rwxr-xr-x 1 root wheel 0 4548272 &quot;Jan 1 16:00:00 2020&quot; &quot;Jan 1 16:00:00 2020&quot; &quot;Jan 1 16:00:00 2020&quot; &quot;Jan 1 16:00:00 2020&quot; 4096 5360 0x80020 /usr/bin/vim# &lt;( CMD )cat &lt;(echo hi)# hiecho &lt;(echo hi)# /dev/fd/13 例子123456789101112131415#!/bin/bashecho &quot;Starting program at $(date)&quot; # date会被替换成日期和时间echo &quot;Running program $0 with $# arguments with pid $$&quot;for file in &quot;$@&quot;; do grep foobar &quot;$file&quot; &gt; /dev/null 2&gt; /dev/null # 如果模式没有找到，则grep退出状态为 1 # 我们将标准输出流和标准错误流重定向到Null，因为我们并不关心这些信息 if [[ $? -ne 0 ]]; then echo &quot;File $file does not have any foobar, adding one&quot; echo &quot;# foobar&quot; &gt;&gt; &quot;$file&quot; fidone Bash的比较在条件语句中，我们比较 $? 是否等于0。 Bash实现了许多类似的比较操作，您可以查看 test 手册。 在bash中进行比较时，尽量使用双方括号 [[ ]] 而不是单方括号 [ ]，这样会降低犯错的几率，尽管这样并不能兼容 sh。 通配符当执行脚本时，经常需要提供形式类似的参数。bash使我们可以轻松的实现这一操作，它可以基于文件扩展名展开表达式。这一技术被称为shell的 通配（ globbing） 通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 ? 和 * 来匹配一个或任意个字符。例如，对于文件foo, foo1, foo2, foo10 和 bar, rm foo?这条命令会删除foo1 和 foo2 ，而rm foo* 则会删除除了bar之外的所有文件。 花括号{} - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。这在批量移动或转换文件时非常方便。 1234567891011121314151617181920212223convert image.{png,jpg}# 会展开为convert image.png image.jpgcp /path/to/project/{foo,bar,baz}.sh /newpath# 会展开为cp /path/to/project/foo.sh /path/to/project/bar.sh /path/to/project/baz.sh /newpath# 也可以结合通配使用mv *{.py,.sh} folder# 会移动所有 *.py 和 *.sh 文件mkdir foo bar# 下面命令会创建foo/a, foo/b, ... foo/h, bar/a, bar/b, ... bar/h这些文件touch {foo,bar}/{a..h}touch foo/x bar/y# 比较文件夹 foo 和 bar 中包含文件的不同diff &lt;(ls foo) &lt;(ls bar)# 输出# &lt; x# ---# &gt; y Shell Tools查看命令如何使用 为对应的命令行添加-h 或 --help 标记。 使用man 命令。man 命令是手册（manual）的缩写，它提供了命令的用户手册。 tldr。 查找文件所有的类UNIX系统都包含一个名为find工具。find命令会递归地搜索符合条件的文件，例如： 12345678# 查找所有名称为src的文件夹find . -name src -type d# 查找所有文件夹路径中包含test的python文件find . -path '*/test/*.py' -type f# 查找前一天修改的所有文件find . -mtime -1# 查找所有大小在500k至10M的tar.gz文件find . -size +500k -size -10M -name '*.tar.gz' 除了列出所寻找的文件之外，find还能对所有查找到的文件进行操作。 1234# 删除全部扩展名为.tmp 的文件find . -name '*.tmp' -exec rm {} \\;# 查找全部的 PNG 文件并将其转换为 JPGfind . -name '*.png' -exec convert {} {}.jpg \\; 更高效的工具： fd 就是一个更简单、更快速、更友好的程序，它可以用来作为find的替代品。它有很多不错的默认设置，例如输出着色、默认支持正则匹配、支持unicode并且它的语法更符合直觉。以模式PATTERN 搜索的语法是 fd PATTERN。 locate ： 通过编译索引或建立数据库的方式来实现更加快速地搜索。locate 使用一个由 updatedb负责更新的数据库，在大多数系统中 updatedb 都会通过 cron每日更新。这便需要我们在速度和时效性之间作出权衡。locate只能通过文件名检索。 查找代码查看文件的内容使用grep命令，它是用于对输入文本进行匹配的通用工具。 经常使用的选项有 ： -C ：获取查找结果的上下文（Context）； -v： 将对结果进行反选（Invert），也就是输出不匹配的结果。 -R： 递归搜索子目录 更高效的工具：ripgrep 查找 shell 命令 按向上的方向键会显示你使用过的上一条命令，继续按上键则会遍历整个历史记录。 history 命令允许您以程序员的方式来访问shell中输入的历史命令。 使用 Ctrl+R 对命令历史记录进行回溯搜索。反复按下就会在所有搜索结果中循环。 Directory NavigationFasd 基于 frecency对文件和文件排序，也就是说它会同时针对频率（frequency ）和时效（ recency）进行排序。默认情况下，fasd使用命令 z 帮助我们快速切换到最常访问的目录。例如， 如果经常访问/home/user/files/cool_project 目录，那么可以直接使用 z cool 跳转到该目录。 对于 autojump，则使用j cool代替即可。 tree可以用来以树的形式表示目录结构。","link":"/2023/03/07/missing-shell-tools/"},{"title":"missing semester - Editors (Vim)","text":"Modal editingVim的设计以大多数时间都花在阅读、浏览和进行少量编辑改动为基础，因此它具有多种操作模式： 正常模式 ：在文件中四处移动光标进行修改 插入模式：插入文本 替换模式：替换文本 可视化（一般，行，块）模式：选中文本块 命令模式：用于执行命令 在不同的操作模式下，键盘敲击的含义也不同。 按下 &lt;ESC&gt; （退出键） 从任何其他模式返回正常模式。 在正常模式，键入 i 进入插入 模式， R 进入替换模式， v 进入可视（一般）模式， V 进入可视（行）模式， &lt;C-v&gt; （Ctrl-V, 有时也写作 ^V）进入可视（块）模式， : 进入命令模式。 BasicsInserting text在正常模式，键入 i 进入插入模式。在插入模式内可以随意插入文本，直到你键入&lt;ESC&gt; 返回正常模式。（一直停留在插入模式内不一定高效）。 Command-line在正常模式下键入 : 进入命令行模式。 在键入 : 后，光标会立即跳到屏幕下方的命令行。 这个模式有很多功能，包括打开，保存，关闭文件，以及 退出 Vim。 :q 退出（关闭窗口） :w 保存（写） :wq 保存然后退出 :e {文件名} 打开要编辑的文件 :ls 显示打开的缓存 :help {标题}打开帮助文档 :help :w 打开 :w 命令的帮助文档 :help w 打开 w 移动的帮助文档 Vim’s interface is a programming languageVim 最重要的设计思想是 Vim 的界面本身是一个程序语言。键入操作 （以及他们的助记名） 本身是命令， 这些命令可以组合使用。 这使得移动和编辑更加高效。 Movement多数时候会在正常模式下，使用移动命令在缓存中导航。在 Vim 里面移动也被称为 “名词”， 因为它们指向文字块。 基本移动: hjkl （左， 下， 上， 右） 词： w （下一个词）， b （上一个词/词初）， e （下一个词/词尾） 行： 0 （行初）， ^ （第一个非空格字符）， $ （行尾） 屏幕： H （屏幕首行）， M （屏幕中间）， L （屏幕底部） 翻页： Ctrl-u （上翻）， Ctrl-d （下翻） 文件： gg （文件头）， G （文件尾） 行数：{行数}G ({行数}为行数) 杂项： % （找到配对，比如括号或者 /* */ 之类的注释对） 查找：f{字符}，t{字符}，F{字符}，T{字符} 查找/到 向前/向后 在本行的{字符} , / ; 用于导航匹配 搜索: /{正则表达式}, n / N 用于导航匹配 Selection可视化模式: 可视化：v 可视化行： V 可视化块：Ctrl+v 可以用移动命令来选中。 Edits i进入插入模式 （insert） 但是对于操纵/编辑文本，不单想用退格键完成 O / o 在之上/之下插入行（open） d{motion} 删除 {motion} （delete） 例如， dw 删除词, d$ 删除到行尾, d0 删除到行头。 dd-删除整行 c{motion} 改变 {motion} （change） 例如， cw 改变词 c{motion} 等同于 d{motion} 再 i进入编辑模式 x 删除字符（等同于 dl） s 替换（substitute）字符（等同于 xi） 可视化模式 + 移动操作（上下左右等移动光标的操作） 选中文字,然后使用 d 删除 或者 c 改变 u 撤销（undo）, &lt;C-r&gt; 重做（redo） y 复制（yank）（其他一些命令比如 d 也会复制） p 粘贴（paste） Counts使用一个数字来结合Movement和Edits，这会执行指定操作若干次。 3w 向前移动三个词 5j 向下移动5行 7dw 删除7个词 Modifiers可以用修饰语改变“名词”的意义。修饰语有 i，表示“内部”或者“在内“，和 a， 表示”周围“。 ci( 改变当前括号内的内容 ci[ 改变当前方括号内的内容 da' 删除一个单引号字符串， 包括周围的单引号","link":"/2023/03/07/missing-vim/"},{"title":"missing semester - Data Wrangling","text":"一些数据处理相关的指令grep用于查找文件里符合条件的字符串 sedsed 是一个基于文本编辑器ed构建的”流编辑器” 。 在 sed 中，可以利用一些简短的命令来修改文件，而不是直接操作文件的内容。 最常用的是 s，即替换命令。s 命令的语法如下：s/REGEX/SUBSTITUTION/, 其中 REGEX 部分是我们需要使用的正则表达式，而 SUBSTITUTION 是用于替换匹配结果的文本。 sed 的正则表达式有些时候是比较奇怪的，它需要在这些模式前添加\\才能使其具有特殊含义。（添加-E选项将正则表达式解释为扩展的正则） 1sed -E 's/.*Disconnected from //' sort &amp; uniqsort 会对其输入数据进行排序。 uniq 用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。 1234567891011121314# Display each line once:sort file | uniq# Display only unique lines:sort file | uniq -u# Display only duplicate lines:sort file | uniq -d# Display number of occurrences of each line along with that line:sort file | uniq -c# Display number of occurrences of each line, sorted by the most frequent:sort file | uniq -c | sort -nr bcbc命令是任意精度计算器语言，通常在linux下当计算器用。 1234567891011# Start `bc` in interactive mode using the standard math library:bc -l# Calculate the result of an expression:bc &lt;&lt;&lt; &quot;(1 + 2) * 2 ^ 2&quot;# Calculate the result of an expression and force the number of decimal places to 10:bc &lt;&lt;&lt; &quot;scale=10; 5 / 3&quot;# Calculate the result of an expression with sine and cosine using `mathlib`:bc -l &lt;&lt;&lt; &quot;s(1) + c(1)&quot; 正则表达式-Regular expressions正则表达式通常以 /开始和结束。有一些字符确实具有表示匹配行为的“特殊”含义。比如： . 除换行符之外的”任意单个字符” * 匹配前面字符零次或多次 + 匹配前面字符一次或多次 [abc] 匹配 a, b 和 c 中的任意一个 (RX1|RX2) 任何能够匹配RX1 或 RX2的结果 ^ 行首 $ 行尾 * 和 + 在默认情况下是贪婪模式，它们会尽可能多的匹配文本。 可以使用regex101网站进行正则表达式的在线调试。 awkawk 是一种编程语言，它非常善于处理文本。 awk 程序接受一个模式串（可选），以及一个代码块，指定当模式匹配时应该做何种操作。默认当模式串即匹配所有行。 在代码块中，$0 表示整行的内容，$1到 $n 为一行中的 n 个区域，区域的分割基于 awk 的域分隔符（默认是空格，可以通过-F来修改）。 1| awk '$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ { print $2 }' 也可像个编程语言一样：BEGIN 也是一种模式，它会匹配输入的开头（ END 则匹配结尾）。然后，对每一行第一个部分进行累加，最后将结果输出。 123BEGIN { rows = 0 }$1 == 1 &amp;&amp; $2 ~ /^c[^ ]*e$/ { rows += $1 }END { print rows } 使用awk可以替代grep和sed。","link":"/2023/03/07/missing-data-wrangling/"},{"title":"missing semester - Command-line Environment","text":"Job Control在shell中可以使用 UNIX 提供的信号机制执行进程间通信。当一个进程接收到信号时，它会停止执行、处理该信号并基于信号传递的信息来改变其执行。信号是一种软件中断。Unix信号如下： Killing a process结束进程： SIGINT （ Ctrl-C ） SIGQUIT （Ctrl-\\）都常常用来发出和终止程序相关的请求。 SIGTERM 则是一个更加通用的、也更加优雅地退出信号。为了发出这个信号我们需要使用 kill命令, 它的语法是： kill -TERM &lt;PID&gt;。 Pausing and backgrounding processes暂停进程： SIGSTOP 会让进程暂停。在终端中，键入 Ctrl-Z 会让 shell 发送 SIGTSTP 信号。（SIGTSTP is the terminal’s version of SIGSTOP） 恢复暂停的作业： 使用 fg（font） 或 bg（back）命令恢复暂停的工作。它们分别表示在前台继续或在后台继续。 jobs 命令会列出当前终端会话中尚未完成的全部任务。可以使用 pid 引用这些任务（也可以用 pgrep 找出 pid）。 更加符合直觉的操作是使用百分号 + 任务编号（例如%1、%2，可以使用jobs 会打印任务编号）来选取该任务。如果要选择最近的一个任务，可以使用 $! 这一特殊参数。 作业后台运行： 给命令加上 &amp; 后缀可以让命令在直接在后台运行，这使得我们可以直接在 shell 中继续做其他操作，不过它此时还是会使用 shell 的标准输出（这种情况可以使用 shell 重定向处理）。 让已经在运行的进程转到后台运行： 可以键入Ctrl-Z （ SIGTSTP信号） jobs查看所有作业 bg转到后台运行 需要注意的是，后台的进程仍然是终端进程的子进程，一旦关闭终端（会发送另外一个信号SIGHUP），这些后台的进程也会终止。为了防止这种情况发生，您可以使用 nohup (一个用来忽略 SIGHUP 的封装) 来运行程序。针对已经运行的程序，可以使用disown 。 1234567891011121314151617181920212223242526272829303132333435363738394041$ sleep 1000^Z[1] + 18653 suspended sleep 1000$ nohup sleep 2000 &amp;[2] 18745appending output to nohup.out$ jobs[1] + suspended sleep 1000[2] - running nohup sleep 2000$ bg %1[1] - 18653 continued sleep 1000$ jobs[1] - running sleep 1000[2] + running nohup sleep 2000$ kill -STOP %1[1] + 18653 suspended (signal) sleep 1000$ jobs[1] + suspended (signal) sleep 1000[2] - running nohup sleep 2000$ kill -SIGHUP %1[1] + 18653 hangup sleep 1000$ jobs[2] + running nohup sleep 2000$ kill -SIGHUP %2$ jobs[2] + running nohup sleep 2000$ kill %2[2] + 18745 terminated nohup sleep 2000$ jobs Terminal Multiplexers在使用命令行时，通常会希望同时执行多个任务。出于解决终端过多问题，可以使用终端多路复用器。 现在最流行的终端多路器是 tmux。tmux 是一个高度可定制的工具，您可以使用相关快捷键创建多个标签页并在它们间导航。 tmux 的快捷键都是类似 &lt;C-b&gt; x 这样的组合，即需要先按下Ctrl+b，松开后再按下 x。 会话 - 每个会话都是一个独立的工作区，其中包含一个或多个窗口 tmux 开始一个新的会话 tmux new -s NAME 以指定名称开始一个新的会话 tmux ls 列出当前所有会话 在 tmux 中输入 &lt;C-b&gt; d ，将当前会话分离 tmux a 重新连接最后一个会话。您也可以通过 -t 来指定具体的会话 窗口 - 相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分 &lt;C-b&gt; c 创建一个新的窗口，使用 &lt;C-d&gt;关闭 &lt;C-b&gt; N 跳转到第 N 个窗口，注意每个窗口都是有编号的 &lt;C-b&gt; p 切换到前一个窗口 &lt;C-b&gt; n 切换到下一个窗口 &lt;C-b&gt; , 重命名当前窗口 &lt;C-b&gt; w 列出当前所有窗口 面板 - 像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个 shell &lt;C-b&gt; &quot; 水平分割 &lt;C-b&gt; % 垂直分割 &lt;C-b&gt; &lt;方向&gt; 切换到指定方向的面板，&lt;方向&gt; 指的是键盘上的方向键 &lt;C-b&gt; z 切换当前面板的缩放 &lt;C-b&gt; [ 开始往回卷动屏幕。您可以按下空格键来开始选择，回车键复制选中的部分 &lt;C-b&gt; &lt;空格&gt; 在不同的面板排布间切换 Aliases大多数 shell 都支持设置别名。shell 的别名相当于一个长命令的缩写，shell 会自动将其替换成原本的命令。 12345678910111213141516171819202122232425262728# 创建常用命令的缩写alias ll=&quot;ls -lh&quot;# 能够少输入很多alias gs=&quot;git status&quot;alias gc=&quot;git commit&quot;alias v=&quot;vim&quot;# 手误打错命令也没关系alias sl=ls# 重新定义一些命令行的默认行为alias mv=&quot;mv -i&quot; # -i prompts before overwritealias mkdir=&quot;mkdir -p&quot; # -p make parent dirs as neededalias df=&quot;df -h&quot; # -h prints human readable format# 别名可以组合使用alias la=&quot;ls -A&quot;alias lla=&quot;la -l&quot;# 在忽略某个别名\\ls# 或者禁用别名unalias la# 获取别名的定义alias ll# 会打印 ll='ls -lh' 在默认情况下 shell 并不会保存别名。为了让别名持续生效，需要将配置放进 shell 的启动文件里，像是.bashrc 或 .zshrc。 Dotfiles很多程序的配置都是通过纯文本格式的被称作dotfiles的配置文件来完成的（之所以称为点文件，是因为它们的文件名以 . 开头，例如 ~/.vimrc。也正因为此，它们默认是隐藏文件，ls并不会显示它们）。 shell 的配置也是通过这类文件完成的。在启动时， shell 程序会读取很多文件以加载其配置项。 一些其他的工具也可以通过dotfiles进行配置： bash - ~/.bashrc, ~/.bash_profile git - ~/.gitconfig vim - ~/.vimrc 和 ~/.vim 目录 ssh - ~/.ssh/config tmux - ~/.tmux.conf Remote Machines登陆远端机器：foo-user, bar.mit.edu-远端机器地址/域名 1ssh foo@bar.mit.edu Executing commands ssh foobar@server ls | grep PATTERN 会在本地查询远端 ls 的输出。 ls | ssh foobar@server grep PATTERN 会在远端对本地 ls 输出的结果进行查询。 Copying files over SSH使用 ssh 复制文件有很多方法： ssh+tee, 最简单的方法是执行 ssh 命令，然后通过这样的方法利用标准输入实现 cat localfile | ssh remote_server tee serverfile。回忆一下，tee 命令会将标准输出写入到一个文件； scp ：当需要拷贝大量的文件或目录时，使用scp 命令则更加方便，因为它可以方便的遍历相关路径。语法如下：scp path/to/local_file remote_host:path/to/remote_file； rsync 对 scp 进行了改进，它可以检测本地和远端的文件以防止重复拷贝。它还可以提供一些诸如符号连接、权限管理等精心打磨的功能。甚至还可以基于 --partial标记实现断点续传。rsync 的语法和scp类似；","link":"/2023/03/07/missing-Command-line-Environment/"},{"title":"missing semester - Version Control (Git)","text":"Git’s data modelSnapshots 快照Git 将顶级目录中的文件和文件夹作为集合，并通过一系列快照来管理其历史记录。 在Git的术语里，文件被称作Blob对象（数据对象），也就是一组数据。目录则被称之为“tree（树）”，它将名字与 Blob 对象或树对象进行映射（使得目录中可以包含其他目录）。 快照则是被追踪的最顶层的树。例如，一个树看起来可能是这样的： 1234567&lt;root&gt; (tree)|+- foo (tree)| || + bar.txt (blob, contents = &quot;hello world&quot;)|+- baz.txt (blob, contents = &quot;git is wonderful&quot;) Modeling history: relating snapshots在 Git 中，历史记录是一个由快照组成的有向无环图（DAG）。 1234o &lt;-- o &lt;-- o &lt;-- o &lt;---- o ^ / \\ v --- o &lt;-- o 其中 o 表示一次提交（快照），箭头指向了当前提交的父辈。 Git 中的提交是不可改变的。但这并不代表错误不能被修改，只不过这种“修改”实际上是创建了一个全新的提交记录。而引用则被更新为指向这些新的提交。 Data model, as pseudocode以伪代码形式表示上述数据模型，如下： 12345678910111213// 文件就是一组数据type blob = array&lt;byte&gt;// 一个包含文件和目录的目录type tree = map&lt;string, tree | blob&gt;// 每个提交都包含一个父辈，元数据和顶层树type commit = struct { parent: array&lt;commit&gt; author: string message: string snapshot: tree} Objects and content-addressingGit 中的对象可以是 blob、tree或commit： 1type object = blob | tree | commit Git 在储存数据时，所有的对象都会基于它们的 SHA-1哈希 进行寻址。 12345678objects = map&lt;string, object&gt;def store(object): id = sha1(object) objects[id] = objectdef load(id): return objects[id] Blobs、tree和commit都一样，它们都是对象。当它们引用其他对象时，它们并没有真正的在硬盘上保存这些对象，而是仅仅保存了它们的哈希值作为引用。（可以通过 git cat-file -p hash_num 来进行可视化） References所有的快照都可以通过它们的 SHA-1 哈希值来标记。但去记住一串 40 位的十六进制字符的十分困难的。 针对这一问题，Git 的解决方法是给这些哈希值赋予人类可读的名字，也就是引用（references）。引用是指向提交的指针。与对象不同的是，它是可变的（引用可以被更新，指向新的提交）。例如，master 引用通常会指向主分支的最新一次提交。 12345678910111213references = map&lt;string, string&gt;def update_reference(name, id): references[name] = iddef read_reference(name): return references[name]def load_reference(name_or_id): if name_or_id in references: return load(references[name_or_id]) else: return load(name_or_id) 在 Git 中，当前的位置有一个特殊的索引- HEAD。 RepositoriesGit 仓库的定义：对象 和 引用。 在硬盘上，Git 仅存储对象和引用：因为其数据模型仅包含这些东西。所有的 git 命令都对应着对提交树的操作，例如增加对象，增加或删除引用。 Staging areaGit 使用一种叫做 “暂存区（staging area）”的机制，它允许您指定下次快照中要包括那些改动。 Git command-line interfaceBasics git help &lt;command&gt;: 获取 git 命令的帮助信息 git init: 创建一个新的 git 仓库，其数据会存放在一个名为 .git 的目录下 git status: 显示当前的仓库状态 git add &lt;filename&gt;: 添加文件到暂存区 git commit : 创建一个新的提交 如何编写 良好的提交信息! 为何要 编写良好的提交信息 git log: 显示历史日志 git log --all --graph --decorate: 可视化历史记录（有向无环图） git diff &lt;filename&gt;: 显示与暂存区文件的差异 git diff &lt;revision&gt; &lt;filename&gt;: 显示某个文件两个版本之间的差异 git checkout &lt;revision&gt;: 更新 HEAD 和目前的分支 Branching and merging git branch: 显示分支 git branch &lt;name&gt;: 创建分支 git checkout -b &lt;name&gt;: 创建分支并切换到该分支 相当于 git branch &lt;name&gt;; git checkout &lt;name&gt; git merge &lt;revision&gt;: 合并到当前分支 git mergetool: 使用工具来处理合并冲突、 git rebase: 将一系列补丁变基（rebase）为新的基线 Remotes git remote: 列出远端 git remote add &lt;name&gt; &lt;url&gt;: 添加一个远端 git push &lt;remote&gt; &lt;local branch&gt;:&lt;remote branch&gt;: 将对象传送至远端并更新远端引用 git branch --set-upstream-to=&lt;remote&gt;/&lt;remote branch&gt;: 创建本地和远端分支的关联关系 git fetch: 从远端获取对象/索引 git pull: 相当于 git fetch; git merge git clone: 从远端下载仓库 Undo git commit --amend: 编辑提交的内容或信息 git reset HEAD &lt;file&gt;: 恢复暂存的文件 git checkout -- &lt;file&gt;: 丢弃修改 Advanced Git git config: Git 是一个高度可定制的 工具 git clone --depth=1: 浅克隆（shallow clone），不包括完整的版本历史信息 git add -p: 交互式暂存 git rebase -i: 交互式变基 git blame: 查看最后修改某行的人 git stash: 暂时移除工作目录下的修改内容 git bisect: 通过二分查找搜索历史记录 .gitignore: 指定不追踪的文件","link":"/2023/03/07/missing-git/"},{"title":"missing semester - Debugging and Profiling","text":"Debugging-调试打印调试法与日志 “The most effective debugging tool is still careful thought, coupled with judiciously placed print statements” — Brian Kernighan, Unix for Beginners. 调试代码的第一种方法往往是在发现问题的地方添加一些打印语句，然后不断重复此过程直到获取了足够的信息并找到问题的根本原因。 另外一个方法是使用日志，而不是临时添加打印语句。日志较普通的打印语句有如下的一些优势： 您可以将日志写入文件、socket 或者甚至是发送到远端服务器而不仅仅是标准输出； 日志可以支持严重等级（例如 INFO, DEBUG, WARN, ERROR等)，这使您可以根据需要过滤日志； 对于新发现的问题，很可能您的日志中已经包含了可以帮助您定位问题的足够的信息。 调试器当通过打印已经不能满足您的调试需求时，您应该使用调试器。 调试器是一种可以允许我们和正在执行的程序进行交互的程序，它可以做到： 当到达某一行时将程序暂停； 一次一条指令地逐步执行程序； 程序崩溃后查看变量的值； 满足特定条件时暂停程序； 其他高级功能。 很多编程语言都有自己的调试器。Python 的调试器是pdb。下面对pdb 支持的命令进行简单的介绍： l(ist) - 显示当前行附近的11行或继续执行之前的显示； s(tep) - 执行当前行，并在第一个可能的地方停止； n(ext) - 继续执行直到当前函数的下一条语句或者 return 语句； b(reak) - 设置断点（基于传入的参数）； p(rint) - 在当前上下文对表达式求值并打印结果。还有一个命令是pp ，它使用 pprint打印； r(eturn) - 继续执行直到当前函数返回； q(uit) - 退出调试器。 对于更底层的编程语言，您可能需要了解一下 gdb ( 以及它的改进版 pwndbg) 和 lldb。 特殊工具系统调用即使需要调试的程序是一个二进制的黑盒程序，仍然有一些工具可以帮助到我们。 当程序需要执行一些只有操作系统内核才能完成的操作时，它需要使用 系统调用。有一些命令可以追踪您的程序执行的系统调用。在 Linux 中可以使用strace ，在 macOS 和 BSD 中可以使用 dtrace。dtrace 用起来可能有些别扭，因为它使用的是它自有的 D 语言，但是我们可以使用一个叫做 dtruss 的封装使其具有和 strace (更多信息参考 这里)类似的接口 12345# On Linuxsudo strace -e lstat ls -l &gt; /dev/null4# On macOSsudo dtruss -t lstat64_extended ls -l &gt; /dev/null 网络抓包有些情况下，我们需要查看网络数据包才能定位问题。像 tcpdump 和 Wireshark 这样的网络数据包分析工具可以帮助您获取网络数据包的内容并基于不同的条件进行过滤。 前端开发对于 web 开发， Chrome/Firefox 的开发者工具非常方便，功能也很强大： 源码 -查看任意站点的 HTML/CSS/JS 源码； 实时地修改 HTML, CSS, JS 代码 - 修改网站的内容、样式和行为用于测试（从这一点您也能看出来，网页截图是不可靠的）； Javascript shell - 在 JS REPL中执行命令； 网络 - 分析请求的时间线； 存储 - 查看 Cookies 和本地应用存储。 静态分析有些问题是不需要执行代码就能发现的。静态分析会将程序的源码作为输入然后基于编码规则对其进行分析并对代码的正确性进行推理。 大多数的编辑器和 IDE 都支持在编辑界面显示这些工具的分析结果、高亮有警告和错误的位置。 这个过程通常称为 code linting 。风格检查或安全检查的结果同样也可以进行相应的显示。 在 vim 中，有 ale 或 syntastic 可以做同样的事情。 在 Python 中， pylint 和 pep8 是两种用于进行风格检查的工具，而 bandit 工具则用于检查安全相关的问题。 对于风格检查和代码格式化，还有以下一些工具可以作为补充：用于 Python 的 black、用于 Go 语言的 gofmt、用于 Rust 的 rustfmt 或是用于 JavaScript, HTML 和 CSS 的 prettier 。这些工具可以自动格式化代码，这样代码风格就可以与常见的风格保持一致。 Profiling-性能分析代码能跑起来不一定是成功的，可能在时间和内存上存在一定问题。 计时大多数情况下只需要打印两处代码之间的时间即可发现问题。 12345678910111213141516import time, randomn = random.randint(1, 10) * 100# 获取当前时间 start = time.time()# 执行一些操作print(&quot;Sleeping for {} ms&quot;.format(n))time.sleep(n/1000)# 比较当前时间和起始时间print(time.time() - start)# Output# Sleeping for 500 ms# 0.5713930130004883 执行时间（wall clock time）不一定是该程序实际在CPU上运行的时间，（分时系统，时间片到期后需等待调度） 对于工具来说，需要区分真实时间、用户时间和系统时间。通常来说，用户时间+系统时间代表了您的进程所消耗的实际 CPU （更详细的解释可以参照这篇文章）。 真实时间 - 从程序开始到结束流失掉的真实时间，包括其他进程的执行时间以及阻塞消耗的时间（例如等待 I/O或网络）； User - CPU 执行用户代码所花费的时间； Sys - CPU 执行系统内核代码所花费的时间。 1234$ time curl https://missing.csail.mit.edu &amp;&gt; /dev/null`real 0m2.561suser 0m0.015ssys 0m0.012s 性能分析工具（profilers）CPU大多数情况下，当人们提及性能分析工具的时候，通常指的是 CPU 性能分析工具。 CPU 性能分析工具有两种： 追踪分析器（tracing）及采样分析器（sampling）。 追踪分析器会记录程序的每一次函数调用，而采样分析器则只会周期性的监测（通常为每毫秒）您的程序并记录程序堆栈。 在 Python 中，使用 cProfile 模块来分析每次函数调用所消耗的时间。 12345678910111213141516$ python -m cProfile -s tottime grep.py 1000 '^(import|\\s*def)[^,]*$' *.py[omitted program output] ncalls tottime percall cumtime percall filename:lineno(function) 8000 0.266 0.000 0.292 0.000 {built-in method io.open} 8000 0.153 0.000 0.894 0.000 grep.py:5(grep) 17000 0.101 0.000 0.101 0.000 {built-in method builtins.print} 8000 0.100 0.000 0.129 0.000 {method 'readlines' of '_io._IOBase' objects} 93000 0.097 0.000 0.111 0.000 re.py:286(_compile) 93000 0.069 0.000 0.069 0.000 {method 'search' of '_sre.SRE_Pattern' objects} 93000 0.030 0.000 0.141 0.000 re.py:231(compile) 17000 0.019 0.000 0.029 0.000 codecs.py:318(decode) 1 0.017 0.017 0.911 0.911 grep.py:3(&lt;module&gt;)[omitted lines] 关于 Python 的 cProfile 分析器（以及其他一些类似的分析器），需要注意的是它显示的是每次函数调用的时间。 更加符合直觉的显示分析信息的方式是包括每行代码的执行时间，这也是行分析器的工作。使用 line_profiler，它会基于行来显示时间： 1234567891011121314151617$ kernprof -l -v a.pyWrote profile results to urls.py.lprofTimer unit: 1e-06 sTotal time: 0.636188 sFile: a.pyFunction: get_urls at line 5Line # Hits Time Per Hit % Time Line Contents============================================================== 5 @profile 6 def get_urls(): 7 1 613909.0 613909.0 96.5 response = requests.get('https://missing.csail.mit.edu') 8 1 21559.0 21559.0 3.4 s = BeautifulSoup(response.content, 'lxml') 9 1 2.0 2.0 0.0 urls = []10 25 685.0 27.4 0.1 for url in s.find_all('a'):11 24 33.0 1.4 0.0 urls.append(url['href']) 内存像 C 或者 C++ 这样的语言，内存泄漏会导致您的程序在使用完内存后不去释放它。为了应对内存类的 Bug，我们可以使用类似 Valgrind 这样的工具来检查内存泄漏问题。 时间分析在使用strace调试代码时，可能会希望忽略一些特殊的代码并希望在分析时将其当作黑盒处理。perf 命令将 CPU 的区别进行了抽象，它不会报告时间和内存的消耗，而是报告与您的程序相关的系统事件。 例如，perf 可以报告不佳的缓存局部性（poor cache locality）、大量的页错误（page faults）或活锁（livelocks）。下面是关于常见命令的简介： perf list - 列出可以被 pref 追踪的事件； perf stat COMMAND ARG1 ARG2 - 收集与某个进程或指令相关的事件； perf record COMMAND ARG1 ARG2 - 记录命令执行的采样信息并将统计数据储存在perf.data中； perf report - 格式化并打印 perf.data 中的数据。 可视化使用分析器来分析真实的程序时，由于软件的复杂性，其输出结果中将包含大量的信息。人类是一种视觉动物，非常不善于阅读大量的文字。因此很多工具都提供了可视化分析器输出结果的功能。 火焰图是一种显示 CPU 分析数据的形式，火焰图会在 Y 轴显示函数调用关系，并在 X 轴显示其耗时的比例。火焰图同时还是可交互的，可以深入程序的某一具体部分，并查看其栈追踪。 调用图和控制流图可以显示子程序之间的关系，它将函数作为节点并把函数调用作为边。将它们和分析器的信息（例如调用次数、耗时等）放在一起使用时，调用图会变得非常有用，它可以帮助我们分析程序的流程。 在 Python 中可以使用 pycallgraph 来生成这些图片。 资源监控有时候，分析程序性能的第一步是搞清楚它所消耗的资源。程序变慢通常是因为它所需要的资源不够了。例如，没有足够的内存或者网络连接变慢的时候。 有很多很多的工具可以被用来显示不同的系统资源，例如 CPU 占用、内存使用、网络、磁盘使用等。 通用监控 - 最流行的工具要数 htop了，它是 top的改进版。htop 可以显示当前运行进程的多种统计信息。如果需要合并测量全部的进程， dstat 是也是一个非常好用的工具，它可以实时地计算不同子系统资源的度量数据，例如 I/O、网络、 CPU 利用率、上下文切换等等； I/O 操作 - iotop 可以显示实时 I/O 占用信息而且可以非常方便地检查某个进程是否正在执行大量的磁盘读写操作； 磁盘使用 - df 可以显示每个分区的信息，而 du 则可以显示当前目录下每个文件的磁盘使用情况（ disk usage）。-h 选项可以使命令以对人类（human）更加友好的格式显示数据；ncdu是一个交互性更好的 du ，它可以让您在不同目录下导航、删除文件和文件夹； 内存使用 - free 可以显示系统当前空闲的内存。内存也可以使用 htop这样的工具来显示； 打开文件 - lsof 可以列出被进程打开的文件信息。 当我们需要查看某个文件是被哪个进程打开的时候，这个命令非常有用； 网络连接和配置 - ss 能帮助我们监控网络包的收发情况以及网络接口的显示信息。ss 常见的一个使用场景是找到端口被进程占用的信息。如果要显示路由、网络设备和接口信息，您可以使用 ip 命令。注意，netstat 和 ifconfig 这两个命令已经被前面那些工具所代替了。 网络使用 - nethogs 和 iftop 是非常好的用于对网络占用进行监控的交互式命令行工具。 如果希望测试一下这些工具，可以使用 stress 命令来为系统人为地增加负载。 特殊工具有时候，只需要对黑盒程序进行基准测试，并依此对软件选择进行评估。 hyperfine 这样的命令行可以进行基准测试。例如，下面的例子中，我们可以看到fd 比 find 要快20倍。 123456789101112$ hyperfine --warmup 3 'fd -e jpg' 'find . -iname &quot;*.jpg&quot;'Benchmark #1: fd -e jpg Time (mean ± σ): 51.4 ms ± 2.9 ms [User: 121.0 ms, System: 160.5 ms] Range (min … max): 44.2 ms … 60.1 ms 56 runsBenchmark #2: find . -iname &quot;*.jpg&quot; Time (mean ± σ): 1.126 s ± 0.101 s [User: 141.1 ms, System: 956.1 ms] Range (min … max): 0.975 s … 1.287 s 10 runsSummary 'fd -e jpg' ran 21.89 ± 2.33 times faster than 'find . -iname &quot;*.jpg&quot;'","link":"/2023/03/07/missing-debugging/"},{"title":"missing semester - Metaprogramming","text":"何谓“元”（meta）： 大哉乾元，万物资始，乃统天。 –《彖》 道生一，一生二，二生三，三生万物。 – 《道德经》 此处的元编程（metaprogramming)并不是C++的元编程魔法，而是关于流程的（即构建系统、代码测试以及依赖管理）。必须要指出的是，“元编程” 也有用于操作程序的程序” 之含义。 Build systems - 构建系统构建过程：您需要执行一系列操作。通常，这一过程包含了很多步骤，很多分支。执行一些命令来生成图表，然后执行另外的一些命令生成结果，然后再执行其他的命令来生成最终的论文。 构建系统：帮助完成构建过程操作的工具。需要定义依赖、目标 和 规则。我们必须告诉构建系统我们具体的构建目标，系统的任务则是找到构建这些目标所需要的依赖，并根据规则构建所需的中间产物，直到最终目标被构建出来。理想的情况下，如果目标的依赖没有发生改动，并且我们可以从之前的构建中复用这些依赖，那么与其相关的构建规则并不会被执行。 make 是最常用的构建系统之一，您会发现它通常被安装到了几乎所有基于UNIX的系统中。make并不完美，但是对于中小型项目来说，它已经足够好了。当您执行 make 时，它会去参考当前目录下名为 Makefile 的文件。所有构建目标、相关依赖和规则都需要在该文件中定义，它看上去是这样的： 12345paper.pdf: paper.tex plot-data.png pdflatex paper.texplot-%.png: %.dat plot.py ./plot.py -i $*.dat -o $@ 冒号左侧的是构建目标，冒号右侧的是构建它所需的依赖。缩进的部分是从依赖构建目标时需要用到的一段程序。 在 make 中，第一条指令还指明了构建的目的，如果您使用不带参数的 make，这便是我们最终的构建结果。或者，您可以使用这样的命令来构建其他目标：make plot-data.png。 规则中的 % 是一种模式，它会匹配其左右两侧相同的字符串。例如，如果目标是 plot-foo.png， make 会去寻找 foo.dat 和 plot.py 作为依赖。 Dependency management依赖管理就一个项目来说，它的依赖可能本身也是其他的项目。项目也许会依赖某些程序(例如 python)、系统包 (例如 openssl)或相关编程语言的库(例如 matplotlib)。 现在，大多数的依赖可以通过某些软件仓库来获取，这些仓库会在一个地方托管大量的依赖，我们则可以通过一套非常简单的机制来安装依赖。 例子： Ubuntu 系统下面有Ubuntu软件包仓库，可以通过apt 这个工具来访问 RubyGems 则包含了 Ruby 的相关库 PyPi 包含了 Python 库 版本控制版本控制：大多数被其他项目所依赖的项目都会在每次发布新版本时创建一个版本号。通常看上去像 8.1.3 或 64.1.20192004。版本号有很多用途，其中最重要的作用是保证软件能够运行。 语义版本号，这种版本号具有不同的语义，它的格式是这样的：主版本号.次版本号.补丁号。相关规则有： 如果新的版本没有改变 API，请将补丁号递增； 如果添加了 API 并且该改动是向后兼容的，请将次版本号递增； 如果修改了 API 但是它并不向后兼容，请将主版本号递增。 软件开发行业的「前后」是按照英语习惯来的，不是按照汉语习惯来的。按照英语习惯，「向前进」(forward)指未来，「向后退」(backward)指过去。注意要把「前」「后」分别理解成「前进」和「后退」，不可以理解成「从前」和「以后」。 lock files锁文件列出了您当前每个依赖所对应的具体版本号。通常，您需要执行升级程序才能更新依赖的版本。这么做的原因有很多，例如避免不必要的重新编译、创建可复现的软件版本或禁止自动升级到最新版本（可能会包含 bug）。 一般可见于python项目中的requirements.txt vendoringvendoring会把依赖中的所有代码直接拷贝到项目中，这样就能够完全掌控代码的任何修改，同时也可以将自己的修改添加进去，不过这也意味着如何该依赖的维护者更新了某些代码，也必须要自己去拉取这些更新。 常见于Go项目中的vendor Continuous integration systems - 持续集成系统持续集成，或者叫做 CI 是一种雨伞术语（umbrella term，涵盖了一组术语的术语），它指的是那些“当您的代码变动时，自动运行的东西”，市场上有很多提供各式各样 CI 工具的公司，这些工具大部分都是免费或开源的。比较大的有 Travis CI、Azure Pipelines 和 GitHub Actions。 工作原理：您需要在代码仓库中添加一个文件，描述当前仓库发生任何修改时，应该如何应对。目前为止，最常见的规则是：如果有人提交代码，执行测试套件。当这个事件被触发时，CI 提供方会启动一个（或多个）虚拟机，执行您制定的规则，并且通常会记录下相关的执行结果。您可以进行某些设置，这样当测试套件失败时您能够收到通知或者当测试全部通过时，您的仓库主页会显示一个徽标。 Test 测试套件：所有测试的统称。 单元测试：一种“微型测试”，用于对某个封装的特性进行测试。 集成测试：一种“宏观测试”，针对系统的某一大部分进行，测试其不同的特性或组件是否能协同工作。 回归测试：一种实现特定模式的测试，用于保证之前引起问题的 bug 不会再次出现。 模拟（Mocking）: 使用一个假的实现来替换函数、模块或类型，屏蔽那些和测试不相关的内容。例如，“模拟网络连接” 或 “模拟硬盘”。","link":"/2023/03/07/missing-Metaprogramming/"},{"title":"missing semester - Security and Cryptography","text":"熵熵(Entropy) 度量了不确定性并可以用来决定密码的强度。 熵的单位是 bits(比特)。对于一个均匀分布的随机离散变量，熵等于 log_2(# of possibilities)。扔一次硬币的熵是1 bits，即log_2(2)。掷一次（六面）骰子的熵大约为2.58 bits，即log_2(6)。 使用多少比特的熵取决于应用的威胁模型。 XKCD漫画告诉我们，大约40比特的熵足以对抗在线穷举攻击（受限于网络速度和应用认证机制）。 而对于离线穷举攻击（主要受限于计算速度）, 一般需要更强的密码 (比如80比特或更多)。 散列函数密码散列函数 (Cryptographic hash function) 可以将任意大小的数据映射为一个固定大小的输出。 1hash(value: array&lt;byte&gt;) -&gt; vector&lt;byte, N&gt; (N对于该函数固定) SHA-1是Git中使用的一种散列函数， 它可以将任意大小的输入映射为一个160比特（可被40位十六进制数表示）的输出。 123456$ printf 'hello' | sha1sumaaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d$ printf 'hello' | sha1sumaaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d$ printf 'Hello' | sha1sum f7ff9e8b7bb2e09b70935a5d785e0cc5d9d0abf0 抽象地讲，散列函数可以被认为是一个不可逆，且看上去随机（但具确定性）的函数。 一个散列函数拥有以下特性： 确定性：对于不变的输入永远有相同的输出。 不可逆性：对于hash(m) = h，难以通过已知的输出h来计算出原始输入m。 目标碰撞抵抗性/弱无碰撞：对于一个给定输入m_1，难以找到m_2 != m_1且hash(m_1) = hash(m_2)。 碰撞抵抗性/强无碰撞：难以找到一组满足hash(m_1) = hash(m_2)的输入m_1, m_2（该性质严格强于目标碰撞抵抗性，即Hash函数基本没有碰撞）。 密码散列函数的应用 Git中的内容寻址存储(Content addressed storage)：散列函数是一个宽泛的概念（存在非密码学的散列函数），那么Git为什么要特意使用密码散列函数？ 普通的散列函数没有无碰撞性，Git 使用密码散列函数，来确保分布式版本控制系统中的两个不同数据不会有相同的摘要信息（例如两个内容不同的 commit 不应该有相同的哈希值）。 文件的信息摘要(Message digest)：例如下载文件时，对比下载下来的文件的哈希值和官方公布的哈希值是否相同来判断文件是否损坏或者被篡改。 承诺机制(Commitment scheme)： 假设我希望承诺一个值，但之后再透露它—— 比如在没有一个可信的、双方可见的硬币的情况下在我的脑海中公平的“扔一次硬币”。 假定偶数r代表正面，奇数r代表反面。 我可以选择一个值r = random()，并和你分享它的哈希值h = sha256(r)。 这时你可以开始猜硬币的正反。 我告诉你值r的内容，得出胜负。同时你可以使用sha256(r)来检查我分享的哈希值h以确认我没有作弊。 密钥生成函数密钥生成函数 (Key Derivation Functions) 与密码散列函数类似，用以产生一个固定长度的密钥。但是为了对抗穷举法攻击，密钥生成函数通常较慢。 密钥生成函数的应用 将其结果作为其他加密算法的密钥，例如对称加密算法 数据库中保存的用户密码为密文 针对每个用户随机生成一个盐，并存储盐，以及密钥生成函数对连接了盐的明文密码生成的哈希值 KDF(password + salt)。 在验证登录请求时，使用输入的密码连接存储的盐重新计算哈希值KDF(input + salt)，并与存储的哈希值对比。 盐（Salt），在密码学中，是指在散列之前将散列内容（例如：密码）的任意固定位置插入特定的字符串。这个在散列中加入字符串的方式称为“加盐”。 在大部分情况，盐是不需要保密的。 通常情况下，当字段经过散列处理，会生成一段散列值，而散列后的值一般是无法通过特定算法得到原始字段的。但是某些情况，比如一个大型的彩虹表，通过在表中搜索该SHA-1值，很有可能在极短的时间内找到该散列值对应的真实字段内容。 加盐可以避免用户的短密码被彩虹表破解，也可以保护在不同网站使用相同密码的用户。 对称加密对称加密使用以下几个方法来实现这个功能： 1234keygen() -&gt; key (这是一个随机方法)encrypt(plaintext: array&lt;byte&gt;, key) -&gt; array&lt;byte&gt; (输出密文)decrypt(ciphertext: array&lt;byte&gt;, key) -&gt; array&lt;byte&gt; (输出明文) 加密方法encrypt()输出的密文ciphertext很难在不知道key的情况下得出明文plaintext。解密方法decrypt()有明显的正确性。对于给定密文及其密钥，解密方法必须输出明文：decrypt(encrypt(m, k), k) = m。 AES 是现在常用的一种对称加密系统。在 Linux 下可以使用 openssl 工具： 1234# 加密openssl aes-256-cbc -salt -in {源文件名} -out {加密文件名}# 解密openssl aes-256-cbc -d -in {加密文件名} -out {解密文件名} 对称加密的应用 加密不信任的云服务上存储的文件。对称加密和密钥生成函数配合起来，就可以使用密码加密文件： 将密码输入密钥生成函数生成密钥 key = KDF(passphrase)，然后存储encrypt(file, key)。 非对称加密非对称加密的“非对称”代表在其环境中，使用两个具有不同功能的密钥： 一个是**私钥(private key)，不向外公布；另一个是公钥(public key)**，公布公钥不像公布对称加密的共享密钥那样可能影响加密体系的安全性。 1234567keygen() -&gt; (public key, private key) (这是一个随机方法)encrypt(plaintext: array&lt;byte&gt;, public key) -&gt; array&lt;byte&gt; (输出密文)decrypt(ciphertext: array&lt;byte&gt;, private key) -&gt; array&lt;byte&gt; (输出明文)sign(message: array&lt;byte&gt;, private key) -&gt; array&lt;byte&gt; (生成签名)verify(message: array&lt;byte&gt;, signature: array&lt;byte&gt;, public key) -&gt; bool (验证签名是否是由和这个公钥相关的私钥生成的) 非对称的加密/解密方法和对称的加密/解密方法有类似的特征（公钥加密，私钥解密）：信息在非对称加密中使用 公钥 加密， 且输出的密文很难在不知道 私钥 的情况下得出明文。解密方法decrypt()有明显的正确性。 给定密文及私钥，解密方法一定会输出明文： decrypt(encrypt(m, public key), private key) = m。 签名/验证(sign/verify)： 在不知道 私钥 的情况下，不管需要签名的信息为何，很难计算出一个可以使 verify(message, signature, public key) 返回为真的签名。 非对称加密的应用 PGP电子邮件加密](https://en.wikipedia.org/wiki/Pretty_Good_Privacy)：用户可以将所使用的公钥在线发布，比如：PGP密钥服务器或 Keybase。任何人都可以向他们发送加密的电子邮件。 聊天加密：像 Signal 和 Keybase 使用非对称密钥来建立私密聊天。 软件签名：Git 支持用户对提交(commit)和标签(tag)进行GPG签名。任何人都可以使用软件开发者公布的签名公钥验证下载的已签名软件。 密钥分发非对称加密面对的主要挑战是，如何分发公钥并对应现实世界中存在的人或组织。 Signal的信任模型：信任用户第一次使用时给出的身份(trust on first use)，支持线下(out-of-band)面对面交换公钥（Signal里的safety number）。 PGP使用的是信任网络。 Keybase主要使用社交网络证明 (social proof)。","link":"/2023/03/07/missing-Security/"},{"title":"missing semester - Potpourri","text":"修改键位映射修改键位映射通常由在计算机上运行的软件实现。当某一个按键被按下，软件截获键盘发出的按键事件（keypress event）并使用另外一个事件取代。比如： 将 Caps Lock 映射为 Ctrl 或者 Escape：Caps Lock 使用了键盘上一个非常方便的位置而它的功能却很少被用到； 下面是一些修改键位映射的软件： macOS - karabiner-elements, skhd 或者 BetterTouchTool Linux - xmodmap 或者 Autokey Windows - 控制面板，AutoHotkey 或者 SharpKeys QMK - 如果你的键盘支持定制固件，QMK 可以直接在键盘的硬件上修改键位映射。保留在键盘里的映射免除了在别的机器上的重复配置。 守护进程守护进程是一种在后台保持运行，不需要用户手动运行或者交互的进程。 以守护进程运行的程序名一般以 d 结尾，比如 SSH 服务端 sshd，用来监听传入的 SSH 连接请求并对用户进行鉴权，MySQL服务端 mysqld。 Linux 中的 systemd（the system daemon）是最常用的配置和运行守护进程的方法。 运行 systemctl status 命令可以看到正在运行的所有守护进程。 用户使用 systemctl 命令和 systemd 交互来enable（启用）、disable（禁用）、start（启动）、stop（停止）、restart（重启）、或者status（检查）配置好的守护进程及系统服务。 systemd 提供了一个很方便的界面用于配置和启用新的守护进程或系统服务。下面的配置文件使用了守护进程来运行一个简单的 Python 程序。systemd 配置文件的详细指南可参见 freedesktop.org。 12345678910111213141516171819202122232425# /etc/systemd/system/myapp.service[Unit]# 配置文件描述Description=My Custom App# 在网络服务启动后启动该进程After=network.target[Service]# 运行该进程的用户User=foo# 运行该进程的用户组Group=foo# 运行该进程的根目录WorkingDirectory=/home/foo/projects/mydaemon# 开始该进程的命令ExecStart=/usr/bin/local/python3.7 app.py# 在出现错误时重启该进程Restart=on-failure[Install]# 相当于Windows的开机启动。即使GUI没有启动，该进程也会加载并运行WantedBy=multi-user.target# 如果该进程仅需要在GUI活动时运行，这里应写作：# WantedBy=graphical.target# graphical.target在multi-user.target的基础上运行和GUI相关的服务 如果想定期运行一些程序，可以直接使用 cron。它是一个系统内置的，用来执行定期任务的守护进程。(即使用 crontab 指令) FUSEFUSE（Filesystem in Userspace，用户空间文件系统）允许运行在用户空间上的程序实现文件系统调用，并将这些调用与内核接口联系起来。在实践中，这意味着用户可以在文件系统调用中实现任意功能。 FUSE 可以用于实现如：一个将所有文件系统操作都使用 SSH 转发到远程主机，由远程主机处理后返回结果到本地计算机的虚拟文件系统。这个文件系统里的文件虽然存储在远程主机，对于本地计算机上的软件而言和存储在本地别无二致。sshfs就是一个实现了这种功能的 FUSE 文件系统。 一些有趣的 FUSE 文件系统包括： sshfs：使用 SSH 连接在本地打开远程主机上的文件 rclone：将 Dropbox、Google Drive、Amazon S3、或者 Google Cloud Storage 一类的云存储服务挂载为本地文件系统 gocryptfs：覆盖在加密文件上的文件系统。文件以加密形式保存在磁盘里，但该文件系统挂载后用户可以直接从挂载点访问文件的明文 kbfs：分布式端到端加密文件系统。在这个文件系统里有私密（private），共享（shared），以及公开（public）三种类型的文件夹 borgbackup：方便用户浏览删除重复数据后的压缩加密备份 备份复制数据很简单，但是可靠地备份数据很难。下面列举了一些关于备份的基础知识，以及一些常见做法容易掉进的陷阱。 复制存储在同一个磁盘上的数据不是备份，因为这个磁盘是一个单点故障（single point of failure）。 同步方案不是备份 Dropbox 或者 Google Drive，当数据在本地被抹除或者损坏，同步方案可能会把这些“更改”同步到云端。 RAID 磁盘镜像方案也不是备份。它不能防止文件被意外删除、损坏、或者被勒索软件加密。 不要盲目信任备份方案。用户应该经常检查备份是否可以用来恢复数据。 有效备份方案的几个核心特性是：版本控制，删除重复数据，以及安全性。 API（应用程序接口）大多数线上服务提供的 API（应用程序接口）让你可以通过编程方式来访问这些服务的数据。 这些 API 大多具有类似的格式。它们的结构化 URL 通常使用 api.service.com 作为根路径，用户可以访问不同的子路径来访问需要调用的操作，以及添加查询参数使 API 返回符合查询参数条件的结果。 通常这些返回都是JSON格式，你可以使用jq等工具来选取需要的部分。 有些需要认证的 API 通常要求用户在请求中加入某种私密令牌（secret token）来完成认证。大多数 API 都会使用 OAuth。 常见命令行标志参数及模式 --help 或 -h 或者类似的标志参数（flag）来显示简略用法 会造成不可撤回操作的工具一般会提供“空运行”（dry run）标志参数和“交互式”（interactive）标志参数 会造成破坏性结果的工具一般默认进行非递归的操作，但是支持使用“递归”（recursive）标志函数（通常是 -r） --version 或者 -V 标志参数可以让工具显示它的版本信息 --verbose 或者 -v 标志参数来输出详细的运行信息。多次使用这个标志参数，比如 -vvv，可以让工具输出更详细的信息（经常用于调试） --quiet 标志参数来抑制除错误提示之外的其他输出。 使用 - 代替输入或者输出文件名意味着工具将从标准输入（standard input）获取所需内容，或者向标准输出（standard output）输出结果。 有的时候你可能需要向工具传入一个 看上去 像标志参数的普通参数，这时候你可以使用特殊参数 -- 让某个程序 停止处理 -- 后面出现的标志参数以及选项（以 - 开头的内容）： rm -- -r 会让 rm 将 -r 当作文件名； ssh machine --for-ssh -- foo --for-foo 的 -- 会让 ssh 知道 --for-foo 不是 ssh 的标志参数。 窗口管理器大部分操作系统默认的窗口管理方式都是“拖拽”式的，这被称作堆叠式（floating/stacking）管理器。另外一种管理器是平铺式（tiling）管理器，其使用逻辑和 tmux 管理终端窗口的方式类似，可以让我们在完全不使用鼠标的情况下使用键盘切换、缩放、以及移动窗口。 Linux awesome i3 macOS yabai Divvy Windows FancyZones VPN使用了 VPN 最好的情况下也就是换了一个网络供应商（ISP）。所有你发出的流量看上去来源于 VPN 供应商的网络而不是你的“真实”地址，而你实际接入的网络只能看到加密的流量。 使用 VPN 只是把原本对网络供应商的信任放在了 VPN 供应商那里——网络供应商 能看到的，VPN 供应商 也都能看到。如果相比网络供应商你更信任 VPN 供应商，那当然很好。反之，则连接VPN的价值不明确。 Markdown在不使用 Word 或者 LaTeX 等复杂工具的情况下，你可以考虑使用 Markdown 这个轻量化的标记语言（markup language）。 Markdown 致力于将人们编写纯文本时的一些习惯标准化。比如： 用*包围的文字表示强调（斜体），或者用**表示特别强调（粗体）； 以#开头的行是标题，#的数量表示标题的级别，比如：##二级标题； 以-开头代表一个无序列表的元素。一个数字加.（比如1.）代表一个有序列表元素； 反引号 ```（backtick）包围的文字会以代码字体显示。如果要显示一段代码，可以在每一行前加四个空格缩进，或者使用三个反引号包围整个代码片段： 1就像这样 如果要添加超链接，将 需要显示 的文字用方括号包围，并在后面紧接着用圆括号包围链接：[显示文字](指向的链接)。 Hammerspoon (macOS 桌面自动化)Hammerspoon 是面向 macOS 的一个桌面自动化框架。它允许用户编写和操作系统功能挂钩的 Lua 脚本，从而与键盘、鼠标、窗口、文件系统等交互。 下面是 Hammerspoon 的一些示例应用： 绑定移动窗口到的特定位置的快捷键 创建可以自动将窗口整理成特定布局的菜单栏按钮 在你到实验室以后，通过检测所连接的 WiFi 网络自动静音扬声器 在你不小心拿了朋友的充电器时弹出警告 资源： Getting Started with Hammerspoon：Hammerspoon 官方教程 Sample configurations：Hammerspoon 官方示例配置 Anish’s Hammerspoon config：Anish 的 Hammerspoon 配置 开机引导以及 Live USB在计算机启动时，BIOS 或者 UEFI 会在加载操作系统之前对硬件系统进行初始化，这被称为引导（booting）。 在 BIOS 菜单中你可以对硬件相关的设置进行更改，也可以在引导菜单中选择从硬盘以外的其他设备加载操作系统——比如 Live USB。 Live USB 是包含了完整操作系统的闪存盘。Live USB 的用途非常广泛，包括： 作为安装操作系统的启动盘； 在不将操作系统安装到硬盘的情况下，直接运行 Live USB 上的操作系统； 对硬盘上的相同操作系统进行修复； 恢复硬盘上的数据。 Live USB 通过在闪存盘上 写入 操作系统的镜像制作，而写入不是单纯的往闪存盘上复制 .iso 文件。你可以使用 UNetbootin 、Rufus 等 Live USB 写入工具制作。 Docker, Vagrant, VMs, Cloud, OpenStack虚拟机（Virtual Machine）以及容器化（containerization）等工具可以帮助你模拟一个包括操作系统的完整计算机系统。虚拟机可以用于创建独立的测试或者开发环境，以及用作安全测试的沙盒。 Vagrant：一个构建和配置虚拟开发环境的工具。它支持用户在配置文件中写入比如操作系统、系统服务、需要安装的软件包等描述，然后使用 vagrant up 命令在各种环境（VirtualBox，KVM，Hyper-V等）中启动一个虚拟机。 Docker：一个使用容器化概念的与 Vagrant 类似的工具，在后端服务的部署中应用广泛。 VPS（虚拟专用服务器）:将一台服务器分割成多个虚拟专用服务器的服务 实现VPS的技术分为容器技术和虚拟机技术 受欢迎的 VPS 服务商有 Amazon AWS，Google Cloud、 Microsoft Azure以及DigitalOcean。 交互式记事本编程交互式记事本可以帮助开发者进行与运行结果交互等探索性的编程。 现在最受欢迎的交互式记事本环境大概是 Jupyter。它的名字来源于所支持的三种核心语言：Julia、Python、R。 Wolfram Mathematica 是另外一个常用于科学计算的优秀环境。 GitHubGitHub 是最受欢迎的开源软件开发平台之一。常用方法： 创建一个issue。 issue可以用来反映软件运行的问题或者请求新的功能。创建issue并不需要创建者阅读或者编写代码，所以它是一个轻量化的贡献方式。 使用pull request提交代码更改。pull request（拉取请求）是请求别人把你自己的代码拉取（且合并）到他们的仓库里。很多开源项目仅允许认证的管理者管理项目代码，所以一般需要fork这些项目的上游仓库（upstream repository），在你的 Github 账号下创建一个内容完全相同但是由你控制的fork仓库。这样你就可以在这个fork仓库自由创建新的分支并推送修复问题或者实现新功能的代码。完成修改以后再回到开源项目的 Github 页面创建一个pull request。 fork这些项目的上游仓库（upstream repository），在你的 Github 账号下创建一个内容完全相同但是由你控制的fork仓库。 在自己的fork仓库自由创建新的分支并推送修复问题或者实现新功能的代码。 完成修改以后再回到开源项目的 Github 页面创建一个pull request。 提交请求后，项目管理者会和你交流pull request里的代码并给出反馈。如果没有问题，你的代码会和上游仓库中的代码合并。","link":"/2023/03/07/missing-Potpourri/"},{"title":"操作系统 - 系统调用","text":"系统调用概述系统调用：运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供用户程序与操作系统之间的接口。 系统调用需要了解的点： 系统调用将处理器从用户态切换到核心态，以便 CPU 访问受到保护的内核内存。 每个系统调用都由一个唯一的数字来标识。 系统调用可以有一套参数，用于用户空间与内核空间之间相互传递信息。（x86-64中最多使用寄存器传递6个参数，参考资料如下： x86-32 [Free|Open|Net|DragonFly]BSD UNIX System Call convention: Parameters are passed on the stack. Push the parameters (last parameter pushed first) on to the stack. Then push an additional 32-bit of dummy data (Its not actually dummy data. refer to following link for more info) and then give a system call instruction int $0x80 x86-64 Linux System Call convention: User-level applications use as integer registers for passing the sequence %rdi, %rsi, %rdx, %rcx, %r8 and %r9. The kernel interface uses %rdi, %rsi, %rdx, %r10, %r8 and %r9. A system-call is done via the syscall instruction. This clobbers %rcx and %r11 as well as the %rax return value, but other registers are preserved. The number of the syscall has to be passed in register %rax. System-calls are limited to six arguments, no argument is passed directly on the stack. Returning from the syscall, register %rax contains the result of the system-call. A value in the range between -4095 and -1 indicates an error, it is -errno. Only values of class INTEGER or class MEMORY are passed to the kernel. 系统调用的详细过程以x86-32为例，说明系统调用过程： 通过调用外壳(wrapper)函数发起系统调用（glibc）。 参数通过堆栈传入外壳函数，外壳函数会将上述参数复制到寄存器（系统调用最多使用6个）。 外壳函数将系统调用编号复制到eax寄存器中。 外壳函数执行中断机器指令(int 0x80)，引发处理器从用户态切换到核心态，并执行系统中断0x80(十进制数128)的中断向量所指向的代码。 为响应中断0x80，内核会调用system_call()例程(位于汇编文件arch/i386/entry.S中)来处理中断，具体如下： 5.1 在内核栈中保存寄存器值。 5.2 审核系统调用编号是否有效。 5.3 如果调用号有效，就去存放所有调用服务例程的列表中进行索引，发现并调用相应的系统调用服务例程。 5.4 从内核栈中恢复各寄存器值，并将系统调用返回值置于栈中。 5.5 返回至外壳函数，同时将处理器切换回用户态。 若系统调用服务例程的返回值表明调用有误，外壳函数会使用该值来设置全局变量 errno。然后，外壳函数会返回到调用程序，并同时返回一个整型值，以表明系统调用是否成功。 其他Linux常见的系统调用 跟踪系统调用Linux可以在命令行中使用 strace追踪系统调用 ，ltrace追踪库函数的调用。 Mac OS可以使用dtruss追踪系统调用。 reference[1] UNIX 系统编程手册 [2] 现代操作系统","link":"/2023/03/07/os-ostep-syscall/"},{"title":"操作系统 - 操作系统内核架构","text":"操作系统设计原则操作系统的重要设计原则：策略与机制的分离 策略（Policy）：要做什么 —— 相对动态 机制（Mechanism）：怎么做 —— 相对静态 操作系统可仅通过调整策略来适应不同应用的需求 例子 策略 机制 登录 什么用户、以什么权限登录 输入处理、策略文件管理、桌面启动加载 调度 调度算法：Round-robin、 Earliest Deadline First … 调度队列、调度实体（如线程） 的表示、调度中断处理 … 操作系统架构与演进 宏内核定义宏内核（Monolithic Kernel）：将管理进程的代码、管理内存的代码、管理各种 I/O 设备的代码、文件系统的代码、图形系统代码以及其它功能模块的代码，把这些所有的代码经过编译，最后链接在一起，形成一个大的可执行程序。这个大程序里有实现支持这些功能的所有代码，向用户应用软件提供一些接口，这些接口即系统 API 函数。 整个系统分为内核与应用两层 内核：运行在特权级，集中控制所有计算资源 应用：运行在非特权级，受内核管理，使用内核服务 结构如下图所示。 以内存分配为例： 应用程序调用内存分配的 API（应用程序接口）函数。 处理器切换到特权模式，开始运行内核代码。 内核里的内存管理代码按照特定的算法，分配一块内存。 把分配的内存块的首地址，返回给内存分配的 API 函数。 内存分配的 API 函数返回，处理器开始运行用户模式下的应用程序，应用程序就得到了一块内存的首地址，并且可以使用这块内存了。 优缺点优点： 宏内核拥有丰富的沉淀和积累 拥有巨大的统一的社区和生态 针对不同场景优化了30年 缺点： 宏内核的结构性缺陷 安全性与可靠性问题：模块之间没有很强的隔离机制 实时性支持：系统太复杂导致无法做最坏情况时延分析 系统庞大而阻碍了创新：Linux代码行数已经过2千万 宏内核难以满足的场景 向上向下的扩展 很难去剪裁/扩展一个宏内核系统支持从KB级别到TB级别的场景 硬件异构性 很难长期支持一些定制化的方式去解决一些特定问题 功能安全 一个广泛共识：Linux无法通过汽车安全完整性认证（ASIL-D） 信息安全 单点错误会导致整个系统出错，而现在有数百个安全问题（CVE） 确定性时延 Linux花费10+年合并实时补丁，目前依然不确定是否能支持确定性时延 微内核定义微内核（MICRO-KERNEL）：与宏内核架构相反，它提倡内核功能尽可能少：仅仅只有进程调度、处理中断、内存空间映射、进程间通信等功能。 服务：开发者们把实际的进程管理、内存管理、设备管理、文件管理等服务功能，做成一个个服务进程。和用户应用进程一样，只是它们很特殊，宏内核提供的功能，在微内核架构里由这些服务进程专门负责完成。 消息：一种进程间通信的机制，应用程序要请求相关服务，就向微内核发送一条与此服务对应的消息，微内核再把这条消息转发给相关的服务进程，接着服务进程会完成相关的服务。服务进程的编程模型就是循环处理来自其它进程的消息，完成相关的服务功能。 下图中以文件系统为例，左边为宏内核架构，文件系统以API形式提供；右边为微内核架构，文件系统为一个服务，通过消息这种进程间通信方式请求服务。 微内核架构的设计原则：最小化内核功能 将操作系统功能移到用户态，称为”服务”（Server） 在用户模块之间，使用消息传递机制通信 以内存分配为例： 应用程序发送内存分配的消息，这个发送消息的函数是微内核提供的，相当于系统 API，微内核的 API（应用程序接口）相当少，极端情况下仅需要两个，一个接收消息的 API 和一个发送消息的 API。 处理器切换到特权模式，开始运行内核代码。 微内核代码让当前进程停止运行，并根据消息包中的数据，确定消息发送给谁，分配内存的消息当然是发送给内存管理服务进程。 内存管理服务进程收到消息，分配一块内存。 内存管理服务进程，也会通过消息的形式返回分配内存块的地址给内核，然后继续等待下一条消息。 微内核把包含内存块地址的消息返回给发送内存分配消息的应用程序。 处理器开始运行用户模式下的应用程序，应用程序就得到了一块内存的首地址，并且可以使用这块内存了。 优缺点优点： 易于扩展：直接添加一个用户进程即可为操作系统增加服务 易于移植：大部分模块与底层硬件无关 更加可靠：在内核模式运行的代码量大大减少 更加安全：即使存在漏洞，服务与服务之间存在进程粒度隔离 更加健壮：单个模块出现问题不会影响到系统整体 缺点： 性能较差：内核中的模块交互由函数调用变成了进程间通信，性能对比如下图 生态欠缺：尚未形成像Linux一样具有广泛开发者的社区 重用问题：重用宏内核操作系统提供兼容性，带来新问题 宏内核，微内核对比：黄色-OS；白色-App；蓝色-逻辑 混合内核架构混合内核架构是宏内核与微内核的结合。 将需要性能的模块重新放回内核态 macOS / iOS：Mach微内核 + BSD 4.3 + 系统框架 Windows NT：微内核 + 内核态的系统服务 + 系统框架 Mac OS的架构如下图： Mac OS有两个内核层——Mach 层与 BSD 层。 Mach 内核是卡耐基梅隆大学开发的经典微内核，意在提供最基本的操作系统服务，从而达到高性能、安全、可扩展的目的。 BSD 则是伯克利大学开发的类 UNIX 操作系统，提供一整套操作系统服务。 前沿的内核架构可以了解： 外核+库OS（EXOKERNEL + LIBOS） 多内核/复内核（MULTI-KERNEL） reference[1]上海交通大学并行与分布式系统研究所-操作系统结构 [2] 极客时间 · 操作系统实战45讲","link":"/2023/03/07/os-ostep-kernel-intro/"},{"title":"操作系统 - 操作系统定义与历史","text":"什么是操作系统操作系统是在硬件和应用之间的软件层 “操作系统是管理硬件资源、控制程序运行、改善人机界面 和为应用软件提供支持的一种系统软件。” [计算机百科全书(第2版)] 操作系统 = 管理 + 服务 操作系统为应用提供的一些服务: 为应用提供计算资源的抽象 CPU：进程/线程，数量不受物理CPU的限制 内存：虚拟内存，大小不受物理内存的限制 I/O设备：将各种设备统一抽象为文件，提供统一接口 为应用提供线程间的同步 应用可以实现自己的同步原语（如spinlock） 操作系统提供了更高效的同步原语（与线程切换配合, 如pthread_mutex） 为应用提供进程间的通信 应用可以利用网络进行进程间通信（如loopback设备） 操作系统提供了更高效的本地通信机制（具有更丰富的语义，如pipe） 操作系统对应用的管理: 生命周期的管理 应用的加载、迁移、销毁等操作 计算资源的分配 CPU：线程的调度机制 内存：物理内存的分配 I/O设备：设备的复用与分配 安全与隔离 应用程序内部：访问控制机制 应用程序之间：隔离机制，包括错误隔离和性能隔离 管理和服务的目标有可能存在冲突 服务的目标：单个应用的运行效率最大化 管理的目标：系统的资源整体利用率最大化 – 例：单纯强调公平性的调度策略往往资源利用率低,如细粒度的round-robin导致大量的上下文切换 操作系统的定义： 操作系统的核心功能： 将有限的、离散的资源，高效地抽象为无限的、连续的资源 从软件角度的定义： 硬件资源虚拟化+管理功能可编程 从结构角度的定义： 操作系统内核+系统框架 操作系统的历史早期操作系统：只是一些库一开始，操作系统只是一组常用函数库。例如，不是让系统中的每个程序员都编写低级 I/O 处理代码，而是让操作系统提供这样的 API，这样开发人员的工作更加轻松。 批（batch）处理：先把一些工作准备好，然后由操作员以“分批” 的方式运行（操作员决定运行作业的顺序）。 缺点：因为计算机闲置成本较高，因此此时的计算机缺少交互。 超越库：保护操作系统运行的代码是特殊的。因为OS控制了设备，因此对待它的方式应该与对待正常应用程序代码的方式不同。（若OS以库的方式提供磁盘I/O，那么任何程序都可以读取磁盘，而不存在隐私与隔离） 出于保护目的，划分出用户模式和内核模式。 用户模式(user mode)。在用户模式下运行的代码会受到限制，应用程序不能完全访问硬件资源。例如，I/O请求等。 内核模式(kernel mode)：在内核模式下，操作系统可以完全访问系统的硬件，因此可以执行诸如发起 I/O 请 求或为程序提供更多内存等功能。 使用系统调用（system call）将控制转移（跳转）到 OS 中，同时提高硬件特权级别（hardware privilege level）。 用户应用程序以所谓的用户模式（user mode）运行，这意味着硬件限制了应用程序的功能。 在发起系统调用时，硬件将控制转移到预先指定的陷阱处理程序（trap handler），并同时将特权级别提升到内核模式（kernel mode）。 在内核模式下，操作系统可以完全访问系统的硬件，因此可以执行诸如发起 I/O 请求或为程序提供更多内存等功能。 当操作系统完成请求的服务时，它通过特殊的陷阱返回 （return-from-trap）指令将控制权交还给用户，该指令返回到用户模式，同时将控制权交还给应用程序，回到应用离开的地方。 以下为printf的使用过程： 缺点：用户程序发生I/O时，CPU利用率较低。 多道批处理系统多道程序由于希望更好地利用机器资源，多道程序（multiprogramming）变得很普遍。 操作系统不是一次只运行一项作业，而是将大量作业加载到内存中甚在它们之间快速切换， 从而提高 CPU 利用率。这种切换非常重要，因为 I/O 设备很慢。 在 I/O 进行和任务中断时，要支持多道程序和重叠运行。多道程序给操作系统带来的挑战： 内存保护（memory protection），我们不希望一个程序能够访问另一个程序的内存。 并发（concurrency）问题。 在中断存在的情况下，确保操作系统正常运行是一个很大的挑战。 多道批处理系统早期的操作系统可以称为单道批处理系统。在单道批处理系统中，内存中仅有一道作业，它无法充分利用系统中的所有资源，致使系统性能较差。为了进一步提高资源的利用率和系统吞吐量，在20世纪60年代中期又引入了多道程序设计技术，由此而形成了多道批处理系统. 多道批处理系统有两个特点： 多道：系统内可同时容纳多个作业。这些作业放在外存中，组成一个后备队列，系统按一定的调度原则每次从后备作业队列中选取一个或多个作业进入内存运行，运行作业结束、退出运行和后备作业进入运行均由系统自动实现，从而在系统中形成一个自动转接的、连续的作业流。 成批：在系统运行过程中，不允许用户与其作业发生交互作用，即：作业一旦进入系统，用户就不能直接干预其作业的运行。 缺点：缺少交互，响应时间较长。 分时系统多道程序设计允许处理器同时处理多个批作业，还可处理多个交互作业。对于后者而言，由于多个用户分享处理器时间，因而该技术称为分时(time sharing)。 在分时系统中，多个用户可以通过终端同时访问系统，由操作系统控制每个用户程序在很短的时间内交替执行。 因此，如果有n个用户同时请求服务，若不计操作系统开销，每个用户平均只能得到计算机有效速度的1/n。但由于人的反应时间相对较慢，因此设计良好的系统响应时间应可以接近于专用计算机的响应时间。批处理和分时都使用了多道程序设计，其主要要差别如下表所示。 实时系统在指定或者确定的时间内完成系统功能以及对外部或内部事件在同步或异步时间内做出响应的系统，实时意思就是对响应时间有严格要求，要以足够快的速度进行处理。分为硬实时和软实时两种。 硬实时：某个动作必须绝对地在规定的时刻发生，否则会产生严重后果。（工业过程控制、民用航空、军事） 软实时：希望能满足时限，但页允许偶尔违反最终时限，偶尔违反不会产生严重后果。（多媒体系统） reference[1] 操作系统导论（ostep） [2]上海交通大学并行与分布式系统研究所-操作系统的前世今生 [3] 操作系统-精髓与设计原理 [4] 现代操作系统 [5] 操作系统概念","link":"/2023/03/07/os-ostep-history/"},{"title":"操作系统 - 进程调度","text":"进程调度概述定义进程存在的核心目的：虚拟化CPU，从而支持多个进程在少量的物理CPU上运行（每个进程以为它独享一个CPU）。 进程调度就是选择一个可用的进程（可能从多个可用进程集合中选择）到CPU上执行。单处理器系统从来不会有超过一个进程在运行。如果有多个进程，那么余下的则需要等待CPU空闲并重新调度。 调度队列进程进入系统时被加入到作业队列中，该队列包含系统中所有进程。 驻留在内存中等待运行的程序保存在就绪队列中，该队列常用链表来实现，其头节点指向链表的第一个和最后一个PCB块的指针。 操作系统也有其他队列。等待特定IO设备的进程列表称为设备队列。每个设备都有自己的设备队列。 就绪队列中进程在就绪队列中等待直到被选中执行或被派遣。当进程分配到CPU执行时，可能发生： 进程发出一个IO请求，并放到IO队列中。 进程创建新的子进程，并等待其结束。 进程由于中断而强制释放CPU（被抢占），并被放回到就绪队列中。 即如下图： 调度的分类 &amp; 调度程序调度有以下几种： 长程调度（作业调度）：决定加入待执行进程池 中程调度：决定加入部分/全部位于内存中的进程集合（换入/换出） 短程调度（进程调度）：决定处理器执行哪个可运行进程（执行） I/O调度：决定可用I/O设备处理哪个进程挂起的I/O请求 除I/O调度外，对应到队列如下图所示： 进程会在各种调度队列之间迁移，为了调度，操作系统必须按某种方式从这些队列中选择进程。进程的选择是由相应的调度程序（scheduler）来执行的。 短程调度程序 从准备执行的进程中选择进程，并为之分配CPU。 短程调度程序通常100ms至少执行一次，由于每次执行之间的时间较短，短程调度程序必须要快。 导致当前进程阻塞或抢占当前运行进程的事件（时钟中断、I/O 中断、操作系统调用、信号）发生时，会调用短程调度程序。 长程调度程序 批处理系统中，进程更多的是被提交，而不是马上执行。这些进程通常放到磁盘的缓冲池里，以便以后执行。长程（作业）调度程序从该池中选择进程，并装入内存以准备执行。 长程调度程序执行的并不频繁，所以长程调度程序能使用更多的时间来选择执行进程。长程调度程序控制多道程序设计的程度（内存中进程的数量）。长程调度程序必须仔细选择执行进程。 绝大多数进程可分为：I/O密集和计算（CPU）密集。为使系统达到平衡和更好的性能，长程调度程序应当选择一个合理的包含I/O为主的和CPU为主的组合进程以充分使用设备和短程调度程序。 Linux和Windows系统通常没有长程调度程序，这些系统的稳定性依赖于物理限制，如果系统性能下降很多，会有用户的退出。 中程调度程序 分时系统中可能引入中程调度程序，其核心思想是能够将进程从内存中移出，从而降低多道程序设计的程度，之后进程可以被换入。 三者在执行频繁程度上有较大差别，执行频繁程度：短程调度 &gt; 中程调度 &gt; 长程调度 调度算法● 非抢占：在这种情况下，一且进程处于运行状态，就会不断执行直到终止，进程要么因为等待I/O，要么因为请求某些操作系统服务而阻塞自己。 ● 抢占：当前正运行进程可能被操作系统中断,并转换为就绪态。一个新进程到达时，或中断发生后把一个阻塞态进程置为就绪态时，或出现周期性的时间中断时，需要进行抢占决策。 经典调度先来先服务 FCFS算法描述：非抢占、先请求CPU的进程先分配CPU。 缺点：在长短任务混合的场景下对短任务不友好 最短作业优先 SJF(SPN)算法描述：非抢占、下次选择预计时间最短的进程。 缺点： 必须预知任务运行时间 表现严重依赖于任务到达时间点 不公平，有饥饿风险 在SJF中加入抢占即是最短剩余时间优先。 抢占： 最短剩余时间有限 SRT算法描述：抢占、选择预期剩余时间最短的进程。 缺点： 必须预知任务运行时间 长任务有饥饿风险 时间片轮转(Round Robin ,RR)算法描述：抢占、以一个周期（q）产生中断，当中断发生时，当前运行的程序置于就绪队列（队尾）中，然后基于FCFS选择下一个就绪作业运行。 缺点：在任务运行时间相似的场景下平均周转时间高 经典调度算法对比： 实时调度每个任务都有截止时间（Deadline）。 软实时（Soft Real Time）：允许超过截止时间、视频播放，每一帧的渲染 硬实时（Hard Real Time）：不允许超过截止时间、自动驾驶汽车的刹车任务 最早截止时间优先 (Earliest Deadline First, EDA )算法描述：每次调度截止时间最近的任务 缺点：在任务不可调度时，会造成多数任务都错过截止时间（多米诺效应） 优先级调度算法描述：设置许多独立的队列（queue），每个队列有不同的优先级（priority level）。任何时刻，一个工作只能存在于一个队列中。优先级调度总是优先执行较高优先级的工作（即在较高级队列中的工作）。具有同样的优先级的作业采用轮转调度。 做法：多级反馈队列（Multi-level Feedback Queu, MLFQ） 公平共享调度 每个用户占用的资源是成比例的，而非被任务的数量决定 每个用户占用的资源是可以被计算的 设定”权重值”以确定相对比例（绝对值不重要） 例：权重为4的用户使用资源，是权重为2的用户的2倍 做法：彩票调度 reference[1] 操作系统概念 [2] 操作系统-精髓与设计原理 [3] 上海交通大学并行与分布式系统研究所-进程/线程调度 [4] 操作系统导论（ostep） [5] 现代操作系统","link":"/2023/03/07/os-ostep-scheduling/"},{"title":"操作系统 - 进程","text":"进程综述定义进程是正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。 进程不只是程序代码，程序代码称为文本段（代码段），还包括当前活动，通过程序计数器的值和处理器寄存器的内容来表示。此外，进程还包括进程堆栈段（临时数据、函数参数、局部变量、地址）和数据段（包括全局变量。还可能包括堆（heap），是在进程运行期间动态分配内存。 程序和进程的关系： 程序是被动实体，进程是活动实体（进程有开始，有结束、程序没有；进程会走走停停，程序走停无意义） 一个程序可以对应多个进程（不同进程间代码段相同，而数据段、堆栈等不同） 为什么要有进程这个概念核心目的：虚拟化CPU，从而支持多个进程在少量的物理CPU上运行（每个进程以为它独享一个CPU）。 操作系统通过虚拟化（virtualizing）CPU 来提供这种假象。通过让一个进程只运行一个时间片，然后切换到其他进程，操作系统提供了存在多个虚拟 CPU 的假象。这就是时分共享（time sharing）CPU 技术，允许用户如愿运行多个并发进程。潜在的开销就是性能损失， 因为如果 CPU 必须共享，每个进程的运行就会慢一点（上下文切换）。 进程创建核心问题：程序是如何转化为进程的？（即：操作系统如何启动并运 行一个程序？进程创建实际如何进行？） 将代码和所有静态数据（例如初始化变量）加载（load）到内存中，加载到进程的地址空间中。 为程序的运行时栈（run-time stack 或 stack）分配一些内存。 为程序的堆（heap）分配一些内存。 执行一些其他初始化任务，特别是与输入/输出（I/O）相关的任务。（在 UNIX 系统中，默认情况下每个进程都有标准输入stdin，标准输出stdout，标准错误stderr三个文件描述符） 启动程序， 在入口处运行，即 main()。 进程状态在三状态模型中，进程的三个状态如下： 运行（running）：在运行状态下，进程正在处理器上运行。这意味着它正在执行指令。 就绪（ready）：在就绪状态下，进程已准备好运行，但由于某种原因，操作系统选择不在此时运行。 阻塞（blocked）：在阻塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。 若加上新建态、退出态，则是五状态模型，两者本质上是一样的，三状态模型更能体现进程核心的状态。 三状态之间的转换如下图： 对应到操作系统中位以下图，处理器中运行的为运行态进程、就绪队列中为就绪态进程、阻塞队列中为阻塞态进程。 需要注意的是，运行态进程有三种转换去向： 发生I/O事件，进入阻塞队列，若I/O事件完成该进程则可转入就绪队列。 时间片到期，操作系统则抢占之，使之进入就绪队列，等待下一次调度。 进程完成，释放。 若考虑到I/O速度较慢且内存数量有限，只能容纳一部分的进程，因此存在内存中所有的进程都在等待I/O的情况。在这种情况中，CPU多数时间处于空闲状态。因此，将所有进程放入内存中是不理智的。可以通过将一部分进程换出到磁盘中，增大操作系统中的进程数目，从而充分利用CPU。 挂起（suspend），即将内存中某个进程的一部分或全部移到磁盘。当内存中不存在就绪态进程时，操作系统就把被阻塞的进程换出到磁盘中的挂起队列（suspend queue），即临时从内存中“踢出”的进程队列。 包含单挂的模型如下，相比与三/五状态模型，增加了一个挂起态： 单挂模型有个缺点：所有已被挂起进程都是阻塞态，那么将被阻塞的进程取回内存无任何意义。若I/O事件完成，阻塞态进程将不再阻塞，可以进入就绪态继续执行。因此可以将挂起态中的进程进行细分，即阻塞/挂起态及就绪/挂起态。 该模型中比较重要的状态转换为： 阻塞/挂起态-&gt;就绪/挂起态：若I/O事件完成，则将进程从阻塞/挂起态切换到就绪/挂起态。 进程描述进程在操作系统内用进程控制块（process control block, PCB)来表示，PCB包含了进程状态、程序计数器、cpu寄存器、cpu调度信息、内存管理信息、记账信息、I/O状态信息等信息。 进程状态： 状态可包括新的，就绪，运行，等待，终止等。 程序计数器 ： 计数器表示进程要执行的下个指令的地址。 CPU寄存器： 与程序计数器一起，这些寄存器的状态信息在出现中断时也需要保存，以便进程以后能正确的执行。 CPU调度信息：这类信息包括进程优先级、调度队列指针和其他调度参数。 内存管理信息：根据内存系统，这类信息包括基址和界限寄存器的值，页表或段表。 记账信息：这类信息包括CPU时间、实际使用时间、时间界限、记账数据、作业或进程数量等。 I/O状态信息：这类信息包含分配给进程的I/O设备列表、打开的文件列表等。 进程之间的切换就用到PCB： xv6中的进程描述信息如下：context即寄存器的上下文。 12345678910111213141516171819202122232425262728293031323334353637// the registers xv6 will save and restore// to stop and subsequently restart a processstruct context { int eip; int esp; int ebx; int ecx; int edx; int esi; int edi; int ebp;};// the different states a process can be inenum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };// the information xv6 tracks about each process// including its register context and statestruct proc { char *mem; // Start of process memory uint sz; // Size of process memory char *kstack; // Bottom of kernel stack // for this process enum proc_state state; // Process state int pid; // Process ID struct proc *parent; // Parent process void *chan; // If non-zero, sleeping on chan int killed; // If non-zero, have been killed struct file *ofile[NOFILE]; // Open files struct inode *cwd; // Current directory struct context context; // Switch here to run process struct trapframe *tf; // Trap frame for the // current interrupt}; Linux中的进程描述： 123456789// Represented by the C structure task_structstruct task_struct{ pid t pid; /* process identifier */ long state; /* state of the process */ unsigned int time slice /* scheduling information */ struct files_struct *files; /* list of open files */ struct mm struct *mm; /* address space of this pro */ // ...}; reference[1] 操作系统-精髓与设计原理 [2] 操作系统导论（ostep） [3] 操作系统概念 [4] 现代操作系统","link":"/2023/03/07/os-ostep-process/"},{"title":"操作系统 - 操作系统的整体结构","text":"操作系统的大致内容的思维导图： 操作系统在传统意义上都会有以下内容： 进程与线程 内存管理 文件系统 I/O 死锁 操作系统导论将操作系统视作三个简单的部分：虚拟化、并发、持久化。我认为是比较合理的，结合操作系统导论和现代操作系统的内容也能更好的学习操作系统。 reference [1] 操作系统导论 [2] 现代操作系统","link":"/2023/03/07/os-ostep-overview/"},{"title":"操作系统 - I&#x2F;O设备","text":"I/O设备综述I/O设备定义I/O设备是硬件中由人（或其他系统）使用与计算机进行通信的部件。 例如，键盘或鼠标是计算机的输入设备，而监控器和打印机是输出设备。计算机之间的通信设备（如电信调制解调器和网卡）通常运行输入和输出操作。操作系统需要控制计算机的所有I/O设备。 I/O设备划分根据信息交换的单位可讲I/O设备可分为块设备（block device）和字符设备（character device）两种。 块设备：由于信息的存取总是以数据块为单位，所以存储信息的设备称为块设备。它属于有结构设备，如磁盘等。磁盘设备的基本特征是传输速率较高，以及可寻址，即对它可随机地读/写任一块。 字符设备：用于数据输入/输出的设备为字符设备，因为其传输的基本单位是字符。它属于无结构类型，如交互式终端机、打印机等。它们的基本特征是传输速率低、不可寻址，并且在输入/输出时常釆用中断驱动方式。 该划分不一定能包括所有的I/O设备，比如说时钟（按照预先设置好的时间间隔去产生中断）。 标准设备与标准模型系统架构一个典型的计算机系统架构如下图： 为何该系统是分层的结构？ 物理布局（越快的总线越短，因此高性能的内存总线没有足够的空间连接太多设备） 造价成本（在工程上高性能总线的造价非常高） 采用分层结构，可以让要求高性能的设备（比如显卡）离 CPU 更近一些，低性能的设备离 CPU 远一些。 标准设备假定I/O设备是如下图所示的一种标准设备（非真实存在的设备） 一个标准设备包含两部分： 硬件接口（interface）。所有设备都有自己的特定接口以及典型交互的协议，系统软件通过该接口来控制设备的操作。 内部结构（internal structure）。这部分包含设备相关的特定实现，负责具体实现设备展示给系统的抽象接口。非常简单的设备通常用一个或几个芯片来实现它们的功能。更复杂的设备（RAID，廉价冗余磁盘阵列）会包含简单的 CPU、一些通用内存、设备相关的特定芯片，来完成它们的工作。 标准协议标准设备中包含3个寄存器： 状态（status）寄存器， 可以读取并查看设备的当前状态。 命令（command）寄存器，用于通知设备执行某个具体任务/ 数据（data）寄存器，将数据传给设备或从设备接收数据。 通过读写这些寄存器，操作系统可以控制设备的行为。假设操作系统与标准设备交互的标准协议如下： 1234567While (STATUS == BUSY) ; // wait until device is not busyWrite data to DATA registerWrite command to COMMAND register (Doing so starts the device and executes the command)While (STATUS == BUSY) ; // wait until device is done with your request 标准协议分为4步： 操作系统反复读取状态寄存器，等待设备进入可以接收命令的就绪状态，即轮询（polling）设备。 操作系统下发数据到数据寄存器。 操作系统将命令写入命令寄存器。 操作系统再次通过不断轮询设备，等待并判断设备是否执行完成命令。 I/O设备的编址方式独立编址I/O端口独立编址即内存地址空间与外设地址空间是相互独立的。 对I/O设备的访问需要使用明确的 I/O 指令（in/out，通常为特权指令）。这些指令规定了操作系统将数据发送到特定设备寄存器的方法，从而允许构造标准协议。 统一编址内存映射 I/O（memory- mapped I/O）：将每个I/O端口当作一个存储单元看待，端口与存储器单元在同一个地址空间中进行编址。 当需要访问设备寄存器时，操作系统装载（读取）或者存入（写入） 到该内存地址；然后硬件会将装载/存入转移到设备上，而不是物理内存。 基本输入输出方式轮询轮询，即操作系统通过反复读取状态寄存器，等待设备进入可以接收命令的就绪状态。 情况1，轮询：进程 1 在 CPU 上运行一段时间（对应 CPU 那一行上重复的 1），然后发出一个读取数据的 I/O 请求给磁盘。操作系统简单自旋，不断轮询设备状态，直到设备完成 I/O 操作（对应其中的 p）。当设备完成请求的操作后，进程 1 又可以继续运行。 中断通过中断（interrupt）可以减少 CPU 开销。有了中断后，CPU 不再需要不断轮询设备，而是向设备发出一个请求，然后就可以让对应进程睡眠，切换执行其他任务。当设备完成了自身操作，会抛出一个硬件中断，引发 CPU 跳转执行操作系统预先定义好的中断服务例程（Interrupt Service Routine，ISR），或更为简单的中断处理程序（interrupt handler）。中断处理程序是一小段操作系统代码，它会结束之前的请求（比如从设备读取到了数据或者错误码）并且唤醒等待 I/O 的进程继续执行。 情况2，中断：在磁盘处理进程 1 的请求时，操作系统在 CPU 上运行进程 2。磁盘处理完成后，触发一个中断，然后操作系统唤醒进程 1 继续运行。这样，在这段时间，无论 CPU 还是磁盘都可以有效地利用。 直接存储器存取（DMA）DMA（Direct Memory Access）。DMA 引擎是系统中的一个特殊设备， 它可以协调完成内存和设备间的数据传递，不需要 CPU 介入。 为了能够将数据传送给设备，操作系统会通过编程告诉 DMA 引擎数据在内存的位置，要拷贝的大小以及要拷贝到哪个设备。在此之后，操作系统就可以处理其他请求了。当 DMA 的任务完成后，DMA 控制器会抛出一个中断来告诉操作系统自己已经完成数据传输。 情况3，不使用DMA的一般情况：进程 1 在运行过程中需要向磁盘写一些数据，所以它开始进行 I/O 操作，将数据从内存 拷贝到磁盘（其中标示 c 的过程）。拷贝结束后，磁盘上的 I/O 操作开始执行，此时 CPU 才 可以处理其他请求。 情况4，使用DMA：数据的拷贝工作都是由 DMA 控制器来完成的。因为 CPU 在此时是空闲的，所以操作系统可以让它做一些其他事情，比如此处调度进程 2 到 CPU 来运行。 因此进程 2 在进程 1 再次运行之前可以使用更多的 CPU。 reference[1] wiki [2] 操作系统导论（ostep） [3] 现代操作系统 [4] 微型计算机原理与接口技术","link":"/2023/03/07/os-ostep-io/"},{"title":"操作系统 - PETERSON算法","text":"Peterson算法概述Peterson算法是一种实现进程/线程间互斥访问临界区的算法。（线程间共享内存地址空间，进程需要采用共享内存实现） 关键术语： 临界区：一段代码，进程/线程在这段代码中进程将访问共享资源，当另外一个进程已在这段代码运行时，其他进程就不能在这段代码中运行。 互斥：当一个进程/线程在临界区访问共享资源时，其他进程/线程不能进入临界区访问任何其他共享资源的情形。 wiki定义： Peterson’s algorithm (or Peterson’s solution) is a concurrent programming algorithm for mutual exclusion that allows two or more processes to share a single-use resource without conflict, using only shared memory for communication. It was formulated by Gary L. Peterson in 1981. While Peterson’s original formulation worked with only two processes, the algorithm can be generalized for more than two. Peterson算法实现该算法使用两个变量，flag 和 turn。 flag[n] 值为 true 表示进程 n 想要进入临界区。turn表示现在轮到谁，是一个进程编号。 123456789101112131415161718int flag[2];int turn;void init() { flag[0] = flag[1] = 0; // 1-&gt;thread wants to grab lock turn = 0; // whose turn? (thread 0 or 1?)}void lock() { flag[self] = 1; // self: thread ID of caller turn = 1 - self; // make it other thread's turn while ((flag[1-self] == 1) &amp;&amp; (turn == 1 - self)) ; // spin-wait}void unlock() { flag[self] = 0; // simply undo your intent} 算法解释： flag[self] = 1 ：设置自己进程感兴趣，想要访问临界区。 turn = 1 - self：将turn设置为对方进程。注意这个turn是个共享变量，若多进程/多线程进行访问，会保留最后一次写的turn值，前面写的值被写覆盖了（overwriting）。然后是一个自旋等待（CPU空转，忙等待，busy wait）：while ((flag[1-self] == 1) &amp;&amp; (turn == 1 - self)); 对该自旋等待真值表进行分析，如下： flag[1-self] == 1 turn == 1 - self 真值 含义 T T T 对方进程也想访问临界区，且turn值为自己设定 T F F 对方进程也想访问临界区，且turn值为对方设定 F T F 只有自己想访问临界区，直接访问即可。 F F F 只有自己想访问临界区，直接访问即可。 由上述真值表可见，仅有双方（两个进程/线程）都想访问临界区时，才会出现自旋情况。将上述情况以单核CPU情况模拟，有如下两种情况。 P0先写turn值而P1后写：P1自旋，P0进入临界区 Process 0 Process 1 turn值 事件 lock()flag[0] = 1; turn = 1; 1 调度程序调度P0执行 lock()flag[1] = 1; turn = 0; while ((flag[0] == 1) &amp;&amp; (turn == 0));P1自旋 0 中断，调度程序调度P1执行 进入临界区do something出临界区unlock()flag[0] = 0; 0 中断，调度程序调度P0执行 while ((flag[0] == 1) &amp;&amp; (turn == 0));自旋结束进入临界区do something出临界区unlock()flag[1] = 0; 0 中断，调度程序调度P1执行 P1先写turn值而P0后写：P0自旋，P1进入临界区 Process 0 Process 1 turn值 事件 lock()flag[1] = 1; turn = 0; 0 调度程序调度P1执行 lock()flag[0] = 1; turn = 1; while ((flag[1] == 1) &amp;&amp; (turn == 1));P1自旋 1 中断，调度程序调度P0执行 进入临界区do something出临界区unlock()flag[1] = 0; 1 中断，调度程序调度P1执行 while ((flag[1] == 1) &amp;&amp; (turn == 1));自旋结束进入临界区do something出临界区unlock()flag[0] = 0; 1 中断，调度程序调度P0执行 由上述例子可见：并发时，两进程/线程中存在着某种抢占的关系，即谁先写入turn值，就不会因此而自旋（因为自旋条件为turn为对面值）；若不是并发，则可以直接进入，而后上锁的进程/线程则需要等待先上锁进程/线程解锁。 算法评价Peterson算法是一种不依赖硬件实现的锁机制。如今大多数CPU以指令乱序执行来提高执行效率，此时实现Peterson算法就得使用相关内存屏障指令。现在一般使用硬件支持的锁机制（比如test-and-set或compare-and-swap），这些机制往往只需要很少的硬件支持。 reference[1] wiki [2] 操作系统导论 [3] 现代操作系统 [4] 深入理解计算机系统","link":"/2023/03/07/os-ostep-peterson/"},{"title":"操作系统 - 受限直接执行（Limited Direct Execution, LDE）","text":"概述虚拟化 CPU的概念：操作系统需要以某种方式让许多任务共享物理CPU,让它们看起来像是同时运行。 在本节需要解决的关键问题是：如何高效、可控地虚拟化 CPU？ 解决方法：采用受限直接执行（Limited Direct Execution, LDE）机制 直接执行的概念直接执行：直接在CPU上运行程序即可。使用正常的调用(call)跳转到用户程序的main()，用户程序结束后返回内核。 直接执行存在的问题优点：快速。该程序直接在硬件 CPU 上运行，因此执行速度与预期的 一样快。 存在的问题：不可控（对用户程序没有限制，且不能切换进程(时分共享)） 对用户程序没有限制（用户程序可能做出危害行为） 不能切换进程（即没有完成时分共享的目标） 问题1: 受限制的操作硬件通过提供不同的执行模式来协助操作系统。 用户模式(user mode)。在用户模式下运行的代码会受到限制，应用程序不能完全访问硬件资源。例如，I/O请求等。 内核模式(kernel mode)：操作系统(或内核)就以这种模式运行。 在此模式下，运行的代码可以做它喜欢的事，包括特权操作，如发出 I/O 请求和执行所有类 型的受限指令。 系统调用：即用户程序向内核请求服务，比如读一个文件（read）、创建新进程（fork），加载新程序（execve）等。通过系统调用可以实现用户程序受限制的操作。 如果一个进程正在用户态中运行一个用户程序,并且需要一个系统服务,比如从一个文件读数据,那么它就必须执行一个陷阱或系统调用指令,将控制转移到操作系统。（即从用户模式切换到内核模式）操作系统接着通过参数检查,找出所需要的调用进程。然后,它执行系统调用,并把控制返回给在系统调用后面跟随着的指令。（即从内核模式切换到用户模式） 系统调用通过如下指令进行模式切换： **陷入(trap)**：用户模式-&gt;内核模式 **从陷阱返回(return-from-trap)**：内核模式-&gt;用户模式 这两条指令类似于过程调用中的call,ret，但又有所不同： 系统调用切换到内核态。而过程调用指令并不改变模式。 过程调用给定过程所在的相对或绝对地址，TRAP指令不能跳转到任意地址上。根据机器的体系结构,或者跳转到一个单固定地址上,或者指令中有一8位长的字段,它给定了内存中一张表格的索引（陷阱表）,这张表格中含有跳转地址。 问题2: 进程切换协作模式协作(cooperative)模式：操作系统相信系统的进程会合理运行。OS 通过等待系统调用（显式的 yield 系统调用），或某种非法操作发生，从而重新获得 CPU 的控制权。 代表：早期版本的 Macintosh 操作系统或旧的 Xerox Alto 系统。 缺点：过于被动 非协作模式时钟中断(timer interrupt)：时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序(interrupt handler)会运行。此时，操作系统重新获得 CPU 的控制权，通过运行调度程序来做出是否切换进程。 一些小问题保存和恢复上下文为了保存当前正在运行的进程的上下文，操作系统会执行一些底层汇编代码，来保存通用寄存器、程序计数器，以及当前正在运行的进程的内核栈指针，然后恢复寄存器、程序计数器，并切换内核栈，供即将运行的进程使用。 123456789101112131415161718192021222324# void swtch(struct context **old, struct context *new); 2## Save current register context in old# and then load register context from new..globl swtchswtch:# Save old registersmovl 4(%esp), %eax # put old ptr into eax popl 0(%eax) # save the old IPmovl %esp, 4(%eax) # and stackmovl %ebx, 8(%eax) # and other registers movl %ecx, 12(%eax)movl %edx, 16(%eax)movl %esi, 20(%eax)movl %edi, 24(%eax)movl %ebp, 28(%eax)# Load new registersmovl 4(%esp), %eax # put new ptr into eaxmovl 28(%eax), %ebp # restore other registersmovl 24(%eax), %edimovl 20(%eax), %esimovl 16(%eax), %edxmovl 12(%eax), %ecxmovl 8(%eax), %ebxmovl 4(%eax), %esp # stack is switched herepushl 0(%eax) # return addr put in placeret # finally return into new ctxt 并发在中断或陷阱处理过程发生另一个中断？ 简单的解决办法：关中断，即在中断处理期间禁止中断。 reference[1]操作系统导论(ostep) [2]现代操作系统 [3]深入理解计算机系统(csapp)","link":"/2023/03/07/os-ostep-LDE/"}],"tags":[{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"cmu15445","slug":"cmu15445","link":"/tags/cmu15445/"},{"name":"debug","slug":"debug","link":"/tags/debug/"},{"name":"linux使用","slug":"linux使用","link":"/tags/linux%E4%BD%BF%E7%94%A8/"},{"name":"effective C++","slug":"effective-C","link":"/tags/effective-C/"},{"name":"qt","slug":"qt","link":"/tags/qt/"},{"name":"树莓派","slug":"树莓派","link":"/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"linux编程","slug":"linux编程","link":"/tags/linux%E7%BC%96%E7%A8%8B/"},{"name":"linux0.11","slug":"linux0-11","link":"/tags/linux0-11/"},{"name":"hitos","slug":"hitos","link":"/tags/hitos/"},{"name":"网络编程","slug":"网络编程","link":"/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"mit6.824","slug":"mit6-824","link":"/tags/mit6-824/"},{"name":"mit6.s081","slug":"mit6-s081","link":"/tags/mit6-s081/"},{"name":"操作系统理论","slug":"操作系统理论","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/"},{"name":"ostep","slug":"ostep","link":"/tags/ostep/"},{"name":"stl","slug":"stl","link":"/tags/stl/"},{"name":"missing semester","slug":"missing-semester","link":"/tags/missing-semester/"}],"categories":[{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"数据库系统","slug":"数据库系统","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"},{"name":"杂七杂八","slug":"杂七杂八","link":"/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"硬件","slug":"硬件","link":"/categories/%E7%A1%AC%E4%BB%B6/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"分布式系统","slug":"分布式系统","link":"/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"},{"name":"工具使用","slug":"工具使用","link":"/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"pages":[]}