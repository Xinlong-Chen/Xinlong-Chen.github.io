{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/03/05/hello-world/"},{"title":"cmu-15445-lab1","text":"本文为本人完成15445 2020fall（B+树版本）时的一些记录，仅作为备忘录使用。 TASK #1 - LRU REPLACEMENT POLICY本任务为实现一个LRU页面置换策略，建立一个关于面向磁盘的数据库的基本的概念是很重要的，如下图： 从中可以看出，实际数据是持久化存储于磁盘之上的，执行引擎主要进行一些数据操作（读/写，也即对Page增删改查），而BufferPool则是介于执行引擎和磁盘之间，位于内存中，给执行引擎提供Page。由于存储器体系结构一般表现为内存容量远小于磁盘容量，因此BufferPool是无法加载整个db的所有Pages的，因此需要在合适的时机将Page写入磁盘中，LRU就决定了牺牲哪个Page（即将哪个Page写回到磁盘中），其中包含了局部性原理的思想。 在Buffer Pool中，Page是存放在frame中的，这是要注意的一个点（buffer pool就是一个能容放多个Page的vector）。 The size of the LRUReplacer is the same as buffer pool since it contains placeholders for all of the frames in the BufferPoolManager. However, not all the frames are considered as in the LRUReplacer. The LRUReplacer is initialized to have no frame in it. Then, only the newly unpinned ones will be considered in the LRUReplacer. 所要实现的接口主要是下面四个： Victim(T*) : Remove the object that was accessed the least recently compared to all the elements being tracked by the Replacer, store its contents in the output parameter and return True. If the Replacer is empty return False. Pin(T) : This method should be called after a page is pinned to a frame in the BufferPoolManager. It should remove the frame containing the pinned page from the LRUReplacer. Unpin(T) : This method should be called when the pin_count of a page becomes 0. This method should add the frame containing the unpinned page to the LRUReplacer. Size() : This method returns the number of frames that are currently in the LRUReplacer. LRU的实现十分的简单，是经典的leetcode题，用list套一个unordered_map即可实现。 下面主要讲一下我对Pin和UnPin的理解： Pin(T) : 将一个Page(frame)从LRU的list中剔除。即该Page(frame)被Buffer Pool所使用了，LRU不应该牺牲该页面。 Unpin(T) : 加入一个Page(frame)入LRU的list。即该页面Buffer Pool目前没人使用了，LRU根据策略决定该页面的去留。 Victim(T*) :意思很直接，LRU根据规则（最近最少使用）有选择性的牺牲一个页面(frame)。 并发的话，直接加大锁就好了。std::lock_guard是一种RAII的加锁方式，可以不用unlock（在析构的时候unlock），比较方便。给出Victim的实现方法，其他的应 Prof. Pavlo 要求就不放出来了。 1234567891011bool LRUReplacer::Victim(frame_id_t *frame_id) { std::lock_guard&lt;std::mutex&gt; lock(latch_); if (id2iter_.empty()) { return false; } auto deleting_id = lru_list_.back(); lru_list_.pop_back(); id2iter_.erase(deleting_id); *frame_id = deleting_id; return true;} TASK #2 - BUFFER POOL MANAGER第二个任务为构造一个Buffer Pool。 The BufferPoolManager is responsible for fetching database pages from the DiskManager and storing them in memory. The BufferPoolManager can also write dirty pages out to disk when it is either explicitly instructed to do so or when it needs to evict a page to make space for a new page. 实现以下几个接口： FetchPageImpl(page_id) NewPageImpl(page_id) UnpinPageImpl(page_id, is_dirty) FlushPageImpl(page_id) DeletePageImpl(page_id) FlushAllPagesImpl() (其实可以先通过测试程序了解这几个接口怎么用的，然后再去实现会比较好！) NewPageImpl(page_id)：新建一个Page。 FetchPageImpl(page_id)：获取一个Page。 UnpinPageImpl(page_id, is_dirty)：解除对某个Page的使用（别的进程可能还在使用，pin_count为0的时候可以删除） DeletePageImpl(page_id)：删除一个Page。 FlushPageImpl(page_id)：强制将某个Page写盘。 FlushAllPagesImpl()：将所有Page写盘。 这个task其实本质上就是考验对下面两个点的理解，根据提示看看DiskManager 的API是比较好实现的： Dirty Flag ：当该flag为真时，该页被写过了，要写回磁盘。 Pin/Reference Counter：引用计数，当该计数为0时，将对应frame加入LRU中；当该计数不为0时，将对应frame从LRU中删除（即不参与LRU的替换）。 该task有几个坑需要注意一下： 重复UnpinPageImpl，但is_dirty标志不同。 不是简单的赋值设置is_dirty标志，而是累计，即或一下。 page-&gt;is_dirty_ |= is_dirty; New完一个Page后，其pin_count为1，因此不要将这个Page放入LRU。 replacer_-&gt;Pin(fid); New完一个Page后，要立即刷盘。可能会有new完以后unpin(false)的情况，不刷盘这一页就丢失了 disk_manager_-&gt;WritePage(new_page-&gt;GetPageId(), new_page-&gt;GetData()); 获取frame时，先从free list获取，再从lru中获取。 12345678910111213141516/*** @brief get a free page from free_list or lru_list** @return frame_id_t frame id, -1 is error*/frame_id_t BufferPoolManager::get_free_frame() {frame_id_t frame_id = -1;if (!free_list_.empty()) { frame_id = free_list_.front(); free_list_.pop_front();} else { replacer_-&gt;Victim(&amp;frame_id);}return frame_id;} 删除一个Page时，要保证free list和LRU中只存在一个fid，而不是两边都有。 replacer_-&gt;Pin(fid); free_list_.emplace_back(fid); 由于是多线程的程序，可以多跑几次测试一下，通过日志排查出错的原因。 12345678910111213141516#!/usr/bin/env bashtrap 'exit 1' INTecho &quot;Running test $1 for $2 iters&quot;for i in $(seq 1 $2); do echo -ne &quot;\\r$i / $2&quot; LOG=&quot;$i.txt&quot; # Failed go test return nonzero exit codes $1 &amp;&gt; $LOG if [[ $? -eq 0 ]]; then rm $LOG else echo &quot;Failed at iter $i, saving log at $LOG&quot; fidone （gradescope上测试要是失败了可以直接偷测试文件，逃 若有概念不理解的可以翻翻课件。","link":"/2023/03/05/cmu-15445-lab1/"},{"title":"effective_cpp_1","text":"第一章 让自己习惯 C++（Accustoming Youself to C++）条款1：视C++为一个语言联邦C++是个多重范型编程语言，同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式。 视C++为一个语言联邦，包括以下四个部分： C：面向过程的部分 Object-Oriented C++：面向对象的部分，包括封装、继承、多态以及虚函数（动态绑定）等。 Template C++：泛型编程部分 STL： 融合泛型编程和OOP编程思想的C++标准模板库，包括容器、迭代器、算法以及函数对象等。 请记住： C++高效编程守则视状况而变化，取决于使用的是这四个部分中的哪一部分。 条款2：尽量以const，enum，inline代替#define宁可以编译器代替预处理器。 #define即宏定义在预处理阶段进行处理，不进入记号表（symbol table）。 123int a = 5, b = 0;CALL_MAX(++a, b); //a被累加2次CALL_MAX(++a, b + 10); //a被累加1次 这是不可预料的行为，因此使用内联函数来代替宏定义函数。 请记住： 对于单纯常量，最好使用const对象或enum替换#defines。 对于形似函数的宏，最好改用inline函数替换#defines。 条款3：尽可能使用constconst关键字告诉编译器某值应该保持不变，即为只读的。 const成员函数两个成员函数如果只是常量性不同，可以被重载。 const成员函数代表this指针的类型为：const className &amp;。 使用const成员函数来处理const对象。 在const和non-cons成员函数中避免重复利用non-const版本调用const版本，再加上转型const_cast、static_cast,例如： 123456const char&amp; operator[](int pos) const;//const版本char&amp; operator[](int pos) { //non-const版本 return const_cast&lt;char&amp;&gt; //返回值转型，移除const (static_cast&lt;const className&amp;&gt;(*this)[pos]);//*this转型,增加const} 但反过来使用const版本调用non-const版本则是一种错误行为。 请记住： 将某些东西声明为const可以帮助编译器侦测除错误；const可以被施加在任何作用域内的对象、函数参数、函数返回类型、成员函数本身。 编译器强制实施bitwise constness，但是你编写程序时应该使用“概念上的常量性”。 当const和non-const成员函数有着实质等价的实现时，使用non-const版本来调用const版本可以避免代码重复。 条款4：确定对象使用前已被初始化永远在对象使用之前将其初始化。 对于内置类型，手动初始化。 对于非内置类型，使用构造函数进行初始化。 赋值和初始化有区别： 12345678910// 赋值，而非初始化ABEntry(const string&amp; name, const string&amp; address, int num) { _name = name; _address = address; _num = num; }// 初始化，发生在进入构造函数本体之前// 即成员初值列(member initialization list)ABEntry::ABEntry(const string&amp; name, const string&amp; address, int num) : _name(name), _address(address), _num(num) { } C++有着固定的初始化顺序：按照声明顺序进行初始化，且基类先于派生类初始化 static对象：其寿命从被构造出来直到程序结束为止。 local static object(局部静态对象)：函数内的static对象。 non-local static object(非局部静态对象)：非函数内的static对象，不同编译单元之间初始化次序不确定 因此，要解决non-local static object初始化次序问题，就要将non-local static object转换为local static object（使用单例模式，即封装一层函数） 123456789101112class Singleton{public: static Singleton&amp; getInstance() { static Singleton s; return s; }private: Singleton() {} Singleton(const Singleton&amp;); void operator=(const Singleton&amp;);}; 请记住: 为内置类型进行手工初始化，C++不保证初始化它们。 构造函数最好使用成员初值列，不要在构造函数中使用赋值操作，初值列中的成员变量的顺序应该和声明顺序一致。 为免除“跨编译单元之初始化次序”问题，使用返回local static对象引用的函数来代替non-local static对象。 reference[1] Effective C++ · Scott Meyers","link":"/2023/03/05/effective-cpp-1/"},{"title":"effective_cpp_2","text":"第一章 让自己习惯 C++（Accustoming Youself to C++）条款1：视C++为一个语言联邦C++是个多重范型编程语言，同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式。 视C++为一个语言联邦，包括以下四个部分： C：面向过程的部分 Object-Oriented C++：面向对象的部分，包括封装、继承、多态以及虚函数（动态绑定）等。 Template C++：泛型编程部分 STL： 融合泛型编程和OOP编程思想的C++标准模板库，包括容器、迭代器、算法以及函数对象等。 请记住： C++高效编程守则视状况而变化，取决于使用的是这四个部分中的哪一部分。 条款2：尽量以const，enum，inline代替#define宁可以编译器代替预处理器。 #define即宏定义在预处理阶段进行处理，不进入记号表（symbol table）。 123int a = 5, b = 0;CALL_MAX(++a, b); //a被累加2次CALL_MAX(++a, b + 10); //a被累加1次 这是不可预料的行为，因此使用内联函数来代替宏定义函数。 请记住： 对于单纯常量，最好使用const对象或enum替换#defines。 对于形似函数的宏，最好改用inline函数替换#defines。 条款3：尽可能使用constconst关键字告诉编译器某值应该保持不变，即为只读的。 const成员函数两个成员函数如果只是常量性不同，可以被重载。 const成员函数代表this指针的类型为：const className &amp;。 使用const成员函数来处理const对象。 在const和non-cons成员函数中避免重复利用non-const版本调用const版本，再加上转型const_cast、static_cast,例如： 123456const char&amp; operator[](int pos) const;//const版本char&amp; operator[](int pos) { //non-const版本 return const_cast&lt;char&amp;&gt; //返回值转型，移除const (static_cast&lt;const className&amp;&gt;(*this)[pos]);//*this转型,增加const} 但反过来使用const版本调用non-const版本则是一种错误行为。 请记住： 将某些东西声明为const可以帮助编译器侦测除错误；const可以被施加在任何作用域内的对象、函数参数、函数返回类型、成员函数本身。 编译器强制实施bitwise constness，但是你编写程序时应该使用“概念上的常量性”。 当const和non-const成员函数有着实质等价的实现时，使用non-const版本来调用const版本可以避免代码重复。 条款4：确定对象使用前已被初始化永远在对象使用之前将其初始化。 对于内置类型，手动初始化。 对于非内置类型，使用构造函数进行初始化。 赋值和初始化有区别： 12345678910// 赋值，而非初始化ABEntry(const string&amp; name, const string&amp; address, int num) { _name = name; _address = address; _num = num; }// 初始化，发生在进入构造函数本体之前// 即成员初值列(member initialization list)ABEntry::ABEntry(const string&amp; name, const string&amp; address, int num) : _name(name), _address(address), _num(num) { } C++有着固定的初始化顺序：按照声明顺序进行初始化，且基类先于派生类初始化 static对象：其寿命从被构造出来直到程序结束为止。 local static object(局部静态对象)：函数内的static对象。 non-local static object(非局部静态对象)：非函数内的static对象，不同编译单元之间初始化次序不确定 因此，要解决non-local static object初始化次序问题，就要将non-local static object转换为local static object（使用单例模式，即封装一层函数） 123456789101112class Singleton{public: static Singleton&amp; getInstance() { static Singleton s; return s; }private: Singleton() {} Singleton(const Singleton&amp;); void operator=(const Singleton&amp;);}; 请记住: 为内置类型进行手工初始化，C++不保证初始化它们。 构造函数最好使用成员初值列，不要在构造函数中使用赋值操作，初值列中的成员变量的顺序应该和声明顺序一致。 为免除“跨编译单元之初始化次序”问题，使用返回local static对象引用的函数来代替non-local static对象。 reference[1] Effective C++ · Scott Meyers","link":"/2021/12/19/effective-cpp-2/"},{"title":"cpp_default_parameters","text":"c++规定默认参数必须从函数参数的右边向左边使用，如下： 正确： 12void fun1(int a, int b=10);void fun2(int a, int b=10, int c=20); 错误： 12void fun3(int a=5, int b, int c);void fun4(int a, int b=5, int c); 默认参数不能在声明和定义中同时出现 错误： 12void fun1(int a=10);void fun1(int a=10){......} 正确： 12345void fun2(int a=10);void fun2(int a){......}// orvoid fun2(int a);void fun2(int a=10){......}","link":"/2021/12/11/cpp-default-parameters/"},{"title":"cpp_header_file","text":"1 头文件的布局： 2 #define 保护 所有头文件都应该有 #define 保护来防止头文件被多重包含, 命名格式当是: &lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_ 。 防御式开头防止重复include头文件。 1234#ifndef COMMON_H#define COMMON_H//.... code#endif //COMMON_H Google C++规范： 为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径。 例如, 项目 foo 中的头文件 foo/src/bar/baz.h 可按如下方式保护: 1234#ifndef FOO_BAR_BAZ_H_#define FOO_BAR_BAZ_H_...#endif // FOO_BAR_BAZ_H_ 也可以使用 1#pragma once 3 前置声明 尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。 前置声明（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义。 前置声明是为了降低编译依赖，防止修改一个头文件引发多米诺效应。 Google C++规范： 优点： 节省编译时间：多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。 节省不必要的重新编译的时间： #include 使代码因为头文件中无关的改动而被重新编译多次。 缺点： 前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。 前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。 极端情况下，用前置声明代替 #include 甚至都会暗暗地改变代码的含义： 123456789// b.h:struct B {};struct D : B {};// good_user.cc:#include &quot;b.h&quot;void f(B*);void f(void*);void test(D* x) { f(x); } // calls f(B*) ​ 如果 #include 被 B 和 D 的前置声明替代， test() 就会调用 f(void*) 结论： 尽量避免前置声明那些定义在其他项目中的实体. 函数：总是使用 #include. 类模板：优先使用 #include. 4 内联函数 只有当函数只有 10 行甚至更少时才将其定义为内联函数. 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用。 在类的声明中定义的函数将被编译器尝试翻译为内联函数。 优点: 只要内联的函数体较小, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联. 缺点: 滥用内联将导致程序变得更慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。 经验： 不要内联超过 10 行的函数 谨慎对待析构函数 内联包含循环或 switch 语句的函数往往得不偿失 一般不会被内联的函数：虚函数和递归函数不会被正常内联 5 #include 的路径及顺序 使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 .h, 本项目内的 .h. 项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 . (当前目录) 或 .. (上级目录).(即使用绝对路径而非相对路径) #include 的顺序： dir2/foo2.h (这个cpp文件对应的.h文件，放置于优先位置) C 系统文件 C++ 系统文件 其他库的 .h 文件 本项目内 .h 文件 这种优先的顺序排序保证 dir2/foo2.h（.h文件） 遗漏某些必要的库时， 其实现/测试（.cpp文件）的构建会立刻中止。这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是别人。","link":"/2021/10/26/cpp-header-file/"},{"title":"cpp_oop_intro","text":"C vs C++C是面向过程的，C++是面向对象的，面向对象即是讲一些数据和函数绑定在一起。 对象(classes)的两种经典分类 Class without pointer members complex 拷贝都得一一复制（因为数据成员都包含在对象中了） Class with pointer members string 拷贝分深浅，因此有移动语义（C++11支持） C++程序代码的基本形式一般而言分 .cpp 或 .h 两种： .h ：写一些类的声明 .cpp ：类的实现 也不一定是 .cpp 或 .h 文件，也有可能是 .hpp 等文件。","link":"/2021/10/26/cpp-oop-intro/"}],"tags":[{"name":"cmu15445","slug":"cmu15445","link":"/tags/cmu15445/"},{"name":"Effective C++","slug":"Effective-C","link":"/tags/Effective-C/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"}],"categories":[],"pages":[]}