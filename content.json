{"posts":[{"title":"CMU15445 - lab1","text":"本文为本人完成15445 2020fall（B+树版本）时的一些记录，仅作为备忘录使用。 TASK #1 - LRU REPLACEMENT POLICY本任务为实现一个LRU页面置换策略，建立一个关于面向磁盘的数据库的基本的概念是很重要的，如下图： 从中可以看出，实际数据是持久化存储于磁盘之上的，执行引擎主要进行一些数据操作（读/写，也即对Page增删改查），而BufferPool则是介于执行引擎和磁盘之间，位于内存中，给执行引擎提供Page。由于存储器体系结构一般表现为内存容量远小于磁盘容量，因此BufferPool是无法加载整个db的所有Pages的，因此需要在合适的时机将Page写入磁盘中，LRU就决定了牺牲哪个Page（即将哪个Page写回到磁盘中），其中包含了局部性原理的思想。 在Buffer Pool中，Page是存放在frame中的，这是要注意的一个点（buffer pool就是一个能容放多个Page的vector）。 The size of the LRUReplacer is the same as buffer pool since it contains placeholders for all of the frames in the BufferPoolManager. However, not all the frames are considered as in the LRUReplacer. The LRUReplacer is initialized to have no frame in it. Then, only the newly unpinned ones will be considered in the LRUReplacer. 所要实现的接口主要是下面四个： Victim(T*) : Remove the object that was accessed the least recently compared to all the elements being tracked by the Replacer, store its contents in the output parameter and return True. If the Replacer is empty return False. Pin(T) : This method should be called after a page is pinned to a frame in the BufferPoolManager. It should remove the frame containing the pinned page from the LRUReplacer. Unpin(T) : This method should be called when the pin_count of a page becomes 0. This method should add the frame containing the unpinned page to the LRUReplacer. Size() : This method returns the number of frames that are currently in the LRUReplacer. LRU的实现十分的简单，是经典的leetcode题，用list套一个unordered_map即可实现。 下面主要讲一下我对Pin和UnPin的理解： Pin(T) : 将一个Page(frame)从LRU的list中剔除。即该Page(frame)被Buffer Pool所使用了，LRU不应该牺牲该页面。 Unpin(T) : 加入一个Page(frame)入LRU的list。即该页面Buffer Pool目前没人使用了，LRU根据策略决定该页面的去留。 Victim(T*) :意思很直接，LRU根据规则（最近最少使用）有选择性的牺牲一个页面(frame)。 并发的话，直接加大锁就好了。std::lock_guard是一种RAII的加锁方式，可以不用unlock（在析构的时候unlock），比较方便。给出Victim的实现方法，其他的应 Prof. Pavlo 要求就不放出来了。 1234567891011bool LRUReplacer::Victim(frame_id_t *frame_id) { std::lock_guard&lt;std::mutex&gt; lock(latch_); if (id2iter_.empty()) { return false; } auto deleting_id = lru_list_.back(); lru_list_.pop_back(); id2iter_.erase(deleting_id); *frame_id = deleting_id; return true;} TASK #2 - BUFFER POOL MANAGER第二个任务为构造一个Buffer Pool。 The BufferPoolManager is responsible for fetching database pages from the DiskManager and storing them in memory. The BufferPoolManager can also write dirty pages out to disk when it is either explicitly instructed to do so or when it needs to evict a page to make space for a new page. 实现以下几个接口： FetchPageImpl(page_id) NewPageImpl(page_id) UnpinPageImpl(page_id, is_dirty) FlushPageImpl(page_id) DeletePageImpl(page_id) FlushAllPagesImpl() (其实可以先通过测试程序了解这几个接口怎么用的，然后再去实现会比较好！) NewPageImpl(page_id)：新建一个Page。 FetchPageImpl(page_id)：获取一个Page。 UnpinPageImpl(page_id, is_dirty)：解除对某个Page的使用（别的进程可能还在使用，pin_count为0的时候可以删除） DeletePageImpl(page_id)：删除一个Page。 FlushPageImpl(page_id)：强制将某个Page写盘。 FlushAllPagesImpl()：将所有Page写盘。 这个task其实本质上就是考验对下面两个点的理解，根据提示看看DiskManager 的API是比较好实现的： Dirty Flag ：当该flag为真时，该页被写过了，要写回磁盘。 Pin/Reference Counter：引用计数，当该计数为0时，将对应frame加入LRU中；当该计数不为0时，将对应frame从LRU中删除（即不参与LRU的替换）。 该task有几个坑需要注意一下： 重复UnpinPageImpl，但is_dirty标志不同。 不是简单的赋值设置is_dirty标志，而是累计，即或一下。 page-&gt;is_dirty_ |= is_dirty; New完一个Page后，其pin_count为1，因此不要将这个Page放入LRU。 replacer_-&gt;Pin(fid); New完一个Page后，要立即刷盘。可能会有new完以后unpin(false)的情况，不刷盘这一页就丢失了 disk_manager_-&gt;WritePage(new_page-&gt;GetPageId(), new_page-&gt;GetData()); 获取frame时，先从free list获取，再从lru中获取。 12345678910111213141516/*** @brief get a free page from free_list or lru_list** @return frame_id_t frame id, -1 is error*/frame_id_t BufferPoolManager::get_free_frame() {frame_id_t frame_id = -1;if (!free_list_.empty()) { frame_id = free_list_.front(); free_list_.pop_front();} else { replacer_-&gt;Victim(&amp;frame_id);}return frame_id;} 删除一个Page时，要保证free list和LRU中只存在一个fid，而不是两边都有。 replacer_-&gt;Pin(fid); free_list_.emplace_back(fid); 由于是多线程的程序，可以多跑几次测试一下，通过日志排查出错的原因。 12345678910111213141516#!/usr/bin/env bashtrap 'exit 1' INTecho &quot;Running test $1 for $2 iters&quot;for i in $(seq 1 $2); do echo -ne &quot;\\r$i / $2&quot; LOG=&quot;$i.txt&quot; # Failed go test return nonzero exit codes $1 &amp;&gt; $LOG if [[ $? -eq 0 ]]; then rm $LOG else echo &quot;Failed at iter $i, saving log at $LOG&quot; fidone （gradescope上测试要是失败了可以直接偷测试文件，逃 若有概念不理解的可以翻翻课件。","link":"/2023/03/05/cmu-15445-lab1/"},{"title":"Effective C++ 第一章 让自己习惯 C++","text":"第一章 让自己习惯 C++（Accustoming Youself to C++）条款1：视C++为一个语言联邦C++是个多重范型编程语言，同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式。 视C++为一个语言联邦，包括以下四个部分： C：面向过程的部分 Object-Oriented C++：面向对象的部分，包括封装、继承、多态以及虚函数（动态绑定）等。 Template C++：泛型编程部分 STL： 融合泛型编程和OOP编程思想的C++标准模板库，包括容器、迭代器、算法以及函数对象等。 请记住： C++高效编程守则视状况而变化，取决于使用的是这四个部分中的哪一部分。 条款2：尽量以const，enum，inline代替#define宁可以编译器代替预处理器。 #define即宏定义在预处理阶段进行处理，不进入记号表（symbol table）。 123int a = 5, b = 0;CALL_MAX(++a, b); //a被累加2次CALL_MAX(++a, b + 10); //a被累加1次 这是不可预料的行为，因此使用内联函数来代替宏定义函数。 请记住： 对于单纯常量，最好使用const对象或enum替换#defines。 对于形似函数的宏，最好改用inline函数替换#defines。 条款3：尽可能使用constconst关键字告诉编译器某值应该保持不变，即为只读的。 const成员函数两个成员函数如果只是常量性不同，可以被重载。 const成员函数代表this指针的类型为：const className &amp;。 使用const成员函数来处理const对象。 在const和non-cons成员函数中避免重复利用non-const版本调用const版本，再加上转型const_cast、static_cast,例如： 123456const char&amp; operator[](int pos) const;//const版本char&amp; operator[](int pos) { //non-const版本 return const_cast&lt;char&amp;&gt; //返回值转型，移除const (static_cast&lt;const className&amp;&gt;(*this)[pos]);//*this转型,增加const} 但反过来使用const版本调用non-const版本则是一种错误行为。 请记住： 将某些东西声明为const可以帮助编译器侦测除错误；const可以被施加在任何作用域内的对象、函数参数、函数返回类型、成员函数本身。 编译器强制实施bitwise constness，但是你编写程序时应该使用“概念上的常量性”。 当const和non-const成员函数有着实质等价的实现时，使用non-const版本来调用const版本可以避免代码重复。 条款4：确定对象使用前已被初始化永远在对象使用之前将其初始化。 对于内置类型，手动初始化。 对于非内置类型，使用构造函数进行初始化。 赋值和初始化有区别： 12345678910// 赋值，而非初始化ABEntry(const string&amp; name, const string&amp; address, int num) { _name = name; _address = address; _num = num; }// 初始化，发生在进入构造函数本体之前// 即成员初值列(member initialization list)ABEntry::ABEntry(const string&amp; name, const string&amp; address, int num) : _name(name), _address(address), _num(num) { } C++有着固定的初始化顺序：按照声明顺序进行初始化，且基类先于派生类初始化 static对象：其寿命从被构造出来直到程序结束为止。 local static object(局部静态对象)：函数内的static对象。 non-local static object(非局部静态对象)：非函数内的static对象，不同编译单元之间初始化次序不确定 因此，要解决non-local static object初始化次序问题，就要将non-local static object转换为local static object（使用单例模式，即封装一层函数） 123456789101112class Singleton{public: static Singleton&amp; getInstance() { static Singleton s; return s; }private: Singleton() {} Singleton(const Singleton&amp;); void operator=(const Singleton&amp;);}; 请记住: 为内置类型进行手工初始化，C++不保证初始化它们。 构造函数最好使用成员初值列，不要在构造函数中使用赋值操作，初值列中的成员变量的顺序应该和声明顺序一致。 为免除“跨编译单元之初始化次序”问题，使用返回local static对象引用的函数来代替non-local static对象。 reference[1] Effective C++ · Scott Meyers","link":"/2021/12/12/effective-cpp-1/"},{"title":"Effective C++ 第二章 构造&#x2F;析构&#x2F;赋值运算","text":"第一章 让自己习惯 C++（Accustoming Youself to C++）条款1：视C++为一个语言联邦C++是个多重范型编程语言，同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式。 视C++为一个语言联邦，包括以下四个部分： C：面向过程的部分 Object-Oriented C++：面向对象的部分，包括封装、继承、多态以及虚函数（动态绑定）等。 Template C++：泛型编程部分 STL： 融合泛型编程和OOP编程思想的C++标准模板库，包括容器、迭代器、算法以及函数对象等。 请记住： C++高效编程守则视状况而变化，取决于使用的是这四个部分中的哪一部分。 条款2：尽量以const，enum，inline代替#define宁可以编译器代替预处理器。 #define即宏定义在预处理阶段进行处理，不进入记号表（symbol table）。 123int a = 5, b = 0;CALL_MAX(++a, b); //a被累加2次CALL_MAX(++a, b + 10); //a被累加1次 这是不可预料的行为，因此使用内联函数来代替宏定义函数。 请记住： 对于单纯常量，最好使用const对象或enum替换#defines。 对于形似函数的宏，最好改用inline函数替换#defines。 条款3：尽可能使用constconst关键字告诉编译器某值应该保持不变，即为只读的。 const成员函数两个成员函数如果只是常量性不同，可以被重载。 const成员函数代表this指针的类型为：const className &amp;。 使用const成员函数来处理const对象。 在const和non-cons成员函数中避免重复利用non-const版本调用const版本，再加上转型const_cast、static_cast,例如： 123456const char&amp; operator[](int pos) const;//const版本char&amp; operator[](int pos) { //non-const版本 return const_cast&lt;char&amp;&gt; //返回值转型，移除const (static_cast&lt;const className&amp;&gt;(*this)[pos]);//*this转型,增加const} 但反过来使用const版本调用non-const版本则是一种错误行为。 请记住： 将某些东西声明为const可以帮助编译器侦测除错误；const可以被施加在任何作用域内的对象、函数参数、函数返回类型、成员函数本身。 编译器强制实施bitwise constness，但是你编写程序时应该使用“概念上的常量性”。 当const和non-const成员函数有着实质等价的实现时，使用non-const版本来调用const版本可以避免代码重复。 条款4：确定对象使用前已被初始化永远在对象使用之前将其初始化。 对于内置类型，手动初始化。 对于非内置类型，使用构造函数进行初始化。 赋值和初始化有区别： 12345678910// 赋值，而非初始化ABEntry(const string&amp; name, const string&amp; address, int num) { _name = name; _address = address; _num = num; }// 初始化，发生在进入构造函数本体之前// 即成员初值列(member initialization list)ABEntry::ABEntry(const string&amp; name, const string&amp; address, int num) : _name(name), _address(address), _num(num) { } C++有着固定的初始化顺序：按照声明顺序进行初始化，且基类先于派生类初始化 static对象：其寿命从被构造出来直到程序结束为止。 local static object(局部静态对象)：函数内的static对象。 non-local static object(非局部静态对象)：非函数内的static对象，不同编译单元之间初始化次序不确定 因此，要解决non-local static object初始化次序问题，就要将non-local static object转换为local static object（使用单例模式，即封装一层函数） 123456789101112class Singleton{public: static Singleton&amp; getInstance() { static Singleton s; return s; }private: Singleton() {} Singleton(const Singleton&amp;); void operator=(const Singleton&amp;);}; 请记住: 为内置类型进行手工初始化，C++不保证初始化它们。 构造函数最好使用成员初值列，不要在构造函数中使用赋值操作，初值列中的成员变量的顺序应该和声明顺序一致。 为免除“跨编译单元之初始化次序”问题，使用返回local static对象引用的函数来代替non-local static对象。 reference[1] Effective C++ · Scott Meyers","link":"/2021/12/19/effective-cpp-2/"},{"title":"CPP - 函数默认参数","text":"c++规定默认参数必须从函数参数的右边向左边使用，如下： 正确： 12void fun1(int a, int b=10);void fun2(int a, int b=10, int c=20); 错误： 12void fun3(int a=5, int b, int c);void fun4(int a, int b=5, int c); 默认参数不能在声明和定义中同时出现 错误： 12void fun1(int a=10);void fun1(int a=10){......} 正确： 12345void fun2(int a=10);void fun2(int a){......}// orvoid fun2(int a);void fun2(int a=10){......}","link":"/2021/12/11/cpp-default-parameters/"},{"title":"CPP - 头文件","text":"1 头文件的布局： 2 #define 保护 所有头文件都应该有 #define 保护来防止头文件被多重包含, 命名格式当是: &lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_ 。 防御式开头防止重复include头文件。 1234#ifndef COMMON_H#define COMMON_H//.... code#endif //COMMON_H Google C++规范： 为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径。 例如, 项目 foo 中的头文件 foo/src/bar/baz.h 可按如下方式保护: 1234#ifndef FOO_BAR_BAZ_H_#define FOO_BAR_BAZ_H_...#endif // FOO_BAR_BAZ_H_ 也可以使用 1#pragma once 3 前置声明 尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。 前置声明（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义。 前置声明是为了降低编译依赖，防止修改一个头文件引发多米诺效应。 Google C++规范： 优点： 节省编译时间：多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。 节省不必要的重新编译的时间： #include 使代码因为头文件中无关的改动而被重新编译多次。 缺点： 前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。 前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。 极端情况下，用前置声明代替 #include 甚至都会暗暗地改变代码的含义： 123456789// b.h:struct B {};struct D : B {};// good_user.cc:#include &quot;b.h&quot;void f(B*);void f(void*);void test(D* x) { f(x); } // calls f(B*) ​ 如果 #include 被 B 和 D 的前置声明替代， test() 就会调用 f(void*) 结论： 尽量避免前置声明那些定义在其他项目中的实体. 函数：总是使用 #include. 类模板：优先使用 #include. 4 内联函数 只有当函数只有 10 行甚至更少时才将其定义为内联函数. 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用。 在类的声明中定义的函数将被编译器尝试翻译为内联函数。 优点: 只要内联的函数体较小, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联. 缺点: 滥用内联将导致程序变得更慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。 经验： 不要内联超过 10 行的函数 谨慎对待析构函数 内联包含循环或 switch 语句的函数往往得不偿失 一般不会被内联的函数：虚函数和递归函数不会被正常内联 5 #include 的路径及顺序 使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 .h, 本项目内的 .h. 项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 . (当前目录) 或 .. (上级目录).(即使用绝对路径而非相对路径) #include 的顺序： dir2/foo2.h (这个cpp文件对应的.h文件，放置于优先位置) C 系统文件 C++ 系统文件 其他库的 .h 文件 本项目内 .h 文件 这种优先的顺序排序保证 dir2/foo2.h（.h文件） 遗漏某些必要的库时， 其实现/测试（.cpp文件）的构建会立刻中止。这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是别人。","link":"/2021/10/26/cpp-header-file/"},{"title":"CPP面向对象 - 概述","text":"C vs C++C是面向过程的，C++是面向对象的，面向对象即是讲一些数据和函数绑定在一起。 对象(classes)的两种经典分类 Class without pointer members complex 拷贝都得一一复制（因为数据成员都包含在对象中了） Class with pointer members string 拷贝分深浅，因此有移动语义（C++11支持） C++程序代码的基本形式一般而言分 .cpp 或 .h 两种： .h ：写一些类的声明 .cpp ：类的实现 也不一定是 .cpp 或 .h 文件，也有可能是 .hpp 等文件。","link":"/2021/10/26/cpp-oop-intro/"},{"title":"CPP - 栈展开(stack unwinding)","text":"栈展开（stack unwinding）的定义抛出异常时，将暂停当前函数的执行，开始查找匹配的 catch 子句。首先检查 throw 本身是否在 try 块内部，如果是，检查与该 try 相关的 catch 子句，看是否可以处理该异常。如果不能处理，就退出当前函数，并且释放当前函数的内存并销毁局部对象，继续到上层的调用函数中查找，直到找到一个可以处理该异常的 catch 。这个过程称为栈展开（stack unwinding）。当处理该异常的 catch 结束之后，紧接着该 catch 之后的点继续执行。 为局部对象调用析构函数 在栈展开的过程中，会释放局部对象所占用的内存并运行类类型局部对象的析构函数。但需要注意的是，如果一个块通过 new 动态分配内存，并且在释放该资源之前发生异常，该块因异常而退出，那么在栈展开期间不会释放该资源，编译器不会删除该指针，这样就会造成内存泄露。 析构函数应该从不抛出异常 在为某个异常进行栈展开的时候，析构函数如果又抛出自己的未经处理的另一个异常，将会导致调用标准库 terminate 函数。通常 terminate 函数将调用 abort 函数，导致程序的非正常退出。所以析构函数应该从不抛出异常。 异常与构造函数 如果在构造函数对象时发生异常，此时该对象可能只是被部分构造，要保证能够适当的撤销这些已构造的成员。 未捕获的异常将会终止程序 不能不处理异常。如果找不到匹配的catch，程序就会调用库函数terminate。 例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;class MyException{};class Dummy {public: // 构造函数 Dummy(string s) : MyName(s) { PrintMsg(&quot;Created Dummy:&quot;); } // 拷贝构造 Dummy(const Dummy&amp; other) : MyName(other.MyName){ PrintMsg(&quot;Copy created Dummy:&quot;); } // 析构函数 ~Dummy(){ PrintMsg(&quot;Destroyed Dummy:&quot;); } void PrintMsg(string s) { cout &lt;&lt; s &lt;&lt; MyName &lt;&lt; endl; } string MyName; int level;};void C(Dummy d, int i) { cout &lt;&lt; &quot;Entering Function C&quot; &lt;&lt; endl; d.MyName = &quot; C&quot;; throw MyException(); cout &lt;&lt; &quot;Exiting Function C&quot; &lt;&lt; endl;}void B(Dummy d, int i) { cout &lt;&lt; &quot;Entering Function B&quot; &lt;&lt; endl; d.MyName = &quot; B&quot;; C(d, i + 1); cout &lt;&lt; &quot;Exiting Function B&quot; &lt;&lt; endl;}void A(Dummy d, int i) { cout &lt;&lt; &quot;Entering Function A&quot; &lt;&lt; endl; d.MyName = &quot; A&quot; ; // Dummy* pd = new Dummy(&quot;new Dummy&quot;); //Not exception safe!!! B(d, i + 1); // delete pd; cout &lt;&lt; &quot;Exiting FunctionA&quot; &lt;&lt; endl;}int main() { cout &lt;&lt; &quot;Entering main&quot; &lt;&lt; endl; try { Dummy d(&quot; M&quot;); A(d,1); } catch (MyException&amp; e) { cout &lt;&lt; &quot;Caught an exception of type: &quot; &lt;&lt; typeid(e).name() &lt;&lt; endl; } cout &lt;&lt; &quot;Exiting main.&quot; &lt;&lt; endl; return 0;}/**/ 进行编译，运行，可得到如下结果： 1234567891011121314151617$ g++ stack_unwinding.cpp -o stack_test -std=c++11$ ./stack_test Entering mainCreated Dummy: MCopy created Dummy: MEntering Function ACopy created Dummy: AEntering Function BCopy created Dummy: BEntering Function CDestroyed Dummy: CDestroyed Dummy: BDestroyed Dummy: ADestroyed Dummy: MCaught an exception of type: 11MyExceptionExiting main. 程序运行时对应栈的内容如下图所示： 程序执行将从 C 中的 throw 语句跳转到 main 中的 catch 语句，并在此过程中展开每个函数。 根据创建 Dummy 对象的顺序，在它们超出范围时将其销毁。 除了包含 catch 语句的 main 之外，其他函数均未完成。 函数 A 绝不会从其对 B() 的调用返回，并且 B 绝不会从其对 C() 的调用返回。 reference[1] microsoft C++文档 [2] 抛出异常与栈展开（stack unwinding）","link":"/2023/03/05/cpp-stack-unwinding/"},{"title":"CPP - 虚函数指针和虚函数表","text":"虚函数指针和虚函数表虚函数表的定义多态是由虚函数实现的，而虚函数主要是通过虚函数表（V-Table）来实现的。 如果一个类中包含虚函数（virtual修饰的函数），那么这个类就会包含一张虚函数表(vftbl)，虚函数表存储的每一项是一个虚函数的地址。在一个对象的内存布局中，指向这张虚函数表的指针（vfptr）位于最前端。如下图： 一般继承（无虚函数覆盖）对于如下UML的类：在普通继承情况，派生类没有重写基类的虚函数： 体现在代码上为： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;class Base{public: virtual void f() { cout &lt;&lt; &quot;Base:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base:h()&quot; &lt;&lt; endl; }};class Derive : public Base{public: virtual void f1() { cout &lt;&lt; &quot;Derive:f1()&quot; &lt;&lt; endl; } virtual void g1() { cout &lt;&lt; &quot;Derive:g1()&quot; &lt;&lt; endl; } virtual void h1() { cout &lt;&lt; &quot;Derive:h1()&quot; &lt;&lt; endl; }};int main() { Base base; Derive derive;} 使用lldb查看虚函数指针和虚函数表内容： 根据结果，可以得知其虚函数表如下图： 一般继承（有虚函数覆盖）对于如下UML的类：在普通继承情况，派生类重写了基类的虚函数( f() )： 代码为： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;class Base{public: virtual void f() { cout &lt;&lt; &quot;Base:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base:h()&quot; &lt;&lt; endl; }};class Derive : public Base{public: virtual void f() { cout &lt;&lt; &quot;Derive:f()&quot; &lt;&lt; endl; } virtual void g1() { cout &lt;&lt; &quot;Derive:g1()&quot; &lt;&lt; endl; } virtual void h1() { cout &lt;&lt; &quot;Derive:h1()&quot; &lt;&lt; endl; }};int main() { Base base; Derive derive;} 结果为： 绘制成图，为： 多重继承（无虚函数覆盖）对于如下UML的类：在多重继承情况，派生类没有重写了基类的虚函数： 代码为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;using namespace std;class Base1{public: virtual void f() { cout &lt;&lt; &quot;Base1:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base1:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base1:h()&quot; &lt;&lt; endl; }};class Base2{public: virtual void f() { cout &lt;&lt; &quot;Base2:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base2:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base2:h()&quot; &lt;&lt; endl; }};class Base3{public: virtual void f() { cout &lt;&lt; &quot;Base3:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base3:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base3:h()&quot; &lt;&lt; endl; }};class Derive : public Base1, public Base2, public Base3{public: virtual void f1() { cout &lt;&lt; &quot;Derive:f1()&quot; &lt;&lt; endl; } virtual void g1() { cout &lt;&lt; &quot;Derive:g1()&quot; &lt;&lt; endl; }};int main() { Derive derive;} 结果为： 绘制成图，为： 多重继承（有虚函数覆盖）对于如下UML的类：在多重继承情况，派生类没有重写了基类的虚函数： 代码为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;using namespace std;class Base1{public: virtual void f() { cout &lt;&lt; &quot;Base1:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base1:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base1:h()&quot; &lt;&lt; endl; }};class Base2{public: virtual void f() { cout &lt;&lt; &quot;Base2:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base2:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base2:h()&quot; &lt;&lt; endl; }};class Base3{public: virtual void f() { cout &lt;&lt; &quot;Base3:f()&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base3:g()&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base3:h()&quot; &lt;&lt; endl; }};class Derive : public Base1, public Base2, public Base3{public: virtual void f() { cout &lt;&lt; &quot;Derive:f()&quot; &lt;&lt; endl; } virtual void g1() { cout &lt;&lt; &quot;Derive:g1()&quot; &lt;&lt; endl; }};int main() { Derive derive;} 结果为： 绘制成图，为：","link":"/2023/03/05/cpp-virtual-function/"},{"title":"STL - 番外2 优先队列默认是大根堆？","text":"stl中默认堆为大根堆，大根堆的定义为： 1priority_queue&lt;int&gt; q; 根据源码中的定义，有如下代码： 123456789101112131415template &lt;class _Tp, class _Container = vector&lt;_Tp&gt;, class _Compare = less&lt;typename _Container::value_type&gt; &gt;class _LIBCPP_TEMPLATE_VIS priority_queue{public: typedef _Container container_type; typedef _Compare value_compare; typedef typename container_type::value_type value_type; typedef typename container_type::reference reference; typedef typename container_type::size_type size_type;protected: container_type c; value_compare comp;} 从最开头我们可以看出，声明优先队列时，第一参数为类型，第二参数为容器，第三参数为比较函数（默认小于）。 那么问题来了，为什么默认的这个cmp仿函数为小于的堆，是个大根堆（堆顶元素为最大值）？ 建堆时都是一步步push()的，查看源码，可以看到如下函数： 1234567891011// 类里边的声明void push(value_type&amp;&amp; __v);// push实现template &lt;class _Tp, class _Container, class _Compare&gt;inlinevoidpriority_queue&lt;_Tp, _Container, _Compare&gt;::push(value_type&amp;&amp; __v){ c.push_back(_VSTD::move(__v)); _VSTD::push_heap(c.begin(), c.end(), comp);} 从上述代码可以看出，优先队列的push操作就是往容器内push_back一个数，然后执行一个push_heap()操作。 查看push_heap()操作，可以看到如下代码： 12345678template &lt;class _RandomAccessIterator, class _Compare&gt;inline _LIBCPP_INLINE_VISIBILITYvoidpush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp){ typedef typename __comp_ref_type&lt;_Compare&gt;::type _Comp_ref; __sift_up&lt;_Comp_ref&gt;(__first, __last, __comp, __last - __first);} 其又掉用了__sift_up()函数，学过堆的小伙伴应该对这个up操作十分熟悉吧！ __sift_up()函数实现如下： 123456789101112131415161718192021222324252627282930313233343536template &lt;class _Compare, class _RandomAccessIterator&gt;void__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp, typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type __len){ typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type value_type; if (__len &gt; 1) { // ((__len - 1) -1) / 2; __len = (__len - 2) / 2; _RandomAccessIterator __ptr = __first + __len; if (__comp(*__ptr, *--__last)) { value_type __t(_VSTD::move(*__last)); do { *__last = _VSTD::move(*__ptr); __last = __ptr; if (__len == 0) break; __len = (__len - 1) / 2; __ptr = __first + __len; } while (__comp(*__ptr, __t)); *__last = _VSTD::move(__t); } }}template &lt;class _Tp&gt;inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPRtypename remove_reference&lt;_Tp&gt;::type&amp;&amp;move(_Tp&amp;&amp; __t) _NOEXCEPT{ typedef _LIBCPP_NODEBUG_TYPE typename remove_reference&lt;_Tp&gt;::type _Up; return static_cast&lt;_Up&amp;&amp;&gt;(__t);} 从__sift_up()函数的代码我们可以看出：这个cmp仿函数时一直传进来了的，而且是根据 __comp(*__ptr, __t)一直在执行某操作的。 这里就要涉及到heap的up操作了。 heap的up，简而言之，就是把元素和他的父亲节点（/2便是父亲节点，完全二叉树性质）比较，如果符合某性质，就将该节点上移。 以上源码类似于如下代码： 12345678910void sift-up ( MaxHeap H){ i = H-&gt;size; item = H-&gt;Element [i]; for ( ; H -&gt; Element [ i/2 ] &lt; item; i /= 2 ) // 与父结点做比较，i / 2 表示的就是父结点的下标 { H -&gt; Element [ i ] = H -&gt; Element [ i/2 ]; // 向下过滤结点 } H -&gt; Element [ i ] = item ; //若for循环完成后,i更新为父节点i，然后将 item 插入} 对于less的话，就是满足小于，则将节点上移，这样就形成了一个大根堆。 所以大小根堆可以以以下方式声明。 1234// 大根堆 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; q;// 小根堆 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;","link":"/2023/03/05/stl-priority-queue/"},{"title":"STL - deque源码分析","text":"deque概述deque是一种双向开口的“连续”线性空间（即可以在头尾两端分别做元素的插入和删除操作）。 deque与vector的差别： deque允许在常数时间内对头端进行元素的插入和删除操作，vector尾部插入和删除常数时间，头部操作O（n）时间 deque没有容量概念，不需要和vector一样进行老三样：申请新空间-&gt;复制元素-&gt;释放旧空间 deque的Ramdon Access Iterator进行过特殊设计，复杂度比vector高。 deque的中控器底层内存分布deque的“连续”空间只是在逻辑上连续的，实际上deque是由一段一段的定量连续空间构成。一旦有必要在deque的头端或尾端增加新空间，便配置一段定量的连续空间，串接在整个deque的头端或尾端。 deque的核心任务是维护 分段的定量连续空间整体连续的假象，并提供随机存取的接口，避免vector的申请新空间-&gt;复制元素-&gt;释放旧空间，但其代价是deque的迭代器架构较复杂。 中控器正如上面那张图看到的，对于分段的定量连续空间，我们需要一个map（就是一小段连续空间，和数组类似）来指示他（就像一个包租婆有很多房子，手里得有一个地图，找到他的每个房子） 1234567891011121314template &lt;class T, class Alloc = alloc, size_t BufSiz = 0&gt; class deque {public: // Basic types typedef T value_type; typedef value_type* pointer; typedef value_type&amp; reference; typedef size_t size_type; typedef ptrdiff_t difference_type;protected: // Internal typedefs typedef pointer* map_pointer;protected: map_pointer map;//指向指针数组 T** 类似于二维数组 T*指向一个缓冲区，T**就是这个map size_type map_size;//指针数组元素个数} deque的迭代器迭代器结构deque是分段连续空间，维护“整体连续”假象的任务就落在了operator++和operator–两个运算上了。 我们可以想象，一个iterator指向一个缓冲区（buffer）内元素时，当到了一个buffer的末端则需要跳到下一个buffer，到了buffer的头端则需要跳转到前一个buffer，这里则需要我们前面所说的map来调节。如何知道我们是否在buffer的头尾端呢？这就需要iterator保存这个buffer的begin和end了。 综上，deque的iterator需要以下元素： 指向当前元素的指针 指向当前buffer头端的指针 指向当前buffer尾端的指针 指向map中控的指针 SGI STL中源码如下： 123456789101112131415161718192021222324252627282930313233343536template &lt;class T, class Ref, class Ptr, size_t BufSiz&gt;struct __deque_iterator { // 未继承 std::iterator typedef __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator; typedef __deque_iterator&lt;T, const T&amp;, const T*, BufSiz&gt; const_iterator; static size_t buffer_size() {return __deque_buf_size(BufSiz, sizeof(T)); }#else /* __STL_NON_TYPE_TMPL_PARAM_BUG */template &lt;class T, class Ref, class Ptr&gt;struct __deque_iterator { // 未继承 std::iterator typedef __deque_iterator&lt;T, T&amp;, T*&gt; iterator; typedef __deque_iterator&lt;T, const T&amp;, const T*&gt; const_iterator; static size_t buffer_size() {return __deque_buf_size(0, sizeof(T)); }#endif // 未继承 std::iterator，所以必须自己写五个必要的迭代器相应型别 typedef random_access_iterator_tag iterator_category; // (1) typedef T value_type; // (2) typedef Ptr pointer; // (3) typedef Ref reference; // (4) typedef size_t size_type; typedef ptrdiff_t difference_type; // (5) typedef T** map_pointer; typedef __deque_iterator self; // 保持与容器的联结 T* cur; // 此迭代器所指之缓冲区中的现行（current）元素 T* first; // 此迭代器所指之缓冲区头 T* last; // 此迭代器所指之缓冲区尾（含备用空间） map_pointer node; __deque_iterator(T* x, map_pointer y) : cur(x), first(*y), last(*y + buffer_size()), node(y) {} __deque_iterator() : cur(0), first(0), last(0), node(0) {} __deque_iterator(const iterator&amp; x) : cur(x.cur), first(x.first), last(x.last), node(x.node) {}} 其中用来决定缓冲区大小的函数buffer_size()，调用__deque_buf_size() 123456789// 如果 n 不为 0，传回 n，表示 buffer size 由使用者自定。// 如果 n 为 0，表示buffer size 使用预设值，那么// 如果 sz（元素大小，sizeof(value_type)）小于 512，传回 512/sz，// 如果 sz 不小于 512，传回 1。inline size_t __deque_buf_size(size_t n, size_t sz){ return n != 0 ? n : (sz &lt; 512 ? size_t(512 / sz) : size_t(1));} 有了迭代器，缓存区，中控map，我们的deque的原型就出来啦： 迭代器操作迭代器到buffer边缘，则需要请求中控map，看怎么跳转buffer。 12345void set_node(map_pointer new_node) { node = new_node; first = *new_node; last = first + difference_type(buffer_size());} 解引用操作： 12reference operator*() const { return *cur; }pointer operator-&gt;() const { return &amp;(operator*()); } 计算两迭代器之间距离： 12345// 两个iterator相减，计算距离difference_type operator-(const self&amp; x) const { return difference_type(buffer_size()) * (node - x.node - 1) + (cur - first) + (x.last - x.cur);} 迭代器的++、–操作： 123456789101112131415161718192021222324252627282930// 参考 More Effective C++, item6: Distinguish between prefix and// postfix forms of increment and decrement operators.self&amp; operator++() { ++cur; // 切换至下一个元素。 if (cur == last) { // 如果已达所在缓冲区的尾端， set_node(node + 1); // 就切换至下一个节点（亦即缓冲区） cur = first; // 的第一个元素。 } return *this;}self operator++(int) { self tmp = *this; ++*this; return tmp;}self&amp; operator--() { if (cur == first) { // 如果已达所在缓冲区的头端， set_node(node - 1); // 就切换至前一个节点（亦即缓冲区） cur = last; // 的最后一个元素。 } --cur; // 切换至前一个元素。 return *this;}self operator--(int) { self tmp = *this; --*this; return tmp;} 迭代器+一个数值访问实现： 123456789101112131415161718192021222324252627282930313233343536// 參考 More Effective C++, item22: Consider using op= instead of// stand-alone op.self operator+(difference_type n) const { self tmp = *this; return tmp += n; // 调用operator+=}self&amp; operator+=(difference_type n) { difference_type offset = n + (cur - first); if (offset &gt;= 0 &amp;&amp; offset &lt; difference_type(buffer_size())) // 目标位置在同一缓冲区內 cur += n; else { // 目标位置不在同一缓冲区內 difference_type node_offset = offset &gt; 0 ? offset / difference_type(buffer_size()) : -difference_type((-offset - 1) / buffer_size()) - 1; // 切换至正确的节点（亦即缓冲区） set_node(node + node_offset); // 切换至正确的元素 cur = first + (offset - node_offset * difference_type(buffer_size())); } return *this;}// 參考 More Effective C++, item22: Consider using op= instead of // stand-alone op.self operator-(difference_type n) const { self tmp = *this; return tmp -= n; // 调用operator-=}self&amp; operator-=(difference_type n) { return *this += -n; }// 以上利用operator+= 来完成 operator-= 随机访问实现，模拟连续空间： 123//随机存取实现reference operator[](difference_type n) const { return *(*this + n); }// 以上调用operator*, operator+ 迭代器的比较操作： 12345bool operator==(const self&amp; x) const { return cur == x.cur; }bool operator!=(const self&amp; x) const { return !(*this == x); }bool operator&lt;(const self&amp; x) const { return (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node);} deque的数据结构deque除了维护一个map中控和map中控大小外，还维护了start、finish两个迭代器，分别指向第一个buffer的第一个元素和最后buffer的最后一个元素的下一个位置（左闭右开）。map中控大小的作用是：一旦节点不足，就得配置一块更大的map。 deque的数据结构如下： 1234567891011121314151617181920212223template &lt;class T, class Alloc = alloc, size_t BufSiz = 0&gt; class deque {public: // Basic types typedef T value_type; typedef value_type* pointer; typedef value_type&amp; reference; typedef size_t size_type; typedef ptrdiff_t difference_type;protected: // Internal typedefs typedef pointer* map_pointer; static size_type buffer_size() {//返回 return __deque_buf_size(BufSiz, sizeof(value_type)); } static size_type initial_map_size() { return 8; }protected: // Data members map_pointer map;//指向指针数组 size_type map_size;//指针数组元素个数 iterator start;//开始迭代器，其中cur指向头部元素 iterator finish;//结束迭代器，其中cur指向尾部元素后面的一个元素} deque的基本对外接口： 123456789101112131415161718192021222324252627282930public: // Basic accessorsiterator begin() { return start; }iterator end() { return finish; }const_iterator begin() const { return start; }const_iterator end() const { return finish; }reference operator[](size_type n) { return start[difference_type(n)]; // 调用 __deque_iterator&lt;&gt;::operator[]}const_reference operator[](size_type n) const { return start[difference_type(n)];}reference front() { return *start; } // 调用 __deque_iterator&lt;&gt;::operator*reference back() { iterator tmp = finish; --tmp; // 调用 __deque_iterator&lt;&gt;::operator-- return *tmp; // 调用 __deque_iterator&lt;&gt;::operator*}size_type size() const { return finish - start; }// 以上调用iterator::operator-size_type max_size() const { return size_type(-1); }bool empty() const { return finish == start; } deque的构造与内存管理deque的ctordeque自行定义了两个空间配置器： 12345protected: // Internal typedefs// 专属之空间配置器，每次配置一个元素大小typedef simple_alloc&lt;value_type, Alloc&gt; data_allocator;// 专属之空间配置器，每次配置一个指标大小typedef simple_alloc&lt;pointer, Alloc&gt; map_allocator; 并有如下构造函数： 12345deque(size_type n, const value_type&amp; value) : start(), finish(), map(0), map_size(0){ fill_initialize(n, value);} fill_initialize()负责产生并安排好deque的结构，并将元素的初值设置好： 123456789101112131415template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::fill_initialize(size_type n, const value_type&amp; value) { create_map_and_nodes(n); // 把deque的结构都产生并安排好 map_pointer cur; __STL_TRY { // 为每个节点的缓冲区設定初值 for (cur = start.node; cur &lt; finish.node; ++cur) uninitialized_fill(*cur, *cur + buffer_size(), value); // 最后一个节点的设定稍有不同（因为尾端可能有备用空间，不必设初值） uninitialized_fill(finish.first, finish.cur, value); } catch(...) { // &quot;commit or rollback&quot; ：若非全部成功，就一个不留。 } 其中create_map_and_nodes()复制产生并安排好deque的结构： 123456789101112131415161718192021222324252627282930313233343536template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::create_map_and_nodes(size_type num_elements) { // 需要节点数=(元素个数/每个缓冲区可容纳的元素个数)+1 // 如果刚好整除，會多配一个节点。 size_type num_nodes = num_elements / buffer_size() + 1; // 一个 map 要管理几个节点。最少8个，最多是 “所需节点数加2” // （前后各預留一个，扩充時可用）。 map_size = max(initial_map_size(), num_nodes + 2); map = map_allocator::allocate(map_size); // 以上配置出一个 “具有 map_size个节点” 的map。 // 以下令nstart和nfinish指向map所拥有之全部节点的最中央区段。 // 保持在最中央，可使头尾两端的扩充能量一样大。每个节点可对应一个缓冲区。 map_pointer nstart = map + (map_size - num_nodes) / 2; map_pointer nfinish = nstart + num_nodes - 1; map_pointer cur; __STL_TRY { // 为map內的每个現用节点配置缓冲区。所有缓冲区加起来就是deque的空间 // （最后一个缓冲区可能留有一些余裕）。 for (cur = nstart; cur &lt;= nfinish; ++cur) *cur = allocate_node(); } catch(...) { // &quot;commit or rollback&quot; ：若非全部成功，就一个不留。 } // 为deque内的两个迭代器start和end 設定正确的内容。 start.set_node(nstart); finish.set_node(nfinish); start.cur = start.first; // first, cur都是public finish.cur = finish.first + num_elements % buffer_size(); // 前面说过，如果刚好整除，会多配一个节点。 // 此时即令cur指向這多配的一個节点（所对应之缓冲区）的起点。} push_back() &amp; push_front()12345678910public: // push_* and pop_*void push_back(const value_type&amp; t) { if (finish.cur != finish.last - 1) { // 最后缓冲区尚有一个以上的备用空间 construct(finish.cur, t); // 直接在备用空间上建构元素 ++finish.cur; // 調整最后缓冲区的使用状态 } else // 最后缓冲区已无（或只剩一个）元素备用空间。 push_back_aux(t);} 尾端只有一个元素备用空间时，push_back调用push_back_aux()，先设置一整块的buffer，再设置新元素内容，然后更改finish： 1234567891011121314// 只有当 finish.cur == finish.last – 1 时才会被呼叫。// 也就是说只有当最后一个缓冲区只剩一个备用元素空間时才会被呼叫。template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::push_back_aux(const value_type&amp; t) { value_type t_copy = t; reserve_map_at_back(); // 若符合某种条件則必須重换一个map *(finish.node + 1) = allocate_node(); // 配置一个新节点（缓冲区） __STL_TRY { construct(finish.cur, t_copy); // 设值 finish.set_node(finish.node + 1); // 改变finish，令其指向新节点 finish.cur = finish.first; // 設定 finish 的状态 } __STL_UNWIND(deallocate_node(*(finish.node + 1)));} push_front()和push_back()同理： 123456789101112131415161718192021222324252627282930void push_front(const value_type&amp; t) { if (start.cur != start.first) { // 第一缓冲区尚有备用空間 construct(start.cur - 1, t); // 直接在备用空間上建构元素 --start.cur; // 调整第一缓冲区的使用状态 } else // 第一缓冲区已无备用空間 push_front_aux(t);}// 只有当start.cur == start.first時才会被呼叫。// 也就是说只有当第一个缓冲区沒有任何备用元素時才会被呼叫。template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::push_front_aux(const value_type&amp; t) { value_type t_copy = t; reserve_map_at_front(); // 若符合某种条件則必須重换一个map *(start.node - 1) = allocate_node(); // 配置一个新节点（缓冲区） __STL_TRY { start.set_node(start.node - 1); // 改变start，令其指向新节点 start.cur = start.last - 1; // 设定 start的状态 construct(start.cur, t_copy); // 设值 } catch(...) { // &quot;commit or rollback&quot; ：若非全部成功，就一个不留。 start.set_node(start.node + 1); start.cur = start.first; deallocate_node(*(start.node - 1)); throw; }} 其中，整治map的操作reserve_map_at_back()和reserve_map_at_front()为调用reallocate_map()： 12345678910111213void reserve_map_at_back (size_type nodes_to_add = 1) { if (nodes_to_add + 1 &gt; map_size - (finish.node - map)) // 如果 map 尾端的节点备用空间不足 // 符合以上条件則必須重换一个map（配置更大的，拷贝原來的，释放原來的） reallocate_map(nodes_to_add, false);}void reserve_map_at_front (size_type nodes_to_add = 1) { if (nodes_to_add &gt; start.node - map) // 如果 map 前端的节点备用空间不足 // 符合以上条件則必須重换一个map（配置更大的，拷贝原來的，释放原來的） reallocate_map(nodes_to_add, true);} reallocate_map()函数实现为： 12345678910111213141516171819202122232425262728293031323334template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::reallocate_map(size_type nodes_to_add, bool add_at_front) { size_type old_num_nodes = finish.node - start.node + 1; size_type new_num_nodes = old_num_nodes + nodes_to_add; map_pointer new_nstart; if (map_size &gt; 2 * new_num_nodes) { new_nstart = map + (map_size - new_num_nodes) / 2 + (add_at_front ? nodes_to_add : 0); if (new_nstart &lt; start.node) copy(start.node, finish.node + 1, new_nstart); else copy_backward(start.node, finish.node + 1, new_nstart + old_num_nodes); } else { size_type new_map_size = map_size + max(map_size, nodes_to_add) + 2; // 配置一块空間，准备给新map使用。 map_pointer new_map = map_allocator::allocate(new_map_size); new_nstart = new_map + (new_map_size - new_num_nodes) / 2 + (add_at_front ? nodes_to_add : 0); // 把原map 內容拷贝过来。 copy(start.node, finish.node + 1, new_nstart); // 释放原map map_allocator::deallocate(map, map_size); // 设定新map的起始位址与大小 map = new_map; map_size = new_map_size; } // 重新设定迭代器 start 和 finish start.set_node(new_nstart); finish.set_node(new_nstart + old_num_nodes - 1);} deque的元素操作pop_back() &amp; pop_front()pop操作和push操作相反，pop是要把元素拿掉，push需要考虑加入buffer，而pop则需要考虑释放buffer。 12345678910111213141516171819202122232425262728293031323334353637383940void pop_back() { if (finish.cur != finish.first) { // 最后缓冲区有一个（或更多）元素 --finish.cur; // 调整指标，相当于排除了最后元素 destroy(finish.cur); // 将最后元素析构 } else // 最后缓冲区没有任何元素 pop_back_aux(); // 這里将进行缓冲区的释放工作}// 只有当finish.cur == finish.first时才會被呼叫。template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::pop_back_aux() { deallocate_node(finish.first); // 释放最后一个缓冲区 finish.set_node(finish.node - 1); // 调整 finish 的状态，使指向 finish.cur = finish.last - 1; // 上一个缓冲区的最后一个元素 destroy(finish.cur); // 将该元素析构。}void pop_front() { if (start.cur != start.last - 1) { // 第一缓冲区有一个（或更多）元素 destroy(start.cur); // 将第一元素析构 ++start.cur; // 调整指标，相当于排除了第一元素 } else // 第一缓冲区僅有一个元素 pop_front_aux(); // 這里将进行缓冲区的释放工作}// 只有当start.cur == start.last - 1时才會被呼叫。template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::pop_front_aux() { destroy(start.cur); // 将第一缓冲区的第一个元素析构。 deallocate_node(start.first); // 释放第一缓冲区。 start.set_node(start.node + 1); // 调整 start 的状态，使指向 start.cur = start.first; // 下一个缓冲区的第一个元素。} clear()clear()用于清空deque，deque在初始的时候有一个buffer，因此clear之后，也应该有一个buffer。 1234567891011121314151617181920212223// 注意，最終需要保留一個緩衝區。這是deque 的策略，也是deque 的初始狀態。template &lt;class T, class Alloc, size_t BufSize&gt;void deque&lt;T, Alloc, BufSize&gt;::clear() { // 以下針對頭尾以外的每一個緩衝區（它們一定都是飽滿的） for (map_pointer node = start.node + 1; node &lt; finish.node; ++node) { // 將緩衝區內的所有元素解構。注意，呼叫的是destroy() 第二版本，見2.2.3節 destroy(*node, *node + buffer_size()); // 釋放緩衝區記憶體 data_allocator::deallocate(*node, buffer_size()); } if (start.node != finish.node) { // 至少有頭尾兩個緩衝區 destroy(start.cur, start.last); // 將頭緩衝區的目前所有元素解構 destroy(finish.first, finish.cur); // 將尾緩衝區的目前所有元素解構 // 以下釋放尾緩衝區。注意，頭緩衝區保留。 data_allocator::deallocate(finish.first, buffer_size()); } else // 只有一個緩衝區 destroy(start.cur, finish.cur); // 將此唯一緩衝區內的所有元素解構 // 注意，並不釋放緩衝區空間。這唯一的緩衝區將保留。 finish = start; // 調整狀態} erase()erase()函数可以清除一个iterator的内容，也可以清除一个范围的内容。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 清除 pos 所指的元素。pos 為清除點。iterator erase(iterator pos) { iterator next = pos; ++next; difference_type index = pos - start; // 清除點之前的元素個數 if (index &lt; (size() &gt;&gt; 1)) { // 如果清除點之前的元素比較少， copy_backward(start, pos, next); // 就搬移清除點之前的元素 pop_front(); // 搬移完畢，最前一個元素贅餘，去除之 } else { // 清除點之後的元素比較少， copy(next, finish, pos); // 就搬移清除點之後的元素 pop_back(); // 搬移完畢，最後一個元素贅餘，去除之 } return start + index;}template&lt;class T, class Alloc, size_t BufSize&gt;deque&lt;T, Alloc, BufSize&gt;::iterator deque&lt;T, Alloc, BufSize&gt;::erase(iterator first, iterator last) { if (first == start &amp;&amp; last == finish) { // 如果清除區間就是整個 deque clear(); // 直接呼叫 clear() 即可 return finish; } else { difference_type n = last - first; // 清除區間的長度 difference_type elems_before = first - start; // 清除區間前方的元素個數 if (elems_before &lt; (size() - n) / 2) { // 如果前方的元素比較少， copy_backward(start, first, last); // 向後搬移前方元素（覆蓋清除區間） iterator new_start = start + n; // 標記 deque 的新起點 destroy(start, new_start); // 搬移完畢，將贅餘的元素解構// 以下將贅餘的緩衝區釋放 for (map_pointer cur = start.node; cur &lt; new_start.node; ++cur) data_allocator::deallocate(*cur, buffer_size()); start = new_start; // 設定 deque 的新起點 } else { // 如果清除區間後方的元素比較少 copy(last, finish, first); // 向前搬移後方元素（覆蓋清除區間） iterator new_finish = finish - n; // 標記 deque 的新尾點 destroy(new_finish, finish); // 搬移完畢，將贅餘的元素解構// 以下將贅餘的緩衝區釋放 for (map_pointer cur = new_finish.node + 1; cur &lt;= finish.node; ++cur) data_allocator::deallocate(*cur, buffer_size()); finish = new_finish; // 設定 deque 的新尾點 } return start + elems_before; }} insert()insert()功能：在某一点之前插入一个元素，并设定其值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 在position 處安插一個元素，其值為 xiterator insert(iterator position, const value_type &amp;x) { if (position.cur == start.cur) { // 如果安插點是deque 最前端 push_front(x); // 交給push_front 去做 return start; } else if (position.cur == finish.cur) { // 如果安插點是deque 最尾端 push_back(x); // 交給push_back 去做 iterator tmp = finish; --tmp; return tmp; } else { return insert_aux(position, x); // 交給 insert_aux 去做 }}template&lt;class T, class Alloc, size_t BufSize&gt;typename deque&lt;T, Alloc, BufSize&gt;::iteratordeque&lt;T, Alloc, BufSize&gt;::insert_aux(iterator pos, const value_type &amp;x) { difference_type index = pos - start; // 安插點之前的元素個數 value_type x_copy = x; if (index &lt; size() / 2) { // 如果安插點之前的元素個數比較少 push_front(front()); // 在最前端加入與第一元素同值的元素。 iterator front1 = start; // 以下標示記號，然後進行元素搬移... ++front1; iterator front2 = front1; ++front2; pos = start + index; iterator pos1 = pos; ++pos1; copy(front2, pos1, front1); // 元素搬移 } else { // 安插點之後的元素個數比較少 push_back(back()); // 在最尾端加入與最後元素同值的元素。 iterator back1 = finish; // 以下標示記號，然後進行元素搬移... --back1; iterator back2 = back1; --back2; pos = start + index; copy_backward(pos, back2, back1); // 元素搬移 } *pos = x_copy; // 在安插點上設定新值 return pos;}","link":"/2023/03/05/stl-deque/"},{"title":"STL - array源码分析","text":"array底层就是一个定长数组，给定长数组加上迭代器相关的东西，就可以让他像一个容器，符合容器的性质。 12345678910111213141516171819202122232425262728293031323334#define _NOEXCEPT noexcepttemplate&lt;class _Tp, size_t _Size&gt;struct array { // types: typedef _Tp value_type; typedef value_type &amp;reference; typedef value_type *pointer; typedef value_type *iterator; typedef ptrdiff_t difference_type; typedef size_t size_type; _Tp __elems_[_Size]; const value_type *data() const _NOEXCEPT { return __elems_; } // iterators: iterator begin() _NOEXCEPT { return iterator(data()); } iterator end() _NOEXCEPT { return iterator(data() + _Size); } reference operator[](size_type __n) _NOEXCEPT { return __elems_[__n]; } reference at(size_type __n);}template&lt;class _Tp, size_t _Size&gt;typename array&lt;_Tp, _Size&gt;::referencearray&lt;_Tp, _Size&gt;::at(size_type __n) { if (__n &gt;= _Size) __throw_out_of_range(&quot;array::at&quot;); return __elems_[__n];} 偏特化版本：(对size为0情况进行处理) 123456789101112131415161718192021template&lt;class _Tp&gt;struct array&lt;_Tp, 0&gt; { // types: typedef _Tp value_type; typedef value_type &amp;reference; typedef value_type *iterator; typedef value_type *pointer; typedef ptrdiff_t difference_type; typedef size_t size_type; typedef typename conditional&lt;is_const&lt;_Tp&gt;::value, const char, char&gt;::type _CharType; struct _ArrayInStructT { _Tp __data_[1]; }; _ALIGNAS_TYPE(_ArrayInStructT) _CharType __elems_[sizeof(_ArrayInStructT)]; value_type *data() _NOEXCEPT { return reinterpret_cast&lt;value_type *&gt;(__elems_); }}","link":"/2023/03/05/stl-array/"},{"title":"STL - 番外1 什么？sizeof(list&lt;int&gt;)竟然是24","text":"之前写了这样一段代码， 1234printf(&quot;%d | %d \\n&quot;, sizeof(std::list&lt;int&gt;), sizeof(std::list&lt;long long&gt;));/*24 | 24 */ 首先我们需要知道list是个什么东东： 点进std::list，可以看到以下代码，可以看出list这玩意貌似没有成员？但他继承了一个 __list_imp&lt;_Tp, _Alloc&gt;： 123456template &lt;class _Tp, class _Alloc /*= allocator&lt;_Tp&gt;*/&gt;class _LIBCPP_TEMPLATE_VIS list : private __list_imp&lt;_Tp, _Alloc&gt;{ ...} 点进__list_imp可以看到这个代码，有一个__end_，我们离真相又近了一点了，__end_是__node_base类型的，可以看到前边有个typedef： 1234567891011template &lt;class _Tp, class _Alloc&gt;class __list_imp{protected: typedef _Tp value_type; typedef typename __alloc_traits::void_pointer __void_pointer; typedef __list_node_base&lt;value_type, __void_pointer&gt; __node_base; __node_base __end_; ...} 点进__list_node_base，看看这是个啥玩意。哦豁，发现了两个指针！ 12345678910struct __list_node_base{ typedef __list_node_pointer_traits&lt;_Tp, _VoidPtr&gt; _NodeTraits; typedef typename _NodeTraits::__node_pointer __node_pointer; typedef typename _NodeTraits::__base_pointer __base_pointer; typedef typename _NodeTraits::__link_pointer __link_pointer; __link_pointer __prev_; __link_pointer __next_;}; 注意，这是个父结构体，再看看他子结构体的实现，如下： 1234567891011121314template &lt;class _Tp, class _VoidPtr&gt;struct __list_node : public __list_node_base&lt;_Tp, _VoidPtr&gt;{ _Tp __value_; typedef __list_node_base&lt;_Tp, _VoidPtr&gt; __base; typedef typename __base::__link_pointer __link_pointer; _LIBCPP_INLINE_VISIBILITY __link_pointer __as_link() { return static_cast&lt;__link_pointer&gt;(__base::__self()); }}; 好啊，终于找到了list的数据成员了，两根指针，一个数据，类似于以下形式： 123456template&lt;class T&gt;struct test { T* prev; T* next; T t;} 但是回到正题，为什么std::list是24呢？ 我的机子是64位机，指针是8bytes，int是4个字节，8*2+4 = 20，没毛病，20。 但是输出为什么是24呢？ 遇到这种问题，我们一般就需要从编译器角度考虑了（首先可以肯定，这肯定不是我的问题！） 结构体对齐，嗯结构体对齐，这是编译器考虑的范畴。 内存对齐的作用： 字节对齐主要是为了提高内存的访问效率，比如intel 32位cpu，每个总线周期都是从偶地址开始读取32位的内存数据，如果数据存放地址不是从偶数开始，则可能出现需要两个总线周期才能读取到想要的数据，因此需要在内存中存放数据时进行对齐。 结论1：一般情况下，结构体所占的内存大小并非元素本身大小之和。 结论2：结构体内存大小应按最大元素大小对齐，如果最大元素大小超过模数，应按模数大小对齐。 这里的模数就需要编译器来操作啦！ 我们试试取消内存对齐试试： 12345678910111213141516171819#include &lt;list&gt;template&lt;class T&gt;struct test { T* prev; T* next; T t;}__attribute__((__packed__)) ;int main(){ printf(&quot;%d | %d \\n&quot;, sizeof(int), sizeof(long long)); printf(&quot;%d | %d \\n&quot;, sizeof(std::list&lt;int&gt;), sizeof(std::list&lt;long long&gt;)); printf(&quot;%d | %d \\n&quot;, sizeof(test&lt;int&gt;), sizeof(test&lt;long long&gt;));}/*4 | 8 24 | 24 20 | 24*/ 可以发现，test已经是20了，说明list为24的原因就是因为内存对齐所致。 内存对齐的相关知识可以参考：https://www.zhihu.com/question/27862634 详细的内存对齐内容，将在以后探讨….","link":"/2023/03/05/stl-memory-question/"},{"title":"STL - list源码分析","text":"list概述list底层为非连续区间，即链表（实质上是一个双向循环链表） list每次插入或者删除一个元素，就配置和释放一个元素空间，对于任何位置的原属插入或原属移除，list永远为常数时间。 list的节点首先要知道，list本身和list的节点是不同的，如果我们声明一个list，里面放了100W个元素，然后执行sizeof，会发现sizeof的结果并不是100W。这就是因为容器所管理的内存空间大小和容器本身的大小是不一样的。 又如下测试代码： 1234567#include &lt;list&gt;int main(){ std::list&lt;int&gt; test (100); printf(&quot;sizeof: %d | size: %d | sizeof(int *) : %d\\n&quot;, sizeof(test), test.size(), sizeof(int*)); // ans: sizeof: 24 | size: 100 | sizeof(int *) : 8} 我的电脑为64位机，指针大小为8，可以看出，对list进行sizeof操作，其为24，而不是100，这也就能映衬上文所说的“容器所管理的内存空间大小和容器本身的大小是不一样的”。那么这24个byte是什么呢？这就得慢慢分析源代码了。 list的节点（node）定义如下，由一个指向前一个节点的指针，指向后一个节点的指针，和数据三个部分构成： 1234567template &lt;class T&gt;struct __list_node { typedef void* void_pointer; void_pointer next; void_pointer prev; T data;}; list的迭代器list的底层节点不能保证其在内存中连续存在，因此list的迭代器是不可能实现随机访问的，只能靠next和prev两根指针的移动来进行操作。这样的迭代器是双向迭代器（bidirectional_iterator），即只能向前和向后移动。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152template&lt;class T, class Ref, class Ptr&gt;struct __list_iterator { // 定义相应型别 typedef __list_iterator&lt;T, T&amp;, T*&gt; iterator; typedef __list_iterator&lt;T, Ref, Ptr&gt; self; typedef bidirectional_iterator_tag iterator_category; typedef T value_type; typedef Ptr pointer; typedef Ref reference; typedef __list_node&lt;T&gt;* link_type; typedef size_t size_type; typedef ptrdiff_t difference_type; // 拥有一个指向对应结点的指针 link_type node; // 构造函数 __list_iterator() {} __list_iterator(link_type x) : node(x) {} __list_iterator(const iterator&amp; x) : node(x.node) {} // 重载了iterator必须的操作符 // 解引用，取数据 reference operator*() const { return (*node).data; } // 指针使用-&gt;访问数据成员 pointer operator-&gt;() const { return &amp;(operator*()); } // ++iter，iter通过next指向下一个元素 self&amp; operator++() { node = (link_type)((*node).next); return *this; } self operator++(int){ self tmp = *this; ++*this; return tmp; } // --iter，iter通过prev指向上一个元素 self&amp; operator--() { node = (link_type)((*node).prev); return *this; } self operator--(int){ self tmp = *this; --*this; return tmp; } bool operator==(const self&amp; x) const { return node == x.node; } bool operator!=(const self&amp; x) const { return node != x.node; }}; list有一个重要的性质：插入（insert）和接合（splice）操作不回造成原有的list迭代器失效，这在vector是不成立的。list的元素删除操作（erase）也只会让指向“被删除元素”的迭代器失效，其他迭代器不受影响。 list的数据结构list的底层数据结构就是一个双向循环链表，要表示这个双向循环链表十分的简单，就用一个节点（node）即可（这样可以说明为什么上面sizeof(list)=24了，一个指针8字节（64位机），prev、next2个指针和一个，这里有个坑，以后再补呜呜呜）。我们在数据结构中学过，一般链表有一个头节点，在list中也是一样的，只不过为了满足STL迭代器前闭后开这个特性，使得begin()为node-&gt;next，end()为node。可结合代码与图一起理解。 1234567891011121314151617181920template &lt;class T, class Alloc = alloc&gt;class list {protected: typedef void* void_pointer; typedef __list_node&lt;T&gt; list_node; typedef simple_alloc&lt;list_node, Alloc&gt; list_node_allocator;public: typedef T value_type; typedef value_type* pointer; typedef value_type&amp; reference; typedef list_node* link_type; typedef size_t size_type; typedef ptrdiff_t difference_type;public: // 定义迭代器类型 typedef __list_iterator&lt;T, T&amp;, T*&gt; iterator;protected: link_type node; // 空白结点 链表尾结点 // ...}; 根据上图，不难得出关于迭代器的几个操作如下： 1234567891011121314// node 指向尾节点的下一位置，因此 node 符合STL对 end 的定义。iterator begin() { return (link_type)((*node).next); }iterator end() { return node; } bool empty() const { return node-&gt;next == node; }size_type size() const { size_type result = 0; distance(begin(), end(), result); // 全局函数，求begin()和end()之间的距离，有对于bidirectional_iterator的特化版本 return result;}// 取头节点的内容reference front() { return *begin(); } // 取尾节点的内容reference back() { return *(--end()); } list的构造与析构直接上构造函数和析构函数吧，看代码就能说明问题！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354template &lt;class T, class Alloc = alloc&gt;class list {public: // 默认构造函数，产生一个空链表 list() { empty_initialize(); }protected: // 初始化 void empty_initialize() { node = get_node(); // 配置一個节点空间，令 node 指向它。 node-&gt;next = node; // 令node 头尾都指向自己，不设元素值。 node-&gt;prev = node; } // 析构函数 ~list() { clear(); // 清楚所有节点 put_node(node); // 把list里边的node释放掉 } // 实现在下面，清除所有节点 void clear(); // 为结点分配内存 link_type get_node() { return list_node_allocator::allocate(); } // 回收内存 void put_node(link_type p) { list_node_allocator::deallocate(p); } // 构造node link_type create_node(const T&amp; x) { link_type p = get_node(); construct(&amp;p-&gt;data, x); return p; } // 销毁node void destroy_node(link_type p) { destroy(&amp;p-&gt;data); put_node(p); }};// 清除所有节点template &lt;class T, class Alloc&gt; void list&lt;T, Alloc&gt;::clear(){ link_type cur = (link_type) node-&gt;next; // begin() while (cur != node) { // 访问每一个节点 link_type tmp = cur; cur = (link_type) cur-&gt;next; destroy_node(tmp); // 摧毁（析构并释放）一个节点 } // 恢复 node 原始状态 node-&gt;next = node; node-&gt;prev = node;} list的其他操作list成员函数的实现其实就是对环状双向链表的操作。 首先是insert、erase、transfer的实现，关于插入删除大部分都调用这三个函数，实际上就是改变结点pre跟next指针的指向。 123456789101112131415161718192021222324252627282930313233iterator insert(iterator position, const T&amp; x) { link_type tmp = create_node(x); // 改变四个指针的指向 实际就是双向链表元素的插入 tmp-&gt;next = position.node; tmp-&gt;prev = position.node-&gt;prev; (link_type(position.node-&gt;prev))-&gt;next = tmp; position.node-&gt;prev = tmp; return tmp;}iterator erase(iterator position) { // 改变四个指针的指向 实际就是双向链表的元素删除 link_type next_node = link_type(position.node-&gt;next); link_type prev_node = link_type(position.node-&gt;prev); prev_node-&gt;next = next_node; next_node-&gt;prev = prev_node; destroy_node(position.node); return iterator(next_node);}// 将[first, last)插入到position位置(可以是同一个链表)void transfer(iterator position, iterator first, iterator last) { if (position != last) { // 实际上也是改变双向链表结点指针的指向 具体操作看下图 (*(link_type((*last.node).prev))).next = position.node; (*(link_type((*first.node).prev))).next = last.node; (*(link_type((*position.node).prev))).next = first.node; link_type tmp = link_type((*position.node).prev); (*position.node).prev = (*last.node).prev; (*last.node).prev = (*first.node).prev; (*first.node).prev = tmp; }} list的对外接口： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091void push_front(const T&amp; x) { insert(begin(), x); }void push_back(const T&amp; x) { insert(end(), x); }void pop_front() { erase(begin()); }void pop_back() { iterator tmp = end(); erase(--tmp);}void swap(list&lt;T, Alloc&gt;&amp; x) { __STD::swap(node, x.node); }// splice有很多重载版本// 將 x 接合於 position 所指位置之前。x 必須不同於 *this。void splice(iterator position, list&amp; x) { if (!x.empty()) transfer(position, x.begin(), x.end());}// 將 i 所指元素接合於 position 所指位置之前。position 和i 可指向同一個list。void splice(iterator position, list&amp;, iterator i) { iterator j = i; ++j; if (position == i || position == j) return; transfer(position, i, j);}// 將 [first,last) 內的所有元素接合於 position 所指位置之前。// position 和[first,last)可指向同一個list，// 但position不能位於[first,last)之內。void splice(iterator position, list&amp;, iterator first, iterator last) { if (first != last) transfer(position, first, last);}// merge函数实现跟归并排序中合并的操作类似template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::merge(list&lt;T, Alloc&gt;&amp; x) { iterator first1 = begin(); iterator last1 = end(); iterator first2 = x.begin(); iterator last2 = x.end(); // 注意：前提是，两个list都递增排列 while (first1 != last1 &amp;&amp; first2 != last2) if (*first2 &lt; *first1) { iterator next = first2; transfer(first1, first2, ++next); first2 = next; } else ++first1; if (first2 != last2) transfer(last1, first2, last2);}// reserse函数每次都调用transfer将结点插入到begin()之前template &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::reverse() { if (node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) return; iterator first = begin(); ++first; while (first != end()) { iterator old = first; ++first; transfer(begin(), old, first); }}// list必须使用自己的sort()成员函数 因为STL算法中的sort()只接受RamdonAccessIterator// 该函数采用的是quick sorttemplate &lt;class T, class Alloc&gt;void list&lt;T, Alloc&gt;::sort() { // 空串和长度为1的 不用排序 if (node-&gt;next == node || link_type(node-&gt;next)-&gt;next == node) return; // 一些新的 lists，暂存 list&lt;T, Alloc&gt; carry; list&lt;T, Alloc&gt; counter[64]; int fill = 0; while (!empty()) { carry.splice(carry.begin(), *this, begin()); int i = 0; while(i &lt; fill &amp;&amp; !counter[i].empty()) { counter[i].merge(carry); carry.swap(counter[i++]); } carry.swap(counter[i]); if (i == fill) ++fill; } for (int i = 1; i &lt; fill; ++i) counter[i].merge(counter[i-1]); swap(counter[fill-1]);}","link":"/2023/03/05/stl-list/"},{"title":"STL - vector源码分析","text":"vector概述向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。 vector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率，即“配置新空间/数据移动/释放旧空间”的这个过程。 vector的主要定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// alloc 是SGI STL的空间配置器template&lt;class T,class Alloc=alloc&gt;class vector{ public: //vector的嵌套型别定义 typedef T value_type; typedef value_type* pointer; typedef value_type* iterator; typedef value_type* reference; typedef size_t size_type; typedef ptrdiff_t difference_type; protected: //simple_alloc 是SGI STL的空间配置器 typedef simple_alloc&lt;value_type,Alloc&gt; data_allocator; iterator start;//表示目前使用空间的头 iterator finish;//表示目前使用空间的尾 iterator end_of_storage;//表示目前可用空间的尾 void insert_aux(iterator position,const T&amp; x); void deallocate(){ if(start) data_allocator::deallocate(start,end_of_storage-start); } void fill_initialize(size_type n,const T&amp; value) { start=allocate_and_fill(n,value); finish=start+n; end_of_storage=finsih; } public: iterator begin(){return start;} iterator end(){return finish;} size_type size() const {return size_type(end()-begin());} size_type capacity() const {return size_type(end_of_storage-begin());} bool empty() const {return begin()==end();} reference operator[](size_type n) {return *(begin()+n);} vector():start(0),finish(0),end_of_storage(0){} vector(size_type n,const T&amp; value){fill_initialize(n,value);} vector(int n,const T&amp; value){fill_initialize(n,value);} vector(long n,const T&amp; value){fill_initialize(n,value);} explicit vector(size_type n){fill_initialize(n,T());} ~vector(){ destroy(start,finish); deallocate(); } reference front(){return *begin();}//第一个元素 reference back() {return *(end()-1);}//最后一个元素 void push_back(const T&amp; x){//将元素插入至最尾端 if(finish!=end_of_storage){ construct(finish,x); ++finish; } else insert_aux(end(),x); } void pop_back(){//将最尾端元素取出 --finish; destroy(finish);//全局函数 } iterator erase(iterator position){//清除某位置上的元素 if(position+1 !=end) { copy(position+1,finish,position);//后续元素往前移动 } --finish; destroy(finish); return position; } void resize(size_type new_size,const T&amp; x) { if(new_size&lt;size()) erase(begin()+new_size,end()); else insert(end(),new_size-size(),x); } void resize(size_type new_size){resize(new_size,T());} void clear() {erase(begin(),end());} protected: //配置空间并填满内容 iterator allocate_and_fill(size_type n,const T&amp; x) { iterator result=data_allocator::allocate(n); uninitialized_fill_n(result,n,x); return result; }}; 这么大一串代码看着头有点晕，那就上个图来表示吧： vector的迭代器vector维护的是一个连续的线性空间,由于是连续线性空间,所以其迭代器所要进行的一些操作比如:operator*,operator-&gt;,operator+,operator-,operator++,operator–等等普通的指针都可以满足所以vector的迭代器就是普通指针。通过普通指针也可让vector随机存取(所以vector的迭代器是Random Access Iterator). 迭代器的类型有5种： 123456输入迭代器input_iterator： 只读，且只能一次读操作，支持操作：++p,p++,!=,==,=*p,p-&gt;；输出迭代器output_iterator： 只写，且只能一次写操作，支持操作：++p,p++；正向迭代器forward_iterator： 可多次读写，支持输入输出迭代器的所有操作；双向迭代器bidirectional_iterator： 支持正向迭代器的所有操作，且支持操作：--p,--p；随机访问迭代器random_access_iterator： 除了支持双向迭代器操作外，还支持：p[n],p+n,n+p,p-n,p+=n,p-=n,p1-p2,p1&lt;p2,p1&gt;p2,p1&gt;=p2,p1&lt;=p2； vector源码中迭代器的定义如下： 123456template&lt;class T,class Alloc=alloc&gt;class vector{ public: typedef T value_type; typedef value_type* iterator;//vector的迭代器是普通指针}; 其实，iterator就是一个指针，即有以下代码。 12vector&lt;int&gt;::iterator ivite; // int*vector&lt;Shape&gt;::iterator svite; //Shape* vector的数据结构正如上面看到的，vector的数据结构如下代码，就是三根指针。vector所表示的是一片线形的连续空间，就相当于一个array，它以start和finish分别指向头和尾（左闭右开），表示连续区间内目前已经使用的范围，并以迭代器end_of_storage指向整块连续空间的尾端。 12345678template&lt;class T,class Alloc=alloc&gt;class vector{...protected: iterator start; iterator finish; iterator end_of_storage;}; 还是上面那张图：结合图像，我们可以看到，[start,finish)这块区域，就是已经放了元素的区域;而[finish,end_of_storage)这块区域则是没有放元素的备用空间。此时vector的大小是size，也就是finish-start，end_of_storage-start则是vector目前总共能放的元素个数。如果finish==end_of_storage，则说明现在这个vector是满了的，我们需要对其扩充空间。即：“配置新空间-&gt;数据移动-&gt;释放旧空间”这个动作，参考下图。 通过这三个迭代器,就可以实现很多操作,比如提供首尾标示,大小,容量,空容器判断,[ ]运算符,最前端元素,最后端元素等。 1234567891011121314template &lt;class T,class Alloc=alloc&gt;class vector{...public: iterator begin(){return start;} iterator end(){return finish;} size_type size() const {return size_type(end()-begin());} size_type capacity() const {return size_type(end_of_storage-begin());} bool empty() const {return begin()==end();} reference operator[](size_type n){return *(begin()+n);} reference front(){return *begin();} reference back() {return *(end()-1);}...}; vector的构造与析构vector提供了许多构造函数： 12345678910111213141516171819202122//默认构造函数vector():start(0),finish(0),end_of_storage(0){}//指定大小和初值vector(size_type n,const T&amp; value){fill_initialize(n,value);}vector(int n,const T&amp; value){fill_initialize(n,value);}vector(long n,const T&amp; value){fill_initialize(n,value);}explicit vector(size_type n){fill_initialize(n,T());} void fill_initialize(size_type n,const T&amp; value){ start=allocate_and_fill(n,value); finish=start+n; end_of_storage=finsih;}//配置空间并填满内容iterator allocate_and_fill(size_type n,const T&amp; x){ iterator result=data_allocator::allocate(n); uninitialized_fill_n(result,n,x); return result;} 对于指定大小和初值的构造方式，其是调用了fill_initialize()，fill_initialize()又调用了uninitialized_fill_n()，uninitialized_fill_n()会根据第一个参数的类别来判断是采用fill_n()还是反复调用construct()来完成vector的构造。 析构函数为：实现了调用析构函数和释放内存空间两个步骤。 1234~vector(){ destroy(start,finish); //全局函数，如果不是trival destructor，则一个个调用析构函数 deallocate(); // deallocate() is a member function of vector class} vector的扩容机制”配置新空间-&gt;数据移动-&gt;释放旧空间“这个动作一般发生于push_back()元素时，push_back()函数的作用为：将新元素插入到vector的尾端。该函数首先检查是否还有备用空间，如果有，则直接在备用空间上构造，并调整迭代器finish，使vector增大；如果没有备用空间了，则去扩充空间（配置新空间-&gt;数据移动-&gt;释放旧空间）。 push_back()的源码如下（此为GNU）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void push_back(const T&amp; x) { if (finish != end_of_storage) { //若当前还有备用空间 construct(finish, x); //将当前水位的值设为x ++finish; //提升水位 } else insert_aux(end(), x); }template &lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert_aux(iterator position, const T&amp; x) { if (finish != end_of_storage) { construct(finish, *(finish - 1)); ++finish; T x_copy = x; copy_backward(position, finish - 2, finish - 1); *position = x_copy; } else { const size_type old_size = size(); //获取之前数组的大小 //以上原则，如果原大小为0，则配置1（个元素） //如果原大小不为0，则配置原大小的两倍 //前半段用来放置原数据，后半段用来放置新数据 const size_type len = old_size != 0 ? 2 * old_size : 1; iterator new_start = data_allocator::allocate(len); //重新分配新数组的起始迭代器 iterator new_finish = new_start; __STL_TRY { new_finish = uninitialized_copy(start, position, new_start); //将旧数组的值重新分配给当前的新数组 construct(new_finish, x); //将当前数组的水位的值设为x ++new_finish; //提升新数组的水位 new_finish = uninitialized_copy(position, finish, new_finish); //这语句感觉可有可无，因为它根本就不会执行，position即last，而finish也是last } # ifdef __STL_USE_EXCEPTIONS catch(...) { //如果重新构造的新数组出现异常，则销毁当前新创建的数组，并释放内存空间 destroy(new_start, new_finish); data_allocator::deallocate(new_start, len); throw; }# endif /* __STL_USE_EXCEPTIONS */ destroy(begin(), end()); //将旧数组的空间释放掉 deallocate(); start = new_start; //new_start记录新数组的起始位置 finish = new_finish; //重新设置当前水位的指针 end_of_storage = new_start + len; //设置新数组的容量 }} 所谓动态增加大小，并不是在原空间之后接续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。 因此，对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了。 需要注意的是：不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。 vector的一些其他操作：pop_back,erase,clear,insert pop_back()源码:即finish回退一步，然后调用析构函数即可。 12345//将尾端元素拿掉，并调整大小void pop_back(){ --finish;//将尾端标记往前移动一格，表示将放弃尾端元素 destroy(finish);} erase()与clear()源码：要注意这里第一个erase的last并不会删除，制定first和last，删除的区间为[first,last)，因为stl的迭代器都是左闭右开的。 12345678910111213141516171819202122//清除[first,last)中的所有元素iterator erase(iterator first,iterator last){ //将[last,finish)前移动到[first,finish-(last-first)） iterator i=copy(last,finish,first); //析构之 destroy(i,finish); //调整水位 finish=finish-(last-first); return first;}//清除某位置上的元素iterator erase(iterator position){ if(position+1 !=end){ copy(position+1,finish,position);//后续元素往前移动 } --finish; destroy(finish); return position;}void clear() {erase(begin(),end());} erase()左闭右开测试程序，由此例可得出ed所指向内容不会被erase()，也可以这么想：如果传入end()为last，end()是不可以被析构的，所以last也不会被析构。 12345678910int main(){ vector&lt;int&gt; a = {0,1,2,3,4,5,6}; auto bg = ++a.begin(); // bg指向1 auto ed = --a.end(); --ed; // ed指向5 a.erase(bg,ed); for(auto &amp;i : a){ // ans : 0 5 6 cout &lt;&lt; i &lt;&lt; &quot; &quot;; }} insert()源码：和erase()类似，就是中间断开增加元素，需要拷贝很多值，效率较低。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//下面是vector::insert()实现内容//从position开始，插入n个元素，元素初值为xtemplate&lt;class T,class Alloc&gt;void vector&lt;T,Alloc&gt;::insert(iterator position,size_type n,const T&amp; x){ if(n!=0) { //当n！=0才进行以下操作 if(size_type(end_of_storage-finish)&gt;=n) { //备用空间大于等于“新增元素个数” T x_copy=x; //以下计算插入点之后的现有元素个数 const size_type elems_after=finish-position; iterator old_finish=finish; if(elems_after&gt;n) { //“插入点之后的现有元素个数”大于“新增元素个数” uninitialized_copy(finish-n,finish,finish); finish+=n;//将vector尾端标记后移 copy_backward(position,old_finish-n,old_finish); fill(position,position+n,x_copy);//从插入点开始填入新值 } else{ //“插入点之后的现有元素个数”小于等于“新增元素个数” uninitialized_fill_n(finish,n-eles_after,x_copy); finish+=n-elems_after; uninitialized_copy(position,old_finish,finish); finish+=elems_after; fill(position,old_finish,x_copy); } } else{ //备用空间小于“新增元素个数”（那就必须配置额外的内存） //首先决定新长度：旧长度的两倍，或旧长度+新增元素个数 const size_type old_size=size(); const size_type len=old_size+max(old_size,n); //配置新的vector空间 iterator new_start=data_allocator::allocate(n); iterator new_finish=new_start; __STL_TRY{ //以下首先将旧vector的插入点之前的元素复制到新空间 new_finish=uninitialized_copy(start,position,new_start); //以下再将新增元素（初值皆为n）填入新空间 new_finish=uninitialized_fill_n(new_finish,n,x); //以下再将旧vector的插入点之后的元素复制到新空间 new_finish=uninitialized_copy(position,finish,new_finish); } #ifdef __STL_USE_EXCEPTIONS catch(...){ //如有异常发生，实现“commit or rollback” semantics destroy(new_start,new_finish); data_allocator::deallocate(new_start,len); throw; } #endif /*__STL_USE_EXCEPTIONS*/ //以下清除并释放旧的vector destroy(start,finish); deallocate(); //以下调整水位标记 start=new_start; finish=new_finish; end_of_storage=new_start+len; } }} vector常见question： 为什么要成倍的扩容而不是一次增加一个固定大小的容量呢？ 可参考：https://www.drdobbs.com/c-made-easier-how-vectors-grow/184401375 1234567891011121314以成倍方式增长 假定有 n 个元素,倍增因子为 m；完成这 n 个元素往一个 vector 中的 push_back 操作，需要重新分配内存的次数大约为 logm(n)；第 i 次重新分配将会导致复制 m^(i) (也就是当前的vector.size() 大小)个旧空间中元素;n 次 push_back 操作所花费的时间复制度为O(n): m / (m - 1)，这是一个常量，均摊分析的方法可知，vector 中 push_back 操作的时间复杂度为常量时间.一次增加固定值大小 假定有 n 个元素,每次增加k个；第i次增加复制的数量为为：100in 次 push_back 操作所花费的时间复杂度为O(n^2): 均摊下来每次push_back 操作的时间复杂度为O(n)；总结：对比可以发现采用采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容 为什么是以两倍的方式扩容而不是三倍四倍，或者其他方式呢？ 可参考：https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md 其实VC的1.5倍扩容是更佳的。 It is well known that std::vector grows exponentially (at a constant factor) in order to avoid quadratic growth performance. The trick is choosing a good factor. Any factor greater than 1 ensures O(1) amortized append complexity towards infinity. But a factor that’s too small (say, 1.1) causes frequent vector reallocation, and one that’s too large (say, 3 or 4) forces the vector to consume much more memory than needed. The initial HP implementation by Stepanov used a growth factor of 2; i.e., whenever you’d push_back into a vector without there being room, it would double the current capacity. This was not a good choice: it can be mathematically proven that a growth factor of 2 is rigorously the worst possible because it never allows the vector to reuse any of its previously-allocated memory. Despite other compilers reducing the growth factor to 1.5, gcc has staunchly maintained its factor of 2. This makes std::vector cache- unfriendly and memory manager unfriendly. ​ 当使用2作为倍数增长时，每次扩展的尺寸的刚好大于之前所分配的总和。换而言之，之前分配的内存空间不可以被使用，对缓存不友好。 1.5倍增长和2倍增长对比： 3. vector与list的区别与应用？区别：应用：vector 拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在 乎插入和删除的效率，使用 vector。list 拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用 list。 resize和reserve区别？ 参考：https://www.cnblogs.com/cxl-/p/14482639.html vector？ vector是vector的一个特化版本，之前一个byte存一个bool，在vector的设计中一个byte存8个bool，用一个bit来表示true和false。 详细的以后再说。 参考文献： [1] https://blog.csdn.net/vjhghjghj/article/details/88713401 [2] https://blog.csdn.net/sinat_33442459/article/details/75142672 [3] https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md [4] https://www.drdobbs.com/c-made-easier-how-vectors-grow/184401375 [5] 侯捷.STL源码剖析[M].武汉：华中科技大学出版社，2002.6：115-128.","link":"/2023/03/05/stl-vector/"},{"title":"STL - 分配器 allocators","text":"1 C++ 内存配置操作和释放操作123class FOO{};FOO *pf = new FOO; delete pf; 对于上述代码，其在底层执行内容为： line 2：new操作，首先调用::operator new分配内存 （2）调用Foo::Foo() 构造对象内容; ::operator new底层调用malloc分配内存。 line 3：delete操作，首先调用Foo::~Foo()将对象析构 （2）调用::operator delete释放内存; ::operator delete底层调用free释放内存。 出于分工的考量，STL 的allocators决定将这两个阶段分开。分别用 4 个函数来实现： 内存的配置：alloc::allocate(); 对象的构造：::construct(); 对象的析构：::destroy(); 内存的释放：alloc::deallocate(); 2 construct()和destroy()construct()和destroy()主要负责对象的构造与析构。 construct()的源码为： 1234template &lt;class T1, class T2&gt;inline void construct(T1* p, const T2&amp; value) { new (p) T1(value); //用placement new在 p 所指的对象上创建一个对象，value是初始化对象的值。} destory()的源码为： 1234567891011121314151617181920212223242526272829template &lt;class T&gt;inline void destroy(T* pointer) { pointer-&gt;~T(); //只是做了一层包装，将指针所指的对象析构---通过直接调用类的析构函数}template &lt;class ForwardIterator&gt; //destory的泛化版，接受两个迭代器为参数inline void destroy(ForwardIterator first, ForwardIterator last) { __destroy(first, last, value_type(first)); //调用内置的 __destory(),value_type()萃取迭代器所指元素的型别}template &lt;class ForwardIterator, class T&gt;inline void __destroy(ForwardIterator first, ForwardIterator last, T*) { typedef typename __type_traits&lt;T&gt;::has_trivial_destructor trivial_destructor; __destroy_aux(first, last, trivial_destructor()); //trival_destructor()相当于用来判断迭代器所指型别是否有 trival destructor}template &lt;class ForwardIterator&gt;inline void //如果无 trival destructor ，那就要调用destroy()函数对两个迭代器之间的对象元素进行一个个析构__destroy_aux(ForwardIterator first, ForwardIterator last, __false_type) { for ( ; first &lt; last; ++first) destroy(&amp;*first);}template &lt;class ForwardIterator&gt; //如果有 trival destructor ，则什么也不用做。这更省时间inline void __destroy_aux(ForwardIterator, ForwardIterator, __true_type) {}inline void destroy(char*, char*) {} //针对 char * 的特化版inline void destroy(wchar_t*, wchar_t*) {} //针对 wchar_t*的特化版 construct()比较好理解，就是直接调用new操作。 destory()的话就比较复杂，主要在于其有很多的特化版本（泛化、特化、偏特化可以百度了解），主要有以下版本： 泛化版本 __destroy() （ForwardIterator, ForwardIterator）: 根据是否是trival destructor（无关痛痒的析构函数）来进行选择 1.1 特化版本（false）：__destroy_aux(ForwardIterator first, ForwardIterator last, __false_type)，即for循环一个个调用析构函数来析构。 1.2 特化版本（true）：__destroy_aux(ForwardIterator, ForwardIterator, __true_type) {}，无关痛痒，什么都不做 特化版本：（T *）对于传入一个对象的指针，直接调用析构函数 特化版本：（char *, char *）char*型，什么都不做 特化版本：（wchar_t *,wchar_t *）wchar_t *型，什么都不做 有这么多特化版本的原因还是因为trival destructor，对于trival destructor执行和不执行都一样，因此去执行那些trival destructor是很吃力不讨好的。 3 allocate()和deallocate()allocate()和deallocate()主要负责与内存分配与释放相关的动作。 在STL源码中，allocate转调用::operator new实现，deallocate转调用::operator delete实现。 调用链路可理解为： 调用allocate分配内存-&gt;调用::operator new分配内存-&gt;调用malloc分配内存 调用deallocate释放内存-&gt;调用::operator delete释放内存-&gt;调用free释放内存 SGI对空间的配置和释放的设计哲学为： 向 system heap 要求空间 考虑多线程状态 考虑内存不足时的应变措施 考虑过多“小型区块”可能造成的内存碎片问题。 考虑到小型区块会导致内存破碎问题，SGI STL设计了一个双层级配置器。 其代码如下： 123456# ifdef __USE_MALLOCtypedef __malloc_alloc_template&lt;0&gt; malloc_alloc;typedef malloc_alloc alloc; //使用第一级配置器# elsetypedef __default_alloc_template&lt;__NODE_ALLOCATOR_THREADS, 0&gt; alloc; // 使用第二级配置器# endif 因为SGI使用了双层级配置器，因此需要对外提供一个接口，从而符合标准： 12345678910111213template&lt;class T, class Alloc&gt;class simple_alloc {public: static T *allocate(size_t n) { return 0 == n? 0 : (T*) Alloc::allocate(n * sizeof (T)); } static T *allocate(void) { return (T*) Alloc::allocate(sizeof (T)); } static void deallocate(T *p, size_t n) { if (0 != n) Alloc::deallocate(p, n * sizeof (T)); } static void deallocate(T *p) { Alloc::deallocate(p, sizeof (T)); }}; 对于足够大和足够小的定义决定了应该使用哪一级配置器，对于SGI STL而言，小于等于128bytes视为足够小。当配置区块超过 128 bytes时，调用第一级配置器。当配置区块小于 128 bytes时，采取第二级配置器。 第一层配置器直接使用malloc()和free()。 第二层配置器则使用 memory pool 的方式。 3.1 第一级配置器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//以下是第一级配置器template &lt;int inst&gt;class __malloc_alloc_template {private://以下函数用来处理内存不足的情况static void *oom_malloc(size_t);static void *oom_realloc(void *, size_t);static void (* __malloc_alloc_oom_handler)();public:static void * allocate(size_t n){ void *result = malloc(n); //第一级配置器，直接使用malloc() //如果内存不足，则调用内存不足处理函数oom_alloc()来申请内存 if (0 == result) result = oom_malloc(n); return result;}static void deallocate(void *p, size_t /* n */){ free(p); //第一级配置器直接使用 free()}static void * reallocate(void *p, size_t /* old_sz */, size_t new_sz){ void * result = realloc(p, new_sz); //第一级配置器直接使用realloc() //当内存不足时，则调用内存不足处理函数oom_realloc()来申请内存 if (0 == result) result = oom_realloc(p, new_sz); return result;}//设置自定义的out-of-memory handle就像set_new_handle()函数static void (* set_malloc_handler(void (*f)()))(){ void (* old)() = __malloc_alloc_oom_handler; __malloc_alloc_oom_handler = f; return(old);}};template &lt;int inst&gt;void (* __malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)() = 0; //内存处理函数指针为空，等待客户端赋值template &lt;int inst&gt;void * __malloc_alloc_template&lt;inst&gt;::oom_malloc(size_t n){ void (* my_malloc_handler)(); void *result; for (;;) { //不断尝试释放、配置、再释放、再配置 my_malloc_handler = __malloc_alloc_oom_handler; //设定自己的oom(out of memory)处理函数 if (0 == my_malloc_handler) { __THROW_BAD_ALLOC; } //如果没有设定自己的oom处理函数，毫不客气的抛出异常 (*my_malloc_handler)(); //设定了就调用oom处理函数 result = malloc(n); //再次尝试申请 if (result) return(result); }}template &lt;int inst&gt;void * __malloc_alloc_template&lt;inst&gt;::oom_realloc(void *p, size_t n){ void (* my_malloc_handler)(); void *result; for (;;) { my_malloc_handler = __malloc_alloc_oom_handler; if (0 == my_malloc_handler) { __THROW_BAD_ALLOC; } //如果自己没有定义oom处理函数，则编译器毫不客气的抛出异常 (*my_malloc_handler)(); //执行自定义的oom处理函数 result = realloc(p, n); //重新分配空间 if (result) return(result); //如果分配到了，返回指向内存的指针 }} 上述代码的流程为： 通过allocate()申请内存，通过deallocate()来释放内存，通过reallocate()重新分配内存。 当allocate()或reallocate()分配内存不足时会调用oom_malloc()或oom_remalloc()来处理。 当oom_malloc() 或 oom_remalloc()还是没能分配到申请的内存时，会转入以下两步中的一步： 3.1 调用用户自定义的内存分配不足处理函数(这个函数通过set_malloc_handler() 来设定)，然后继续申请内存。 3.2 如果用户未定义内存分配不足处理函数，程序就会抛出bad_alloc异常或利用exit(1)终止程序。 3.2 第二级配置器在第二级配置器中，SGI 第二层配置器定义了一个 free-lists，这个free-list是一个数组，各自管理大小分别为8,16,24,32,40….128bytes的小额区块。 free-list节点结构为： 1234union obj{ union obj * free_list_link; char client_date[1]; }; 第二级配置器的部分实现源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192template &lt;bool threads, int inst&gt;class __default_alloc_template {private: // Really we should use static const int x = N // instead of enum { x = N }, but few compilers accept the former.# ifndef __SUNPRO_CC enum {__ALIGN = 8}; //小型区块上调边界 enum {__MAX_BYTES = 128}; // 小型区块的上界 enum {__NFREELISTS = __MAX_BYTES/__ALIGN}; // free-list的节点个数# endif // 将bytes上调至8的倍数 static size_t ROUND_UP(size_t bytes) { return (((bytes) + __ALIGN-1) &amp; ~(__ALIGN - 1)); }__PRIVATE: union obj { union obj * free_list_link; char client_data[1]; /* The client sees this. */ };private: //16个free-list static obj * __VOLATILE free_list[__NFREELISTS]; //根据大小计算该用哪个区块，32-&gt;3 static size_t FREELIST_INDEX(size_t bytes) { return (((bytes) + __ALIGN-1)/__ALIGN - 1); } // Returns an object of size n, and optionally adds to size n free list. static void *refill(size_t n); // Allocates a chunk for nobjs of size &quot;size&quot;. nobjs may be reduced // if it is inconvenient to allocate the requested number. static char *chunk_alloc(size_t size, int &amp;nobjs); // Chunk allocation state. static char *start_free; //内存池起始位置，只在chunk_alloc()中变化。 static char *end_free; //内存池结束位置，只在chunk_alloc()中变化。 static size_t heap_size;public: /* n must be &gt; 0 */ static void * allocate(size_t n) { obj * __VOLATILE * my_free_list; obj * __RESTRICT result; if (n &gt; (size_t) __MAX_BYTES) { return(malloc_alloc::allocate(n)); } my_free_list = free_list + FREELIST_INDEX(n); // Acquire the lock here with a constructor call. // This ensures that it is released in exit or during stack // unwinding.# ifndef _NOTHREADS /*REFERENCED*/ lock lock_instance;# endif result = *my_free_list; if (result == 0) { void *r = refill(ROUND_UP(n)); return r; } *my_free_list = result -&gt; free_list_link; return (result); }; /* p may not be 0 */ static void deallocate(void *p, size_t n) { obj *q = (obj *)p; obj * __VOLATILE * my_free_list; if (n &gt; (size_t) __MAX_BYTES) { malloc_alloc::deallocate(p, n); return; } my_free_list = free_list + FREELIST_INDEX(n); // acquire lock# ifndef _NOTHREADS /*REFERENCED*/ lock lock_instance;# endif /* _NOTHREADS */ q -&gt; free_list_link = *my_free_list; *my_free_list = q; // lock is released here } static void * reallocate(void *p, size_t old_sz, size_t new_sz);} ; 第二级配置器的结构： 3.2.1 allocate()allocate()的源码： 1234567891011121314151617181920static void * allocate(size_t n){ obj * __VOLATILE * my_free_list; obj * __RESTRICT result; //要申请的空间大于128bytes就调用第一级配置 if (n &gt; (size_t) __MAX_BYTES) { return(malloc_alloc::allocate(n)); } //寻找 16 个free lists中恰当的一个 my_free_list = free_list + FREELIST_INDEX(n); result = *my_free_list; if (result == 0) { //没找到可用的free list，准备新填充free list void *r = refill(ROUND_UP(n)); return r; } *my_free_list = result -&gt; free_list_link; return (result);}; ROUND_UP函数源码如下，其作用为：将要申请的内存字节数上调为8的倍数。 123static size_t ROUND_UP(size_t bytes) { return (((bytes) + __ALIGN-1) &amp; ~(__ALIGN - 1));} refill函数源码如下，其作用为：向内存池申请20块大小为n的一大块内存，将其挂在free-list上，并返回之。这个refill函数如allocate中所描述，就是在没找到可用的free-list时使用的，即我想要一块大小为32bytes的内存，然而发现没有了，此时就调用refill，去申请20个32bytes的内存以供使用。 12345678910111213141516171819202122232425262728293031/* Returns an object of size n, and optionally adds to size n free list.*//* We assume that n is properly aligned. *//* We hold the allocation lock. */template &lt;bool threads, int inst&gt;void* __default_alloc_template&lt;threads, inst&gt;::refill(size_t n){ int nobjs = 20; char * chunk = chunk_alloc(n, nobjs); obj * __VOLATILE * my_free_list; obj * result; obj * current_obj, * next_obj; int i; if (1 == nobjs) return(chunk); my_free_list = free_list + FREELIST_INDEX(n); /* Build free list in chunk */ result = (obj *)chunk; *my_free_list = next_obj = (obj *)(chunk + n); for (i = 1; ; i++) { current_obj = next_obj; next_obj = (obj *)((char *)next_obj + n); if (nobjs - 1 == i) { current_obj -&gt; free_list_link = 0; break; } else { current_obj -&gt; free_list_link = next_obj; } } return(result);} 3.2.2 deallocate()deallocate()的实现则较为简单，等同于一个链表插入操作，源码如下： 12345678910111213141516static void deallocate(void *p, size_t n){ obj *q = (obj *)p; obj * __VOLATILE * my_free_list; //如果要释放的字节数大于128，则调第一级配置器 if (n &gt; (size_t) __MAX_BYTES) { malloc_alloc::deallocate(p, n); return; } //寻找对应的位置 my_free_list = free_list + FREELIST_INDEX(n); //以下两步将待释放的块加到链表上 q -&gt; free_list_link = *my_free_list; *my_free_list = q;} 参考文献： [1] 侯捷.STL源码剖析[M].武汉：华中科技大学出版社，2002.6：43-69. [2] https://www.cnblogs.com/zhuwbox/p/3699977.html","link":"/2023/03/05/stl-allocators/"},{"title":"CPP - const限定符","text":"const修饰的变量，它的值不能被改变。只能执行不改变其内容的操作。const修饰的变量一样能进行算数运算等操作。 1const int bufSize = 512; 如果对其进行修改，则会引发错误。 1bufSize = 1024; //error const对象必须初始化 const修饰不具有传递性 1234567const int j = get_size(); //correctconst int j = 42; //correctconst int k; // errorint i = 1024;const int ci = i; //correctint j = ci; //correct 默认状态下，const对象仅在文件内有效 编译时，编译器将变量替换成对应的值（类似于define），因为const对象仅在文件内有效，如果要让其他文件访问到，需要添加extern关键字。 1234//file1.cc 定义并初始化一个常量，它可以被其他文件访问extern const int bufSize = fcn();//file1.h 头文件extern const int bufSize; // 与file1.cc的相同 对常量的引用（reference to const）：把引用绑定到const对象上。对常量的引用不可以修改它所绑定的对象。 1234const int ci =1024;const int &amp;r1 = ci; //correctr1 = 41; //errorint &amp;r2 = ci; //correct,r2非常量引用 对const的引用的初始化： 初始化常量引用可以用任何表达式作为初始值 1234int i = 42;const int &amp;r1 = i; //correctconst int &amp;r2 = r1*2; //correctint &amp;r3 = r1*2; //error，结合下文，error原因为绑定的为一个临时量对象， 解释： 假设有如下代码： 12double dval = 3.14;const int &amp;ri = dval; dval为双精度浮点数，为了确保让ri绑定上一个整数，编译器将上述代码变成如下形式： 12const int temp = dval; //由浮点数生产一个临时的整形变量const int &amp;ri = temp; ri绑定了一个临时量对象。这个临时量对象是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。 对const的引用可能引用一个并非const的对象 12345int i = 42;int &amp;r1 = i;const int &amp;r2 = i;r1 = 0; //correctr2 = 0; //error 指向常量的指针（pointer to const） 要想存放常量对象的地址，必须使用指向常量的指针。 1234const double pi = 3.14;double *ptr = &amp;pi; //errorconst double *cptr = &amp;pi; //correct*cptr = 1; //error 对象的值能不能改变，还得看自身是不是const，引用和指针的const是保证自己不去改变变量的值。 const指针：指针是一个对象，因此可以将指针定义为const。 常量指针（const pointer）必须初始化，一旦初始化完成，他的值（指向的地址）就不能改变。 *放const之前，说明指针是一个常量（另一层意思：指针本身的值不变，指向的值可以变） 12345int errNum = 0;int *const curErr = &amp;errNum; //curErr一直指向errNumconst double pi = 3.14;const double *const pop = &amp;pi; // pop是一个指向常量对象的常量指针//阅读方法：从右往左读 顶层const 顶层const：指针本身是个常量（靠近变量） 底层const：指针所指对象是一个常量","link":"/2023/03/05/cpp-const/"},{"title":"CPP - 操作符重载！看这篇就够了！","text":"实现一个操作符重载的方式通常有两种情况： 将操作符重载实现为类的成员函数。 操作符重载实现为非类的成员函数（即全局函数）。 将操作符重载实现为类的成员函数 在类体中声明（定义）需要重载的操作符，声明方式跟普通的成员函数一样，只不过操作符重载函数的名字是“关键字operator +以及紧跟其后的一个C++预定义的操作符”。参数则需要传入除自己以外的别的参数（比如==需要两个参数，即自身和另一个对象，因此传入另一个对象即可，自身就是this）。 形式即如下(Student为自定义类)： 1bool operator==(const Student &amp;student){} 此处要注意输入输出操作（&lt;&lt; and &gt;&gt;）的重载方式有所不同，需要使用友元函数，形式如下： 1friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Student &amp;student) 操作符重载实现为非类的成员函数 对于全局重载操作符，代表左操作数的参数必须被显式指定。 形式如下： 1bool operator&gt;(Student &amp;student, Student &amp;student1) 可以根据以下因素，确定把一个操作符重载为类的成员函数还是全局函数： 如果一个重载操作符是类成员，那么只有当与它一起使用的左操作数是该类的对象时，该操作符才会被调用；而如果该操作符的左操作数确定为其他的类型，则操作符必须被重载为全局函数； C++要求’=’、’[]’、’()’、’-&gt;’操作符必须被定义为类的成员操作符，把这些操作符通过全局函数进行重载时会出现编译错误 如果有一个操作数是类类型（如string类），那么对于对称操作符（比如==操作符），最好通过全局函数的方式进行重载。 实现操作符重载时，需要注意有如下限制： 重载后操作符的操作数至少有一个是用户定义类型； 不能违反原来操作数的语法规则； 不能创建新的操作符； 不能重载的操作符包括（以空格分隔）：sizeof . .* :: ?: RTTI类型运算符 =、()、[]、以及 -&gt;操作符只能被类的成员函数重载 下面给出示例代码，其中使用全局函数的为重载&gt;。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;using namespace std;class Student {public: int sno; string name; Student(int s = 0, string n = &quot;&quot;) : sno(s), name(n) {} bool operator==(const Student &amp;student) { if (sno == student.sno) return true; return false; } // 将操作符重载实现为类的成员函数 bool operator&lt;(const Student &amp;student) { if (sno &lt; student.sno) return true; return false; } // ++student 前缀形式 Student &amp;operator++() { sno++; return *this; } // student++ 后缀形式 Student operator++(int) { Student student(sno, name); sno++; return student; } friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Student &amp;student) { os &lt;&lt; student.sno &lt;&lt; &quot; &quot; &lt;&lt; student.name; return os; } friend istream &amp;operator&gt;&gt;(istream &amp;is, Student &amp;student) { cout &lt;&lt; &quot;input sno:&quot;; is &gt;&gt; student.sno; cout &lt;&lt; &quot;input name:&quot;; is &gt;&gt; student.name; return is; }};// 操作符重载实现为非类的成员函数bool operator&gt;(Student &amp;student, Student &amp;student1) { if (student.sno &gt; student1.sno) return true; return false;}int main() { Student student_a; cin &gt;&gt; student_a; cout &lt;&lt; &quot;your input: &quot; &lt;&lt; student_a &lt;&lt; endl; Student student_b = student_a++; cout &lt;&lt; &quot;student_a: &quot; &lt;&lt; student_a &lt;&lt; endl; cout &lt;&lt; &quot;student_b: &quot; &lt;&lt; student_b &lt;&lt; endl; cout &lt;&lt; &quot;student_a &lt; student_b: &quot; &lt;&lt; (student_a &lt; student_b) &lt;&lt; endl; cout &lt;&lt; &quot;student_a &gt; student_b: &quot; &lt;&lt; (student_a &gt; student_b) &lt;&lt; endl; cout &lt;&lt; &quot;student_a == student_b: &quot; &lt;&lt; (student_a == student_b) &lt;&lt; endl; cout &lt;&lt; endl; Student student_c = ++student_a; cout &lt;&lt; &quot;student_a: &quot; &lt;&lt; student_a &lt;&lt; endl; cout &lt;&lt; &quot;student_c: &quot; &lt;&lt; student_c &lt;&lt; endl; cout &lt;&lt; &quot;student_a &lt; student_c: &quot; &lt;&lt; (student_a &lt; student_c) &lt;&lt; endl; cout &lt;&lt; &quot;student_a &gt; student_c: &quot; &lt;&lt; (student_a &gt; student_c) &lt;&lt; endl; cout &lt;&lt; &quot;student_a == student_c: &quot; &lt;&lt; (student_a == student_c) &lt;&lt; endl;} 结果如下：","link":"/2023/03/05/cpp-operator-override/"},{"title":"CPP - 处理类型","text":"类型别名类型别名是一个名字，是某种类型的同义词。使用类型别名可以使复杂的类型名字变得简单明了。 12typedef double wages;typedef wages base, *p; //base=double,p=double* C++11中支持新方法： 1using wages = double; auto类型说明符C++11标准，编译器通过初始值推算变量的类型。（auto定义的变量必须具有初始值） 12auto i = 0, *p = &amp;i; //correctauto sz = 0, pi = 3.14; //error decltype类型指示符希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。 1decltype(f()) sum = x; //sum的类型就是函数f的返回类型","link":"/2023/03/05/cpp-type/"},{"title":"CPP - 引用&amp;指针","text":"引用 引用(reference)为对象起了另外一个名字，引用类型引用(refers to)另外一种类型。通过将声明符写成 &amp;d 的形式来定义引用类型型,其中 d 是声明的变量名。在初始化变量时，会出现初始值拷贝现象，定义引用则将引用与初始值对象绑定在一起。 引用必须初始化（类型必须严格匹配） 引用并不是对象，而是给一个已经存在的对象起另一个名字（这个对象必须存在，不可为字面值[10,”10”…]） 1234int &amp;refVal = 0; //errordouble dval = 3.14;int &amp;refVal2 = dval; //error 指针 指针(pointer)是’”指向(point to)“另外一种类型型的复合类型。定义指针类型的方法将声明符写成d的形式,其中d是变量名。 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。 指针无须在定义时赋初值。 使用取地址符（ &amp; ）可以取得存放某个对象的地址。 类型必须严格匹配 12double dval = 3.14;int *p = &amp;dval; 指针的值(即地址)应属下列4种状态之一: 指向一个对象。 指向紧邻对象所占空间的下一个位置。 空指针,意味着指针没有指向任何对象。 无效指针,也就是上述情况之外的其他值。 利用指针访问对象 如果指针指向了一个对象，则可以用解引用符（*）来访问该对象。 12345int ival = 42;int *p = &amp;ival; //声明指针*p = 0; //改变对象内容cout&lt;&lt; *p; //输出0 解引用符只适用于确指向了某个对象的有效指针 空指针 空指针不指向任何对象，在试图使用一个指针之前可以检查其是否为空。 123int *p1 = nullptr; //C++11int *p2 = 0;int *p3 = NULL; //cstdlib void* 指针 void *是一种特殊的指针类型，可用于存放任意对象的地址。存放的也仅仅就是一个地址。 12double obj = 3.14;void *pv = &amp;obj; 不能直接操作相关void *所指向的对象。 指向指针的指针 通过*的个数区分指针的级别。 123int ival = 1024;int *pi = &amp;ival; //指向intint **ppi = &amp;pi; //指向一个int指针 指向指针的引用 引用不是对象，指针是对象，因此不存在指向引用的指针，只存在指向指针的引用。 123456int i = 42;int *p;int *&amp;r = p; //对int指针的引用r = &amp;i; //r是一个int指针，即r指向i*r = 0; //解引用r得到i 如何理解r的类型是什么？ 从右往左阅读，越靠近r的对r有最直接影响（*&amp;r -&gt; &amp; -&gt; r为一个指针）","link":"/2023/03/05/cpp-reference-pointer/"},{"title":"STL - STL概述","text":"1 STL概述 容器 Containers：STL内部封装好的数据结构，一种class template，常用的包括vector、list、deque、set、map、multiset、multimap等 分配器 Allocators：负责空间配置与管理。是一个实现了动态空间配置、空间管理、空间释放的class template。一般SGI STL为每一个容器都指定其缺省的空间配置器为alloc（SGI配置器） 算法 Algorithms：一种function template，常用的有sort、search、copy、erase等 迭代器 Iterators：泛型指针，是一种智能指针，是一种将operator*，operator-&gt;，operator++，operator–等指针相关操作予以重载的class template。所有STL容器都附带自己的迭代器 适配器 Adapters：一种用来修饰容器(container)或仿函数(functor)或迭代器(iterator)接口的东西。如queue和stack。它们的底部完全借助deque，所有操作都由底层的deque供应。改变functor接口者，称为functor adapter，改变container接口者，称为container adapter；改变iterator接口者，称为iterator adapter。 仿函数 Functors：行为类似函数，就是使一个类的使用看上去象一个函数，具有可配接性。它的具体实现就是通过在类中重载了operator()，使这个类具有了类似函数的行为，就是一个仿函数类了。一般函数指针、回调函数可视为狭义的仿函数。分为算术运算、关系运算、逻辑运算三大类。这部分内建的仿函数，均放在头文件里，使用时需引入头文件。 给出如下示例，在例子中，对应上述六大组件有： 容器：vector 分配器：allocator 迭代器：begin(),end() 算法：count_if 适配器：not1,bind2nd 仿函数：less 123456789void test_all_components(){ int ia[7] = { 27, 210, 12, 47, 109, 83, 40 }; vector&lt;int,allocator&lt;int&gt;&gt; vi(ia,ia+7); cout &lt;&lt; count_if(vi.begin(), vi.end(), not1(bind2nd(less&lt;int&gt;(), 40)));//5 cout &lt;&lt; endl; }","link":"/2023/03/05/stl-intro/"},{"title":"STL - STL的编程范式","text":"2 STL的编程范式OOP(Object-Oriented Programming)：面向对象 数据和操作在同一个类;OOP企图将datas和methods关联在一起 12345template&lt;class T, class Alloc = alloc&gt;class list{ ... void sort();} GP(Generic Programming)：泛型编程 datas和methods分隔开，即algorithm和contains分隔开，通过iterator交互。 12template&lt;typename _RandomAccessIterator&gt;inline void sort(_RandomAccessIterator __first, _RandomAccessIterator __end) STL采用GP的原因： Containers和Algorithms团队刻个字闭门造车，Iterators团队沟通。 Algorithms通过Iterators确定操作范围，并通过Iterators取用Containers元素。 例子： 有算法（Algorithms）如下： 1234template&lt;class T&gt;inline const min T&amp;(const T&amp; a, const T&amp; b){ return b &lt; a ? b : a;} 如果要对一个自定义类进行大小比较，则可以重载**&lt;**，或者写个Compare函数。这样，算法就有了其通用性，而无需关心容器是什么。 泛化、特化、偏特化特化即特殊化，即设计者认为对于制定类型，使用特定版本更好。 全特化就是限定死模板实现的具体类型。 偏特化就是如果这个模板有多个类型，那么只限定其中的一部分。 优先级：全特化类&gt;偏特化类&gt;主版本模板类 123456789101112131415161718192021222324252627//泛化Template &lt;class type&gt; Struct __type_traits{typedef __true_type this_dummy_member_must_be_first; };//特化1Template &lt; &gt; Struct __type_traits&lt;int&gt;{typedef __true_type this_dummy_member_must_be_first; };//特化2Template &lt; &gt; Struct __type_traits&lt;double&gt;{typedef __true_type this_dummy_member_must_be_first; };//__type_traits&lt;FOO&gt;:: this_dummy_member_must_be_first; 使用的是泛化的内容//泛化Template &lt;class T, class Alloc = alloc&gt; Class vecor{};//偏特化(个数偏特化，第一个特化，第二个不特化)Template &lt;class Alloc&gt;Class vector&lt;bool, Alloc&gt;{};//泛化Template &lt;class Iterator&gt;Struct iterator_traits {};//偏特化1（范围偏特化，只能是传入指针）Template &lt;class T&gt;Struct iterator_traits&lt;T*&gt;{};//偏特化2Template &lt;class T&gt;Struct iterator_traits&lt;const T*&gt;{}; 为什么list不能使用::sort函数 list底层数据结构为链表，不支持随机访问（random access），所以list这个Containers中，有自带的sort方法。 ::sort接口为： 12345sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp){ typedef typename __comp_ref_type&lt;_Compare&gt;::type _Comp_ref; _VSTD::__sort&lt;_Comp_ref&gt;(__first, __last, _Comp_ref(__comp));} list.sort为，可以看到为链表的归并排序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162template &lt;class _Tp, class _Alloc&gt;template &lt;class _Comp&gt;typename list&lt;_Tp, _Alloc&gt;::iteratorlist&lt;_Tp, _Alloc&gt;::__sort(iterator __f1, iterator __e2, size_type __n, _Comp&amp; __comp){ switch (__n) { case 0: case 1: return __f1; case 2: if (__comp(*--__e2, *__f1)) { __link_pointer __f = __e2.__ptr_; base::__unlink_nodes(__f, __f); __link_nodes(__f1.__ptr_, __f, __f); return __e2; } return __f1; } size_type __n2 = __n / 2; iterator __e1 = _VSTD::next(__f1, __n2); iterator __r = __f1 = __sort(__f1, __e1, __n2, __comp); iterator __f2 = __e1 = __sort(__e1, __e2, __n - __n2, __comp); if (__comp(*__f2, *__f1)) { iterator __m2 = _VSTD::next(__f2); for (; __m2 != __e2 &amp;&amp; __comp(*__m2, *__f1); ++__m2) ; __link_pointer __f = __f2.__ptr_; __link_pointer __l = __m2.__ptr_-&gt;__prev_; __r = __f2; __e1 = __f2 = __m2; base::__unlink_nodes(__f, __l); __m2 = _VSTD::next(__f1); __link_nodes(__f1.__ptr_, __f, __l); __f1 = __m2; } else ++__f1; while (__f1 != __e1 &amp;&amp; __f2 != __e2) { if (__comp(*__f2, *__f1)) { iterator __m2 = _VSTD::next(__f2); for (; __m2 != __e2 &amp;&amp; __comp(*__m2, *__f1); ++__m2) ; __link_pointer __f = __f2.__ptr_; __link_pointer __l = __m2.__ptr_-&gt;__prev_; if (__e1 == __f2) __e1 = __m2; __f2 = __m2; base::__unlink_nodes(__f, __l); __m2 = _VSTD::next(__f1); __link_nodes(__f1.__ptr_, __f, __l); __f1 = __m2; } else ++__f1; } return __r;}","link":"/2023/03/05/stl-programming-style/"},{"title":"STL - 番外0 vector resize reserve比较","text":"vector resize reserve比较size：Returns the number of elements in the vector 目前存在的元素数。即： 元素个数 capacity：Return size of allocated storage capacity 容器能存储数据的个数。 即：容器容量 reserve原型： 1void reserve (size_type n); 作用： Request a change in capacity Requests that the vector capacity be at least enough to contain n elements. If n is greater than the current vector capacity, the function causes the container to reallocate its storage increasing its capacity to n (or greater). In all other cases, the function call does not cause a reallocation and the vector capacity is not affected. This function has no effect on the vector size and cannot alter its elements. resize原型： 12void resize (size_type n);void resize (size_type n, const value_type&amp; val); 作用： Change size Resizes the container so that it contains n elements. If n is smaller than the current container size, the content is reduced to its first n elements, removing those beyond (and destroying them). If n is greater than the current container size, the content is expanded by inserting at the end as many elements as needed to reach a size of n. If val is specified, the new elements are initialized as copies of val, otherwise, they are value-initialized. If n is also greater than the current container capacity, an automatic reallocation of the allocated storage space takes place. Notice that this function changes the actual content of the container by inserting or erasing elements from it. 通过以上说明我们可以得知： resize改变的是容器的大小（包括capacity和size），reserve则是改变的capacity，size没有改变。 reserve是容器预留空间，但在空间内不真正创建元素对象，所以在没有添加新的对象之前，不能引用容器内的元素。 resize了以后，容器中就有了相关的元素（对象），是可以引用容器内的元素的。 我们通过以下的一个测试函数，来探讨下我们为什么要使用reserve： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void growPushBack(vector&lt;int&gt; &amp;vec){ int size = 0, cap = 0; for(int i = 0; i &lt; 600; i++){ cap = vec.capacity(); size = vec.size(); if(cap == size){ cout &lt;&lt; endl; cout &lt;&lt; &quot;after push, capacity will mul 2&quot; &lt;&lt; endl; cout &lt;&lt; &quot;before: &quot; &lt;&lt; vec.capacity() &lt;&lt; &quot; address: &quot; &lt;&lt; &amp;*(vec.begin()) &lt;&lt; endl; } vec.push_back(i); if(cap == size){ cout &lt;&lt; &quot;after: &quot; &lt;&lt; vec.capacity() &lt;&lt; &quot; address: &quot; &lt;&lt; &amp;*(vec.begin()) &lt;&lt; endl; } }}int main(){ vector&lt;int&gt; vecIntA; //声明vector后未使用reserve，直接进行push_back操作 cout &lt;&lt; &quot;Making vecIntA growing:(empty opt)&quot; &lt;&lt; endl; cout &lt;&lt; &quot;size: &quot; &lt;&lt; vecIntA.size() &lt;&lt; endl; cout &lt;&lt; &quot;capacity: &quot; &lt;&lt; vecIntA.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;begin:&quot; &lt;&lt;&amp;*(vecIntA.begin()) &lt;&lt; endl; growPushBack(vecIntA); cout &lt;&lt; &quot;\\n\\n-----\\n\\n&quot; &lt;&lt; endl; vector&lt;int&gt; vecIntB; //声明vecIntB后用reserve来执行其容量为50 vecIntB.reserve(50); cout &lt;&lt; &quot;Making vecIntB growing:(reserve) &quot; &lt;&lt; endl; cout &lt;&lt; &quot;size: &quot; &lt;&lt; vecIntB.size() &lt;&lt; endl; cout &lt;&lt; &quot;capacity: &quot; &lt;&lt; vecIntB.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;begin:&quot; &lt;&lt;&amp;*(vecIntB.begin()) &lt;&lt; endl; growPushBack(vecIntB); cout &lt;&lt; &quot;\\n\\n-----\\n\\n&quot; &lt;&lt; endl; vector&lt;int&gt; vecIntC; //声明vecIntC后用resize来执行其容量为50 vecIntC.resize(50); cout &lt;&lt; &quot;Making vecIntC growing: (resize)&quot; &lt;&lt; endl; cout &lt;&lt; &quot;size: &quot; &lt;&lt; vecIntC.size() &lt;&lt; endl; cout &lt;&lt; &quot;capacity: &quot; &lt;&lt; vecIntC.capacity() &lt;&lt; endl; cout &lt;&lt; &quot;begin:&quot; &lt;&lt;&amp;*(vecIntC.begin()) &lt;&lt; endl; growPushBack(vecIntC); return 0;} 输出结果为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677Making vecIntA growing:(empty opt)size: 0capacity: 0begin:0x0after push, capacity will mul 2before: 0 address: 0x0after: 1 address: 0x7fb4a4604080after push, capacity will mul 2before: 1 address: 0x7fb4a4604080after: 2 address: 0x7fb4a4604090after push, capacity will mul 2before: 2 address: 0x7fb4a4604090after: 4 address: 0x7fb4a4604080after push, capacity will mul 2before: 4 address: 0x7fb4a4604080after: 8 address: 0x7fb4a46040a0after push, capacity will mul 2before: 8 address: 0x7fb4a46040a0after: 16 address: 0x7fb4a46040c0after push, capacity will mul 2before: 16 address: 0x7fb4a46040c0after: 32 address: 0x7fb4a4604100after push, capacity will mul 2before: 32 address: 0x7fb4a4604100after: 64 address: 0x7fb4a4604180after push, capacity will mul 2before: 64 address: 0x7fb4a4604180after: 128 address: 0x7fb4a4604280after push, capacity will mul 2before: 128 address: 0x7fb4a4604280after: 256 address: 0x7fb4a5808200-----Making vecIntB growing:(reserve) size: 0capacity: 50begin:0x7fb4a4604180after push, capacity will mul 2before: 50 address: 0x7fb4a4604180after: 100 address: 0x7fb4a4704080after push, capacity will mul 2before: 100 address: 0x7fb4a4704080after: 200 address: 0x7fb4a4704210-----Making vecIntC growing: (resize)size: 50capacity: 50begin:0x7fb4a4704080after push, capacity will mul 2before: 50 address: 0x7fb4a4704080after: 100 address: 0x7fb4a4704530after push, capacity will mul 2before: 100 address: 0x7fb4a4704530after: 200 address: 0x7fb4a47046c0Process finished with exit code 0 由运行结果可知，通过push_back操作，容器中的元素数量（size）一直在增加，当容器中的元素个数（size）达到了capacity值时，capacity是呈指数级增大的（2^n）（注意：此处不同编译器是不一样的，有的编译器是增加目前capacity的一半，即乘以1.5；有的是增加目前capacity，即乘以2），当发生扩容操作时，系统会发生以下操作： 开辟2*capacity的新空间 将原vector中的元素拷贝至新地址 释放原vector的capacity空间 根据输出容器的begin迭代器在内存中的地址，可以知道，容器是换了位置的（在内存中的位置发生了变化）。 为了支持快速的随机访问，vector容器的元素以连续方式存放，每一个元素都紧挨着前一个元素存储。设想一下，当vector添加一个元素时，为了满足连续存放这个特性，都需要重新分配空间、拷贝元素、撤销旧空间，这样性能难以接受。因此STL实现者在对vector进行内存分配时，其实际分配的容量要比当前所需的空间多一些。就是说，vector容器预留了一些额外的存储区，用于存放新添加的元素，这样就不必为每个新元素重新分配整个容器的内存空间。 push_back的具体实现： 当数组中增加一个元素x的时候，先判断是否还有备用空间；如果还有备用空间，则将当前指针的值设为x，并将当前的指针加1；若备用空间已经用完，如果之前的空间为0，则重新分配大小为1的空间，否则将空间扩容为之前的两倍，然后将旧容器中的值重新拷贝到新空间中，并重新分配起始指针和当前指针。所以使用vector需要注意的一点就是尽量不要动态给它分配空间。而且空间重新分配之后，之前的所有指针都会失效（特别要注意）。两倍扩容的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243void push_back(const T&amp; x) { if (finish != end_of_storage) { //若当前还有备用空间 construct(finish, x); //将当前水位的值设为x ++finish; //提升水位 } else insert_aux(end(), x); }template &lt;class T, class Alloc&gt;void vector&lt;T, Alloc&gt;::insert_aux(iterator position, const T&amp; x) { if (finish != end_of_storage) { construct(finish, *(finish - 1)); ++finish; T x_copy = x; copy_backward(position, finish - 2, finish - 1); *position = x_copy; } else { const size_type old_size = size(); //获取之前数组的大小 const size_type len = old_size != 0 ? 2 * old_size : 1; //将当前数组的容量扩大为原来的两倍 iterator new_start = data_allocator::allocate(len); //重新分配新数组的起始迭代器 iterator new_finish = new_start; __STL_TRY { new_finish = uninitialized_copy(start, position, new_start); //将旧数组的值重新分配给当前的新数组 construct(new_finish, x); //将当前数组的水位的值设为x ++new_finish; //提升新数组的水位 new_finish = uninitialized_copy(position, finish, new_finish); //这语句感觉可有可无，因为它根本就不会执行，position即last，而finish也是last } # ifdef __STL_USE_EXCEPTIONS catch(...) { //如果重新构造的新数组出现异常，则销毁当前新创建的数组，并释放内存空间 destroy(new_start, new_finish); data_allocator::deallocate(new_start, len); throw; }# endif /* __STL_USE_EXCEPTIONS */ destroy(begin(), end()); //将旧数组的空间释放掉 deallocate(); start = new_start; //new_start记录新数组的起始位置 finish = new_finish; //重新设置当前水位的指针 end_of_storage = new_start + len; //设置新数组的容量 }} 综上，出于性能的考虑，我们在提前可以知道vector size的情况下，可以提前resize或reserve，这样可以减少扩容时拷贝所付出的时间。","link":"/2023/03/05/stl-resize-or-reserve/"},{"title":"CPP - memset与for循环赋初值比较","text":"写代码的时候思考了一会儿memset初始化快还是for循环初始化快。看了大量的文献资料，结论如下： 如果对于一个数组进行赋初值操作，memset肯定比for循环快memset赋初值是按字节为单位的，如果要赋一些比较难的值（33，22等），就比较难接上，因为memset是按字节为单位赋初值，当变量所占字节数越大，速度越慢（int的数组比char慢）测试代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;chrono&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;numeric&gt;using namespace std;using namespace std::chrono;const int MAXROWNUM = 5e3;const int MAXCOLNUM = 5e3;const int loopTimes = 10;const int loop = 10;int arr[MAXROWNUM][MAXCOLNUM];int arr0[MAXROWNUM][MAXCOLNUM];int arr1[MAXROWNUM][MAXCOLNUM];int arr2[MAXROWNUM][MAXCOLNUM];int arr3[MAXROWNUM][MAXCOLNUM];int arr4[MAXROWNUM][MAXCOLNUM];int arr5[MAXROWNUM][MAXCOLNUM];int arr6[MAXROWNUM][MAXCOLNUM];int arr7[MAXROWNUM][MAXCOLNUM];int arr8[MAXROWNUM][MAXCOLNUM];int arr9[MAXROWNUM][MAXCOLNUM];char str0[MAXROWNUM][MAXCOLNUM];char str1[MAXROWNUM][MAXCOLNUM];char str2[MAXROWNUM][MAXCOLNUM];char str3[MAXROWNUM][MAXCOLNUM];char str4[MAXROWNUM][MAXCOLNUM];char str5[MAXROWNUM][MAXCOLNUM];char str6[MAXROWNUM][MAXCOLNUM];char str7[MAXROWNUM][MAXCOLNUM];char str8[MAXROWNUM][MAXCOLNUM];char str9[MAXROWNUM][MAXCOLNUM];char str[MAXROWNUM][MAXCOLNUM];long long memsetfunc_i(){ auto start = system_clock::now(); int len =MAXROWNUM*MAXCOLNUM*sizeof(int); memset(arr,0, len); auto end = system_clock::now(); auto tt = duration_cast&lt;microseconds&gt;(end - start);// printf(&quot;memset cost %.3f us\\n&quot;,tt.count()); return tt.count();}long long memsettenfunc_i(){ auto start = system_clock::now(); int len =MAXROWNUM*MAXCOLNUM*sizeof(int); for (int i = 0; i &lt; loopTimes; ++i) { memset(arr,0, len); } auto end = system_clock::now(); auto tt = duration_cast&lt;microseconds&gt;(end - start); return tt.count();}long long forfunc_i(){ auto start1 = system_clock::now(); for (int i = 0; i &lt; MAXROWNUM; ++i) { for (int j = 0; j &lt; MAXCOLNUM; ++j) { arr[i][j] = 0; } } auto end1 = system_clock::now(); auto tt1 = duration_cast&lt;microseconds&gt;(end1 - start1); return tt1.count();}long long fortenfunc_i(){ auto start1 = system_clock::now(); for (int k = 0; k &lt; loopTimes; ++k) { for (int i = 0; i &lt; MAXROWNUM; ++i) { for (int j = 0; j &lt; MAXCOLNUM; ++j) { arr[i][j] = 0; } } } auto end1 = system_clock::now(); auto tt1 = duration_cast&lt;microseconds&gt;(end1 - start1); return tt1.count();}long long memsetfunc_c(){ auto start = system_clock::now(); int len =MAXROWNUM*MAXCOLNUM*sizeof(char); memset(str,'0', len); auto end = system_clock::now(); auto tt = duration_cast&lt;microseconds&gt;(end - start);// printf(&quot;memset cost %.3f us\\n&quot;,tt.count()); return tt.count();}long long memsettenfunc_c(){ auto start = system_clock::now(); int len =MAXROWNUM*MAXCOLNUM*sizeof(char); for (int i = 0; i &lt; loopTimes; ++i) { memset(str,'0', len); } auto end = system_clock::now(); auto tt = duration_cast&lt;microseconds&gt;(end - start); return tt.count();}long long forfunc_c(){ auto start1 = system_clock::now(); for (int i = 0; i &lt; MAXROWNUM; ++i) { for (int j = 0; j &lt; MAXCOLNUM; ++j) { str[i][j] = '0'; } } auto end1 = system_clock::now(); auto tt1 = duration_cast&lt;microseconds&gt;(end1 - start1); return tt1.count();}long long fortenfunc_c(){ auto start1 = system_clock::now(); for (int k = 0; k &lt; loopTimes; ++k) { for (int i = 0; i &lt; MAXROWNUM; ++i) { for (int j = 0; j &lt; MAXCOLNUM; ++j) { str[i][j] = '0'; } } } auto end1 = system_clock::now(); auto tt1 = duration_cast&lt;microseconds&gt;(end1 - start1); return tt1.count();}long long memsettendifffunc_c(){ auto start = system_clock::now(); int len =MAXROWNUM*MAXCOLNUM*sizeof(char); memset(str0,'0', len); memset(str1,'0', len); memset(str2,'0', len); memset(str3,'0', len); memset(str4,'0', len); memset(str5,'0', len); memset(str6,'0', len); memset(str7,'0', len); memset(str8,'0', len); memset(str9,'0', len); auto end = system_clock::now(); auto tt = duration_cast&lt;microseconds&gt;(end - start); return tt.count();}long long fortendifffunc_c(){ auto start1 = system_clock::now(); for (int i = 0; i &lt; MAXROWNUM; ++i) { for (int j = 0; j &lt; MAXCOLNUM; ++j) { str0[i][j] = '0'; str1[i][j] = '0'; str2[i][j] = '0'; str3[i][j] = '0'; str4[i][j] = '0'; str5[i][j] = '0'; str6[i][j] = '0'; str7[i][j] = '0'; str8[i][j] = '0'; str9[i][j] = '0'; } } auto end1 = system_clock::now(); auto tt1 = duration_cast&lt;microseconds&gt;(end1 - start1); return tt1.count();}long long memsettendifffunc(){ auto start = system_clock::now(); int len =MAXROWNUM*MAXCOLNUM*sizeof(char); memset(arr0,0, len); memset(arr1,0, len); memset(arr2,0, len); memset(arr3,0, len); memset(arr4,0, len); memset(arr5,0, len); memset(arr6,0, len); memset(arr7,0, len); memset(arr8,0, len); memset(arr9,0, len); auto end = system_clock::now(); auto tt = duration_cast&lt;microseconds&gt;(end - start); return tt.count();}long long fortendifffunc(){ auto start1 = system_clock::now(); for (int i = 0; i &lt; MAXROWNUM; ++i) { for (int j = 0; j &lt; MAXCOLNUM; ++j) { arr0[i][j] = 0; arr1[i][j] = 0; arr2[i][j] = 0; arr3[i][j] = 0; arr4[i][j] = 0; arr5[i][j] = 0; arr6[i][j] = 0; arr7[i][j] = 0; arr8[i][j] = 0; arr9[i][j] = 0; } } auto end1 = system_clock::now(); auto tt1 = duration_cast&lt;microseconds&gt;(end1 - start1); return tt1.count();}vector&lt;long long&gt; ans;double getAns(long long(*p)()){ ans.clear(); for (int i = 0; i &lt; loop; ++i) { ans.push_back((*p)()); } sort(ans.begin(),ans.end()); double cost = accumulate(ans.begin()+2, ans.end()-2, 0.0) / static_cast&lt;double&gt;(ans.size()-6); cost = cost/1000; return cost;}int main() { double m1,m10,f1,f10,cm1,cm10,cf1,cf10,cmd10,cfd10,md10,fd10; m1 = getAns(memsetfunc_i); m10 = getAns(memsettenfunc_i); f1 = getAns(forfunc_i); f10 = getAns(fortenfunc_i); cm1 = getAns(memsetfunc_c); cm10 = getAns(memsettenfunc_c); cf1 = getAns(forfunc_c); cf10 = getAns(fortenfunc_c); cmd10 = getAns(memsettendifffunc_c); cfd10 = getAns(fortendifffunc_c); md10 = getAns(memsettendifffunc); fd10 = getAns(fortendifffunc); printf(&quot;int数组memset一次耗时:%.3fms\\tint数组for循环一次耗时:%.3fms\\n&quot;,m1,f1); printf(&quot;int数组memset十次耗时:%.3fms\\tint数组for循环十次耗时:%.3fms\\n&quot;,m10,f10); printf(&quot;不同的十个int数组memset耗时:%.3fms\\t不同的十个int数组for循环耗时:%.3fms\\n&quot;,md10,fd10); printf(&quot;\\n&quot;); printf(&quot;char数组memset一次耗时:%.3fms\\tchar数组for循环一次耗时:%.3fms\\n&quot;,cm1,cf1); printf(&quot;char数组memset十次耗时:%.3fms\\tchar数组for循环十次耗时:%.3fms\\n&quot;,cm10,cf10); printf(&quot;不同的十个char数组memset耗时:%.3fms\\t不同的十个char数组for循环耗时:%.3fms\\n&quot;,cmd10,cfd10);} 数组都开在的栈区，因此数组不能设的太大。。。运行结果如下：可以佐证上诉的结论。运行结果 memset具体的实现可以看一下下面这个博客，写的很仔细：https://www.cnblogs.com/hoodlum1980/p/3505802.html。 以大佬的总结作为我的总结： 对数组使用初始化列表，或 memset 两者在底层上可能等效。（msvc编译器将前者处理为后者）。对数组用循环初始化，和使用 memset 初始化相比，很有可能等效。即使不等效（memset 调用了 SSE2 扩展），也不可能达到成为一个优化命题和关注点。如果一定要说有点区别，那就是如果是对一个整数数组用初始化列表或者循环初始化，那么编译器不需要考虑地址对齐的问题（因为编译器必然把数组分配到对齐的地址），而 memset 则需要考虑传入的地址是否已对齐到某个基本粒度，并对此未对齐部分作处理。当对一个随机数据组成的内存块进行清零操作，memset 看起来仿佛是唯一正确的可选方式（如果所在平台无此函数，则可以用手写循环替代）。声明数组时提供初始化列表，声明后再调用 memset 或者使用循环初始化（显然，在能够使用 memset 时，循环写法在高级语言层面不如前者简洁），无论是代码规范还是性能层面，这些写法都不存在值得强调的绝对优劣关系。","link":"/2023/03/05/cpp-memset/"},{"title":"mit6.824 - MapReduce极简实现","text":"0 概述MapReduce是一种广泛运用的分布式-大数据计算编程模型，最初由Google发表，其开源实现为Hadoop。 MapReduce 的编程模型非常简单，正如名字一样，用户仅仅需要实现一个 Map 函数，一个 Reduce 函数。 Map 函数，即映射函数：它会接受一个 key-value 对，然后把这个 key-value 对转换成 0 到多个新的 key-value 对并输出出去。 1map (k1, v1) -&gt; list (k2, v2) Reduce 函数，即化简函数：它接受一个 Key，以及这个 Key 下的一组 Value，然后化简成一组新的值 Value 输出出去。 1reduce (k2, list(v2)) -&gt; list(v3) 可以解决的任务例子： 分布式 grep； 统计 URL 的访问频次； 反转网页 - 链接图； 分域名的词向量； 生成倒排索引； 分布式排序。 1 MapReduce结构一图胜千言： 2 总体设计以完成6.8242021Spring的lab1为目标。 可以通过以下git命令：clone代码： 1git clone git://g.csail.mit.edu/6.824-golabs-2021 6.824 master采用lazy分配任务方法，由worker主动去触发任务分配、任务结束等操作。master分配不同的块给不同的worker执行。 因此worker需要实现获取任务，任务结束等RPC，代码如下： 12345678910111213141516171819type GetTaskArgs struct {}type GetTaskReply struct { Type TaskType Filenames []string Task_no int NReduce int Err Errno}type FinishTaskArgs struct { Type TaskType Task_no int}type FinishTaskReply struct { Err Errno} 3 worker设计worker的工作就是不断获取任务，若任务完成则提交之。 其主要代码为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354func Worker(mapf func(string, string) []KeyValue, reducef func(string, []string) string) { // Your worker implementation here. for { args := GetTaskArgs{} reply := GetTaskReply{} log.Printf(&quot;get task request: %v\\n&quot;, args) ok := CallGetTask(&amp;args, &amp;reply) log.Printf(&quot;recv get task reply: %v\\n&quot;, reply) if !ok || reply.Type == STOP { break } // handle map fynction switch reply.Type { case MAP: if len(reply.Filenames) &lt; 1 { log.Fatalf(&quot;don't have filename&quot;) } DoMAP(reply.Filenames[0], reply.Task_no, reply.NReduce, mapf) // map complete, send msg to master finish_args := FinishTaskArgs{ Type: MAP, Task_no: reply.Task_no, } finish_reply := FinishTaskReply{} log.Printf(&quot;finish request: %v\\n&quot;, finish_args) CallFinishTask(&amp;finish_args, &amp;finish_reply) log.Printf(&quot;recv finish reply: %v\\n&quot;, finish_reply) // time.Sleep(time.Second) case REDUCE: if len(reply.Filenames) &lt; 1 { log.Fatalf(&quot;don't have filenames&quot;) } DoReduce(reply.Filenames, reply.Task_no, reducef) // reduce complete, send msg to master finish_args := FinishTaskArgs{ Type: REDUCE, Task_no: reply.Task_no, } finish_reply := FinishTaskReply{} log.Printf(&quot;finish request: %v\\n&quot;, finish_args) CallFinishTask(&amp;finish_args, &amp;finish_reply) log.Printf(&quot;recv finish reply: %v\\n&quot;, finish_reply) // time.Sleep(time.Second) case WAIT: log.Printf(&quot;wait task\\n&quot;) time.Sleep(time.Second) default: time.Sleep(time.Second) } }} 其中分MAP、REDUCE、WAIT和STOP四个状态： MAP：进行MAP操作 REDUCE：进行REDECE操作 WAIT：等待其他worker完成任务（比如等待在总体MAP任务的收尾上，以及没有更多的MAP任务可以分配了） STOP：worker停止、退出 其中最重要的为map和reduce任务的执行。 map任务的执行实现代码如下：（对应上图中的2、3、4步） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func DoMAP(filename string, task_no int, nReduce int, mapf func(string, string) []KeyValue) { file, err := os.Open(filename) if err != nil { log.Fatalf(&quot;cannot open %v&quot;, filename) } content, err := ioutil.ReadAll(file) if err != nil { log.Fatalf(&quot;cannot read %v&quot;, filename) } file.Close() kva := mapf(filename, string(content)) sort.Sort(ByKey(kva)) log.Println(&quot;encode to json&quot;) files := make([]*os.File, nReduce) encoders := make([]*json.Encoder, nReduce) for i := 0; i &lt; nReduce; i++ { ofile, err := ioutil.TempFile(&quot;&quot;, &quot;mr-tmp*&quot;) if err != nil { log.Fatalf(&quot;cannot create temp file&quot;) } defer ofile.Close() encoder := json.NewEncoder(ofile) encoders[i] = encoder files[i] = ofile } var index int for _, kv := range kva { index = ihash(kv.Key) % nReduce err = encoders[index].Encode(&amp;kv) if err != nil { log.Fatalf(&quot;cannot encode %v&quot;, kv) } } // atomically rename for i := 0; i &lt; nReduce; i++ { filename_tmp := fmt.Sprintf(&quot;mr-%d-%d&quot;, task_no, i) err := os.Rename(files[i].Name(), filename_tmp) if err != nil { log.Fatalf(&quot;cannot rename %v to %v&quot;, files[i].Name(), filename_tmp) } }} 比较有意思的是map需要通过一个hash函数将相同的条目分布在同一输出文件中： 1234567891011121314func ihash(key string) int { h := fnv.New32a() h.Write([]byte(key)) return int(h.Sum32() &amp; 0x7fffffff)}var index intfor _, kv := range kva { index = ihash(kv.Key) % nReduce err = encoders[index].Encode(&amp;kv) if err != nil { log.Fatalf(&quot;cannot encode %v&quot;, kv) }} reduce任务的执行实现代码如下：（对应上图中的5、6步） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354func DoReduce(filenames []string, task_no int, reducef func(string, []string) string) { // read data from mid-file kva := make([]KeyValue, 0) for _, filename := range filenames { file, err := os.Open(filename) if err != nil { log.Fatalf(&quot;cannot open %v&quot;, filename) } defer file.Close() dec := json.NewDecoder(file) for { var kv KeyValue if err := dec.Decode(&amp;kv); err != nil { break } kva = append(kva, kv) } } sort.Sort(ByKey(kva)) // call Reduce on each distinct key in kva[], // and print the result to mr-out-0. ofile, err := ioutil.TempFile(&quot;&quot;, &quot;mr-out-tmp*&quot;) if err != nil { log.Fatalf(&quot;cannot create temp file&quot;) } defer ofile.Close() i := 0 for i &lt; len(kva) { j := i + 1 for j &lt; len(kva) &amp;&amp; kva[j].Key == kva[i].Key { j++ } values := []string{} for k := i; k &lt; j; k++ { values = append(values, kva[k].Value) } output := reducef(kva[i].Key, values) // this is the correct format for each line of Reduce output. fmt.Fprintf(ofile, &quot;%v %v\\n&quot;, kva[i].Key, output) i = j } output_filename := fmt.Sprintf(&quot;mr-out-%d&quot;, task_no) err = os.Rename(ofile.Name(), output_filename) if err != nil { log.Fatalf(&quot;cannot rename %v to %v&quot;, ofile.Name(), output_filename) }} 按道理应该是要在GFS上读写文件的，条件不允许，就直接采用UNIX的文件系统了。 4 master设计master的设计还是比较简单的，只包含很少的信息： 1234567type Coordinator struct { tasks []Task nReduce int nMap int status CoordinatorStatus mu sync.Mutex} 对所需要进行的任务信息进行定义，如下： 1234567891011121314type TaskStatus intconst ( idle TaskStatus = iota in_progress completed)type Task struct { tno int filenames []string status TaskStatus startTime time.Time} 其主要就是接受worker的两个RPC请求。 获取任务的RPC handler实现如下： 对于长时间（10s）未完成的任务，重新制定一个worker执行此任务。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051func (c *Coordinator) GetTask(args *GetTaskArgs, reply *GetTaskReply) error { c.mu.Lock() defer c.mu.Unlock() finish_flag := c.IsAllFinish() if finish_flag { c.NextPhase() } for i := 0; i &lt; len(c.tasks); i++ { if c.tasks[i].status == idle { log.Printf(&quot;send task %d to worker\\n&quot;, i) reply.Err = SuccessCode reply.Task_no = i reply.Filenames = c.tasks[i].filenames if c.status == MAP_PHASE { reply.Type = MAP reply.NReduce = c.nReduce } else if c.status == REDUCE_PHASE { reply.NReduce = 0 reply.Type = REDUCE } else { log.Fatal(&quot;unexpected status&quot;) } c.tasks[i].startTime = time.Now() c.tasks[i].status = in_progress return nil } else if c.tasks[i].status == in_progress { curr := time.Now() if curr.Sub(c.tasks[i].startTime) &gt; time.Second*10 { log.Printf(&quot;resend task %d to worker\\n&quot;, i) reply.Err = SuccessCode reply.Task_no = i reply.Filenames = c.tasks[i].filenames if c.status == MAP_PHASE { reply.Type = MAP reply.NReduce = c.nReduce } else if c.status == REDUCE_PHASE { reply.NReduce = 0 reply.Type = REDUCE } else { log.Fatal(&quot;unexpected status&quot;) } c.tasks[i].startTime = time.Now() return nil } } } reply.Err = SuccessCode reply.Type = WAIT return nil} 完成任务的RPC handler实现如下： 12345678910111213func (c *Coordinator) FinishTask(args *FinishTaskArgs, reply *FinishTaskReply) error { c.mu.Lock() defer c.mu.Unlock() if args.Task_no &gt;= len(c.tasks) || args.Task_no &lt; 0 { reply.Err = ParaErrCode return nil } c.tasks[args.Task_no].status = completed if c.IsAllFinish() { c.NextPhase() } return nil} 检查全部任务是否完成，完成就进入下一个阶段： 123456789101112131415161718192021func (c *Coordinator) IsAllFinish() bool { for i := len(c.tasks) - 1; i &gt;= 0; i-- { if c.tasks[i].status != completed { return false } } return true}func (c *Coordinator) NextPhase() { if c.status == MAP_PHASE { log.Println(&quot;change to REDUCE_PHASE&quot;) c.MakeReduceTasks() c.status = REDUCE_PHASE } else if c.status == REDUCE_PHASE { log.Println(&quot;change to FINISH_PHASE&quot;) c.status = FINISH_PHASE } else { log.Println(&quot;unexpected status change!&quot;) }} 客户端查看MapReduce任务是否完成： 12345678func (c *Coordinator) Done() bool { c.mu.Lock() defer c.mu.Unlock() if c.status == FINISH_PHASE { return true } return false} 5 客户端如何使用呢？写两个函数（Map和Reduce）就行啦： 1234567891011121314151617181920212223242526272829303132//// The map function is called once for each file of input. The first// argument is the name of the input file, and the second is the// file's complete contents. You should ignore the input file name,// and look only at the contents argument. The return value is a slice// of key/value pairs.//func Map(filename string, contents string) []mr.KeyValue { // function to detect word separators. ff := func(r rune) bool { return !unicode.IsLetter(r) } // split contents into an array of words. words := strings.FieldsFunc(contents, ff) kva := []mr.KeyValue{} for _, w := range words { kv := mr.KeyValue{w, &quot;1&quot;} kva = append(kva, kv) } return kva}//// The reduce function is called once for each key generated by the// map tasks, with a list of all the values created for that key by// any map task.//func Reduce(key string, values []string) string { // return the number of occurrences of this word. return strconv.Itoa(len(values))} 6 附录详细代码可以参考： 仓库 commit","link":"/2023/03/06/mit6-824-mapreduce/"},{"title":"mit6.S081 - Xv6 and Unix utilities","text":"sleep Implement the UNIX program sleep for xv6; your sleep should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file user/sleep.c. 描述：实现一个提供sleep功能的unix程序。 解决思路：系统已经实现了sleep函数，直接调用即可。 代码： 12345678910111213141516171819#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;intmain(int argc, char *argv[]){ int ticks_num; if(argc != 2){ fprintf(2, &quot;Usage: sleep times\\n&quot;); exit(1); } ticks_num = atoi(argv[1]); sleep(ticks_num); exit(0);} pingpong Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “: received ping”, where is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “: received pong”, and exit. Your solution should be in the file user/pingpong.c. 描述：使用管道（pipe）实现ping-pong（即使用pipe实现父进程子进程之间的通信） 解决思路：fork + pipe + write/read即可，比较简单，要注意pipe会创建两个fd（读/写），fork后子进程会继承文件描述符。 代码： 12345678910111213141516171819202122232425262728#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;intmain(int argc, char *argv[]){ int p[2]; // read, write char buf[2]; if(argc != 1){ fprintf(2, &quot;Usage: pingpong\\n&quot;); exit(1); } pipe(p); if (fork() == 0) { // child read(p[0], buf, 1); fprintf(1, &quot;%d: received ping\\n&quot;, getpid()); write(p[1], &quot;c&quot;, 1); exit(0); } else { // father write(p[1], &quot;c&quot;, 1); read(p[0], buf, 1); fprintf(1, &quot;%d: received pong\\n&quot;, getpid()); } exit(0);} primes Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down this page and the surrounding text explain how to do it. Your solution should be in the file user/primes.c. 描述：使用pipe实现素数筛。 解决思路：父进程产生2-35的数，然后子进程按以下算法进行筛选即可。 123456p = get a number from left neighborprint ploop: n = get a number from left neighbor if (p does not divide n) send n to right neighbor 代码：（若BUFSIZE过大会panic，排查后发现是stack只有一页。。。） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#define MAX_SEQ 35#define BUFSIZE 100int getline(int fd, char *buf, int max){ int i, cc; char c; for (i = 0; i + 1 &lt; max;) { cc = read(fd, &amp;c, 1); if (cc &lt; 1) { return 0; } if (c == '\\n' || c == '\\r') break; buf[i++] = c; } buf[i] = '\\0'; return i;}int getnum(char *buf, int *pos){ int num = 0, i = *pos; while(buf[i] &gt;= '0' &amp;&amp; buf[i] &lt;= '9') { num = num * 10 + buf[i] - '0'; i++; } *pos = i - 1; return num;}int primer(int read_fd){ char buf[BUFSIZE]; int len = getline(read_fd, buf, BUFSIZE); // printf(&quot;%s\\n&quot;, buf); close(read_fd); int pipe_fd[2]; pipe(pipe_fd); int i = 0, first_print_flag = 1; int is_have = 0; int first_num = getnum(buf, &amp;i), num_tmp; printf(&quot;prime %d\\n&quot;, first_num); for (i = 0; i &lt; len; ++i) { if (buf[i] &gt;= '0' &amp;&amp; buf[i] &lt;= '9') { num_tmp = getnum(buf, &amp;i); if (num_tmp % first_num == 0) { continue; } is_have = 1; break; } } if (is_have) { if (fork() == 0) { // child close(pipe_fd[1]); primer(pipe_fd[0]); exit(0); } else { close(pipe_fd[0]); for (i = 0; i &lt; len; ++i) { if (buf[i] &gt;= '0' &amp;&amp; buf[i] &lt;= '9') { num_tmp = getnum(buf, &amp;i); if (num_tmp % first_num == 0) { continue; } if (first_print_flag) { fprintf(pipe_fd[1], &quot;%d&quot;, num_tmp); first_print_flag = 0; } else { fprintf(pipe_fd[1], &quot; %d&quot;, num_tmp); } } } fprintf(pipe_fd[1], &quot;\\n&quot;, num_tmp); close(pipe_fd[1]); wait(0); } } else { close(pipe_fd[0]); close(pipe_fd[1]); } return 0;}int main(int argc, char *argv[]){ int pipe_fd[2]; // read, write if (argc != 1) { fprintf(2, &quot;Usage: primes\\n&quot;); exit(1); } pipe(pipe_fd); if (fork() == 0) { // child close(pipe_fd[1]); primer(pipe_fd[0]); exit(0); } else { // father close(pipe_fd[0]); for (int i = 2; i &lt;= MAX_SEQ; ++i) { fprintf(pipe_fd[1], &quot;%d&quot;, i); if (i != MAX_SEQ) { fprintf(pipe_fd[1], &quot; &quot;, i); } else { fprintf(pipe_fd[1], &quot;\\n&quot;, i); } } close(pipe_fd[1]); wait(0); } exit(0);} find Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file user/find.c. 描述：实现find。 解决思路：魔改ls即可，改成dfs实现。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/fs.h&quot;char*fmtname(char *path){ char *p; // Find first character after last slash. for(p=path+strlen(path); p &gt;= path &amp;&amp; *p != '/'; p--) ; p++; return p;}voidfind(char *path, char *target){ struct stat st; char buf[512], *p; int fd; struct dirent de; if (stat(path, &amp;st) &lt; 0) { fprintf(2, &quot;find: cannot stat %s\\n&quot;, path); return; } switch(st.type){ case T_FILE: if (strcmp(fmtname(path), target) == 0) { printf(&quot;%s\\n&quot;, path); } break; case T_DIR: if((fd = open(path, 0)) &lt; 0){ fprintf(2, &quot;find: cannot open %s\\n&quot;, path); return; } strcpy(buf, path); p = buf+strlen(buf); *p++ = '/'; // many records while(read(fd, &amp;de, sizeof(de)) == sizeof(de)){ if(de.inum == 0) continue; if (!strcmp(&quot;.&quot;, de.name) || !strcmp(&quot;..&quot;, de.name)) { continue; } memmove(p, de.name, strlen(de.name)); p[strlen(de.name)] = 0; find(buf, target); } close(fd); break; }}intmain(int argc, char *argv[]){ if(argc != 3){ fprintf(2, &quot;Usage: find path keyword\\n&quot;); exit(1); } find(argv[1], argv[2]); exit(0);} xargs Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file user/xargs.c. 描述：实现xargs。 解决思路：对每行进行处理，因此加上上面的getline函数然后搭配上fork和exec就行（和shell类似）。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/param.h&quot;#define MAX_LEN 512int getline(char *buf, int max){ int i, cc; char c; for(i=0; i+1 &lt; max; ){ cc = read(0, &amp;c, 1); if(cc &lt; 1) { return 0; } if(c == '\\n' || c == '\\r') break; buf[i++] = c; } buf[i] = '\\0'; printf(&quot;str: %s\\n&quot;, buf); return 1;}intmain(int argc, char *argv[]){ // echo hello too | xargs echo bye char buffer[MAX_LEN]; char* argv_tmp[MAXARG]; // minus &quot;xargs&quot; memcpy(argv_tmp, argv + 1, (argc - 1) * sizeof(char*)); while (getline(buffer, MAX_LEN)) { if (fork() == 0) { argv_tmp[argc - 1] = buffer; exec(argv_tmp[0], argv_tmp); exit(0); } else { wait(0); } } exit(0);}","link":"/2023/03/06/mit6-s081-lab1/"}],"tags":[{"name":"cmu15445","slug":"cmu15445","link":"/tags/cmu15445/"},{"name":"Effective C++","slug":"Effective-C","link":"/tags/Effective-C/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"stl","slug":"stl","link":"/tags/stl/"},{"name":"mit6.824","slug":"mit6-824","link":"/tags/mit6-824/"},{"name":"mit6.s081","slug":"mit6-s081","link":"/tags/mit6-s081/"}],"categories":[],"pages":[]}