{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/03/05/hello-world/"},{"title":"cmu-15445-lab1","text":"本文为本人完成15445 2020fall（B+树版本）时的一些记录，仅作为备忘录使用。 TASK #1 - LRU REPLACEMENT POLICY本任务为实现一个LRU页面置换策略，建立一个关于面向磁盘的数据库的基本的概念是很重要的，如下图： 从中可以看出，实际数据是持久化存储于磁盘之上的，执行引擎主要进行一些数据操作（读/写，也即对Page增删改查），而BufferPool则是介于执行引擎和磁盘之间，位于内存中，给执行引擎提供Page。由于存储器体系结构一般表现为内存容量远小于磁盘容量，因此BufferPool是无法加载整个db的所有Pages的，因此需要在合适的时机将Page写入磁盘中，LRU就决定了牺牲哪个Page（即将哪个Page写回到磁盘中），其中包含了局部性原理的思想。 在Buffer Pool中，Page是存放在frame中的，这是要注意的一个点（buffer pool就是一个能容放多个Page的vector）。 The size of the LRUReplacer is the same as buffer pool since it contains placeholders for all of the frames in the BufferPoolManager. However, not all the frames are considered as in the LRUReplacer. The LRUReplacer is initialized to have no frame in it. Then, only the newly unpinned ones will be considered in the LRUReplacer. 所要实现的接口主要是下面四个： Victim(T*) : Remove the object that was accessed the least recently compared to all the elements being tracked by the Replacer, store its contents in the output parameter and return True. If the Replacer is empty return False. Pin(T) : This method should be called after a page is pinned to a frame in the BufferPoolManager. It should remove the frame containing the pinned page from the LRUReplacer. Unpin(T) : This method should be called when the pin_count of a page becomes 0. This method should add the frame containing the unpinned page to the LRUReplacer. Size() : This method returns the number of frames that are currently in the LRUReplacer. LRU的实现十分的简单，是经典的leetcode题，用list套一个unordered_map即可实现。 下面主要讲一下我对Pin和UnPin的理解： Pin(T) : 将一个Page(frame)从LRU的list中剔除。即该Page(frame)被Buffer Pool所使用了，LRU不应该牺牲该页面。 Unpin(T) : 加入一个Page(frame)入LRU的list。即该页面Buffer Pool目前没人使用了，LRU根据策略决定该页面的去留。 Victim(T*) :意思很直接，LRU根据规则（最近最少使用）有选择性的牺牲一个页面(frame)。 并发的话，直接加大锁就好了。std::lock_guard是一种RAII的加锁方式，可以不用unlock（在析构的时候unlock），比较方便。给出Victim的实现方法，其他的应 Prof. Pavlo 要求就不放出来了。 1234567891011bool LRUReplacer::Victim(frame_id_t *frame_id) { std::lock_guard&lt;std::mutex&gt; lock(latch_); if (id2iter_.empty()) { return false; } auto deleting_id = lru_list_.back(); lru_list_.pop_back(); id2iter_.erase(deleting_id); *frame_id = deleting_id; return true;} TASK #2 - BUFFER POOL MANAGER第二个任务为构造一个Buffer Pool。 The BufferPoolManager is responsible for fetching database pages from the DiskManager and storing them in memory. The BufferPoolManager can also write dirty pages out to disk when it is either explicitly instructed to do so or when it needs to evict a page to make space for a new page. 实现以下几个接口： FetchPageImpl(page_id) NewPageImpl(page_id) UnpinPageImpl(page_id, is_dirty) FlushPageImpl(page_id) DeletePageImpl(page_id) FlushAllPagesImpl() (其实可以先通过测试程序了解这几个接口怎么用的，然后再去实现会比较好！) NewPageImpl(page_id)：新建一个Page。 FetchPageImpl(page_id)：获取一个Page。 UnpinPageImpl(page_id, is_dirty)：解除对某个Page的使用（别的进程可能还在使用，pin_count为0的时候可以删除） DeletePageImpl(page_id)：删除一个Page。 FlushPageImpl(page_id)：强制将某个Page写盘。 FlushAllPagesImpl()：将所有Page写盘。 这个task其实本质上就是考验对下面两个点的理解，根据提示看看DiskManager 的API是比较好实现的： Dirty Flag ：当该flag为真时，该页被写过了，要写回磁盘。 Pin/Reference Counter：引用计数，当该计数为0时，将对应frame加入LRU中；当该计数不为0时，将对应frame从LRU中删除（即不参与LRU的替换）。 该task有几个坑需要注意一下： 重复UnpinPageImpl，但is_dirty标志不同。 不是简单的赋值设置is_dirty标志，而是累计，即或一下。 page-&gt;is_dirty_ |= is_dirty; New完一个Page后，其pin_count为1，因此不要将这个Page放入LRU。 replacer_-&gt;Pin(fid); New完一个Page后，要立即刷盘。可能会有new完以后unpin(false)的情况，不刷盘这一页就丢失了 disk_manager_-&gt;WritePage(new_page-&gt;GetPageId(), new_page-&gt;GetData()); 获取frame时，先从free list获取，再从lru中获取。 12345678910111213141516/*** @brief get a free page from free_list or lru_list** @return frame_id_t frame id, -1 is error*/frame_id_t BufferPoolManager::get_free_frame() {frame_id_t frame_id = -1;if (!free_list_.empty()) { frame_id = free_list_.front(); free_list_.pop_front();} else { replacer_-&gt;Victim(&amp;frame_id);}return frame_id;} 删除一个Page时，要保证free list和LRU中只存在一个fid，而不是两边都有。 replacer_-&gt;Pin(fid); free_list_.emplace_back(fid); 由于是多线程的程序，可以多跑几次测试一下，通过日志排查出错的原因。 12345678910111213141516#!/usr/bin/env bashtrap 'exit 1' INTecho &quot;Running test $1 for $2 iters&quot;for i in $(seq 1 $2); do echo -ne &quot;\\r$i / $2&quot; LOG=&quot;$i.txt&quot; # Failed go test return nonzero exit codes $1 &amp;&gt; $LOG if [[ $? -eq 0 ]]; then rm $LOG else echo &quot;Failed at iter $i, saving log at $LOG&quot; fidone （gradescope上测试要是失败了可以直接偷测试文件，逃 若有概念不理解的可以翻翻课件。","link":"/2023/03/05/cmu-15445-lab1/"},{"title":"effective_cpp_1","text":"第一章 让自己习惯 C++（Accustoming Youself to C++）条款1：视C++为一个语言联邦C++是个多重范型编程语言，同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式。 视C++为一个语言联邦，包括以下四个部分： C：面向过程的部分 Object-Oriented C++：面向对象的部分，包括封装、继承、多态以及虚函数（动态绑定）等。 Template C++：泛型编程部分 STL： 融合泛型编程和OOP编程思想的C++标准模板库，包括容器、迭代器、算法以及函数对象等。 请记住： C++高效编程守则视状况而变化，取决于使用的是这四个部分中的哪一部分。 条款2：尽量以const，enum，inline代替#define宁可以编译器代替预处理器。 #define即宏定义在预处理阶段进行处理，不进入记号表（symbol table）。 123int a = 5, b = 0;CALL_MAX(++a, b); //a被累加2次CALL_MAX(++a, b + 10); //a被累加1次 这是不可预料的行为，因此使用内联函数来代替宏定义函数。 请记住： 对于单纯常量，最好使用const对象或enum替换#defines。 对于形似函数的宏，最好改用inline函数替换#defines。 条款3：尽可能使用constconst关键字告诉编译器某值应该保持不变，即为只读的。 const成员函数两个成员函数如果只是常量性不同，可以被重载。 const成员函数代表this指针的类型为：const className &amp;。 使用const成员函数来处理const对象。 在const和non-cons成员函数中避免重复利用non-const版本调用const版本，再加上转型const_cast、static_cast,例如： 123456const char&amp; operator[](int pos) const;//const版本char&amp; operator[](int pos) { //non-const版本 return const_cast&lt;char&amp;&gt; //返回值转型，移除const (static_cast&lt;const className&amp;&gt;(*this)[pos]);//*this转型,增加const} 但反过来使用const版本调用non-const版本则是一种错误行为。 请记住： 将某些东西声明为const可以帮助编译器侦测除错误；const可以被施加在任何作用域内的对象、函数参数、函数返回类型、成员函数本身。 编译器强制实施bitwise constness，但是你编写程序时应该使用“概念上的常量性”。 当const和non-const成员函数有着实质等价的实现时，使用non-const版本来调用const版本可以避免代码重复。 条款4：确定对象使用前已被初始化永远在对象使用之前将其初始化。 对于内置类型，手动初始化。 对于非内置类型，使用构造函数进行初始化。 赋值和初始化有区别： 12345678910// 赋值，而非初始化ABEntry(const string&amp; name, const string&amp; address, int num) { _name = name; _address = address; _num = num; }// 初始化，发生在进入构造函数本体之前// 即成员初值列(member initialization list)ABEntry::ABEntry(const string&amp; name, const string&amp; address, int num) : _name(name), _address(address), _num(num) { } C++有着固定的初始化顺序：按照声明顺序进行初始化，且基类先于派生类初始化 static对象：其寿命从被构造出来直到程序结束为止。 local static object(局部静态对象)：函数内的static对象。 non-local static object(非局部静态对象)：非函数内的static对象，不同编译单元之间初始化次序不确定 因此，要解决non-local static object初始化次序问题，就要将non-local static object转换为local static object（使用单例模式，即封装一层函数） 123456789101112class Singleton{public: static Singleton&amp; getInstance() { static Singleton s; return s; }private: Singleton() {} Singleton(const Singleton&amp;); void operator=(const Singleton&amp;);}; 请记住: 为内置类型进行手工初始化，C++不保证初始化它们。 构造函数最好使用成员初值列，不要在构造函数中使用赋值操作，初值列中的成员变量的顺序应该和声明顺序一致。 为免除“跨编译单元之初始化次序”问题，使用返回local static对象引用的函数来代替non-local static对象。 reference[1] Effective C++ · Scott Meyers","link":"/2023/03/05/effective-cpp-1/"},{"title":"effective_cpp_2","text":"第一章 让自己习惯 C++（Accustoming Youself to C++）条款1：视C++为一个语言联邦C++是个多重范型编程语言，同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式。 视C++为一个语言联邦，包括以下四个部分： C：面向过程的部分 Object-Oriented C++：面向对象的部分，包括封装、继承、多态以及虚函数（动态绑定）等。 Template C++：泛型编程部分 STL： 融合泛型编程和OOP编程思想的C++标准模板库，包括容器、迭代器、算法以及函数对象等。 请记住： C++高效编程守则视状况而变化，取决于使用的是这四个部分中的哪一部分。 条款2：尽量以const，enum，inline代替#define宁可以编译器代替预处理器。 #define即宏定义在预处理阶段进行处理，不进入记号表（symbol table）。 123int a = 5, b = 0;CALL_MAX(++a, b); //a被累加2次CALL_MAX(++a, b + 10); //a被累加1次 这是不可预料的行为，因此使用内联函数来代替宏定义函数。 请记住： 对于单纯常量，最好使用const对象或enum替换#defines。 对于形似函数的宏，最好改用inline函数替换#defines。 条款3：尽可能使用constconst关键字告诉编译器某值应该保持不变，即为只读的。 const成员函数两个成员函数如果只是常量性不同，可以被重载。 const成员函数代表this指针的类型为：const className &amp;。 使用const成员函数来处理const对象。 在const和non-cons成员函数中避免重复利用non-const版本调用const版本，再加上转型const_cast、static_cast,例如： 123456const char&amp; operator[](int pos) const;//const版本char&amp; operator[](int pos) { //non-const版本 return const_cast&lt;char&amp;&gt; //返回值转型，移除const (static_cast&lt;const className&amp;&gt;(*this)[pos]);//*this转型,增加const} 但反过来使用const版本调用non-const版本则是一种错误行为。 请记住： 将某些东西声明为const可以帮助编译器侦测除错误；const可以被施加在任何作用域内的对象、函数参数、函数返回类型、成员函数本身。 编译器强制实施bitwise constness，但是你编写程序时应该使用“概念上的常量性”。 当const和non-const成员函数有着实质等价的实现时，使用non-const版本来调用const版本可以避免代码重复。 条款4：确定对象使用前已被初始化永远在对象使用之前将其初始化。 对于内置类型，手动初始化。 对于非内置类型，使用构造函数进行初始化。 赋值和初始化有区别： 12345678910// 赋值，而非初始化ABEntry(const string&amp; name, const string&amp; address, int num) { _name = name; _address = address; _num = num; }// 初始化，发生在进入构造函数本体之前// 即成员初值列(member initialization list)ABEntry::ABEntry(const string&amp; name, const string&amp; address, int num) : _name(name), _address(address), _num(num) { } C++有着固定的初始化顺序：按照声明顺序进行初始化，且基类先于派生类初始化 static对象：其寿命从被构造出来直到程序结束为止。 local static object(局部静态对象)：函数内的static对象。 non-local static object(非局部静态对象)：非函数内的static对象，不同编译单元之间初始化次序不确定 因此，要解决non-local static object初始化次序问题，就要将non-local static object转换为local static object（使用单例模式，即封装一层函数） 123456789101112class Singleton{public: static Singleton&amp; getInstance() { static Singleton s; return s; }private: Singleton() {} Singleton(const Singleton&amp;); void operator=(const Singleton&amp;);}; 请记住: 为内置类型进行手工初始化，C++不保证初始化它们。 构造函数最好使用成员初值列，不要在构造函数中使用赋值操作，初值列中的成员变量的顺序应该和声明顺序一致。 为免除“跨编译单元之初始化次序”问题，使用返回local static对象引用的函数来代替non-local static对象。 reference[1] Effective C++ · Scott Meyers","link":"/2021/12/19/effective-cpp-2/"}],"tags":[{"name":"cmu15445","slug":"cmu15445","link":"/tags/cmu15445/"},{"name":"Effective C++","slug":"Effective-C","link":"/tags/Effective-C/"}],"categories":[],"pages":[]}