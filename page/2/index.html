<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Xinlong-Chen&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Xinlong-Chen&#039;s blog"><meta name="msapplication-TileImage" content="/img/avatar3.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Xinlong-Chen&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="及行迷之未远"><meta property="og:type" content="blog"><meta property="og:title" content="Xinlong-Chen&#039;s blog"><meta property="og:url" content="https://xinlong-chen.github.io/"><meta property="og:site_name" content="Xinlong-Chen&#039;s blog"><meta property="og:description" content="及行迷之未远"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://xinlong-chen.github.io/img/og_image.png"><meta property="article:author" content="Xinlong-Chen"><meta property="article:tag" content="操作系统 | 数据库系统"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://xinlong-chen.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xinlong-chen.github.io"},"headline":"Xinlong-Chen's blog","image":["https://xinlong-chen.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Xinlong-Chen"},"publisher":{"@type":"Organization","name":"Xinlong-Chen's blog","logo":{"@type":"ImageObject","url":"https://xinlong-chen.github.io/img/avatar3.png"}},"description":"及行迷之未远"}</script><link rel="icon" href="/img/avatar3.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar3.png" alt="Xinlong-Chen&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-05T15:04:52.000Z" title="3/5/2023, 11:04:52 PM">2023-03-05</time>发表</span><span class="level-item"><time dateTime="2023-03-05T15:13:28.037Z" title="3/5/2023, 11:13:28 PM">2023-03-05</time>更新</span><span class="level-item">1 分钟读完 (大约220个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/03/05/stl-array/">STL - array源码分析</a></p><div class="content"><p>array底层就是一个定长数组，给定长数组加上迭代器相关的东西，就可以让他像一个容器，符合容器的性质。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _NOEXCEPT noexcept</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="type">size_t</span> _Size&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">array</span> &#123;</span><br><span class="line">    <span class="comment">// types:</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type &amp;reference;</span><br><span class="line">    <span class="keyword">typedef</span> value_type *pointer;</span><br><span class="line">    <span class="keyword">typedef</span> value_type *iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"></span><br><span class="line">    _Tp __elems_[_Size];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> value_type *<span class="title">data</span><span class="params">()</span> <span class="type">const</span> _NOEXCEPT </span>&#123; <span class="keyword">return</span> __elems_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iterators:</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> _NOEXCEPT </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="built_in">data</span>()); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> _NOEXCEPT </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="built_in">data</span>() + _Size); &#125;</span><br><span class="line"></span><br><span class="line">    reference <span class="keyword">operator</span>[](size_type __n) _NOEXCEPT &#123; <span class="keyword">return</span> __elems_[__n]; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">reference <span class="title">at</span><span class="params">(size_type __n)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="type">size_t</span> _Size&gt;</span><br><span class="line"><span class="keyword">typename</span> array&lt;_Tp, _Size&gt;::reference</span><br><span class="line">array&lt;_Tp, _Size&gt;::<span class="built_in">at</span>(size_type __n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__n &gt;= _Size)</span><br><span class="line">        __throw_out_of_range(<span class="string">&quot;array::at&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> __elems_[__n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>偏特化版本：(对size为0情况进行处理)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">array</span>&lt;_Tp, <span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// types:</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type &amp;reference;</span><br><span class="line">    <span class="keyword">typedef</span> value_type *iterator;</span><br><span class="line">    <span class="keyword">typedef</span> value_type *pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> conditional&lt;is_const&lt;_Tp&gt;::value, <span class="type">const</span> <span class="type">char</span>,</span><br><span class="line">            <span class="type">char</span>&gt;::type _CharType;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_ArrayInStructT</span> &#123;</span><br><span class="line">        _Tp __data_[<span class="number">1</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">    _ALIGNAS_TYPE(_ArrayInStructT)</span><br><span class="line">    _CharType __elems_[<span class="built_in">sizeof</span>(_ArrayInStructT)];</span><br><span class="line"></span><br><span class="line">    <span class="function">value_type *<span class="title">data</span><span class="params">()</span> _NOEXCEPT </span>&#123; <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;value_type *&gt;(__elems_); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-05T15:02:41.000Z" title="3/5/2023, 11:02:41 PM">2023-03-05</time>发表</span><span class="level-item"><time dateTime="2023-03-05T15:13:22.700Z" title="3/5/2023, 11:13:22 PM">2023-03-05</time>更新</span><span class="level-item">33 分钟读完 (大约4917个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/03/05/stl-deque/">STL - deque源码分析</a></p><div class="content"><h4 id="deque概述"><a href="#deque概述" class="headerlink" title="deque概述"></a>deque概述</h4><p>deque是一种双向开口的“连续”线性空间（即可以在头尾两端分别做元素的插入和删除操作）。</p>
<p>deque与vector的差别：</p>
<ol>
<li>deque允许在常数时间内对头端进行元素的插入和删除操作，vector尾部插入和删除常数时间，头部操作O（n）时间</li>
<li>deque没有容量概念，不需要和vector一样进行老三样：申请新空间-&gt;复制元素-&gt;释放旧空间</li>
<li>deque的Ramdon Access Iterator进行过特殊设计，复杂度比vector高。</li>
</ol>
<h4 id="deque的中控器"><a href="#deque的中控器" class="headerlink" title="deque的中控器"></a>deque的中控器</h4><h5 id="底层内存分布"><a href="#底层内存分布" class="headerlink" title="底层内存分布"></a>底层内存分布</h5><p>deque的“连续”空间只是在逻辑上连续的，实际上deque是由一段一段的定量连续空间构成。一旦有必要在deque的头端或尾端增加新空间，便配置一段定量的连续空间，串接在整个deque的头端或尾端。</p>
<p>deque的核心任务是维护 <strong>分段的定量连续空间</strong>整体连续的假象，并提供随机存取的接口，避免vector的申请新空间-&gt;复制元素-&gt;释放旧空间，但其代价是deque的迭代器架构较复杂。</p>
<p><img src="/2023/03/05/stl-deque/1659233-20210331190400722-1934546150.png"></p>
<h5 id="中控器"><a href="#中控器" class="headerlink" title="中控器"></a>中控器</h5><p>正如上面那张图看到的，对于<strong>分段的定量连续空间</strong>，我们需要一个map（就是一小段连续空间，和数组类似）来指示他（就像一个包租婆有很多房子，手里得有一个地图，找到他的每个房子）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc, <span class="type">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line"><span class="keyword">class</span> deque &#123;</span><br><span class="line"><span class="keyword">public</span>:                         <span class="comment">// Basic types</span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"><span class="keyword">protected</span>:                      <span class="comment">// Internal typedefs</span></span><br><span class="line">  <span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  map_pointer map;<span class="comment">//指向指针数组 T** 类似于二维数组 T*指向一个缓冲区，T**就是这个map</span></span><br><span class="line">  size_type map_size;<span class="comment">//指针数组元素个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/05/stl-deque/1659233-20210331190410650-118395508.png"></p>
<h4 id="deque的迭代器"><a href="#deque的迭代器" class="headerlink" title="deque的迭代器"></a>deque的迭代器</h4><h5 id="迭代器结构"><a href="#迭代器结构" class="headerlink" title="迭代器结构"></a>迭代器结构</h5><p>deque是<strong>分段连续空间</strong>，维护“整体连续”假象的任务就落在了operator++和operator–两个运算上了。</p>
<p>我们可以想象，一个iterator指向一个缓冲区（buffer）内元素时，当到了一个buffer的末端则需要跳到下一个buffer，到了buffer的头端则需要跳转到前一个buffer，这里则需要我们前面所说的map来调节。如何知道我们是否在buffer的头尾端呢？这就需要iterator保存这个buffer的begin和end了。</p>
<p>综上，deque的iterator需要以下元素：</p>
<ol>
<li>指向当前元素的指针</li>
<li>指向当前buffer头端的指针</li>
<li>指向当前buffer尾端的指针</li>
<li>指向map中控的指针</li>
</ol>
<p>SGI STL中源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__deque_iterator</span> &#123; 	<span class="comment">// 未继承 std::iterator</span></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;      iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*, BufSiz&gt; const_iterator;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">buffer_size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="built_in">sizeof</span>(T)); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* __STL_NON_TYPE_TMPL_PARAM_BUG */</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__deque_iterator</span> &#123; 	<span class="comment">// 未继承 std::iterator</span></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*&gt; const_iterator;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">buffer_size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> __deque_buf_size(<span class="number">0</span>, <span class="built_in">sizeof</span>(T)); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 未继承 std::iterator，所以必须自己写五个必要的迭代器相应型别</span></span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">// (1)</span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type; 				<span class="comment">// (2)</span></span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer; 				<span class="comment">// (3)</span></span><br><span class="line">  <span class="keyword">typedef</span> Ref reference; 				<span class="comment">// (4)</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; 	<span class="comment">// (5)</span></span><br><span class="line">  <span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保持与容器的联结</span></span><br><span class="line">  T* cur;	<span class="comment">// 此迭代器所指之缓冲区中的现行（current）元素</span></span><br><span class="line">  T* first;	<span class="comment">// 此迭代器所指之缓冲区头</span></span><br><span class="line">  T* last;	<span class="comment">// 此迭代器所指之缓冲区尾（含备用空间）</span></span><br><span class="line">  map_pointer node;</span><br><span class="line"></span><br><span class="line">  __deque_iterator(T* x, map_pointer y) </span><br><span class="line">    : <span class="built_in">cur</span>(x), <span class="built_in">first</span>(*y), <span class="built_in">last</span>(*y + <span class="built_in">buffer_size</span>()), <span class="built_in">node</span>(y) &#123;&#125;</span><br><span class="line">  __deque_iterator() : <span class="built_in">cur</span>(<span class="number">0</span>), <span class="built_in">first</span>(<span class="number">0</span>), <span class="built_in">last</span>(<span class="number">0</span>), <span class="built_in">node</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  __deque_iterator(<span class="type">const</span> iterator&amp; x)</span><br><span class="line">    : <span class="built_in">cur</span>(x.cur), <span class="built_in">first</span>(x.first), <span class="built_in">last</span>(x.last), <span class="built_in">node</span>(x.node) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中用来决定缓冲区大小的函数buffer_size()，调用__deque_buf_size()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 n 不为 0，传回 n，表示 buffer size 由使用者自定。</span></span><br><span class="line"><span class="comment">// 如果 n 为 0，表示buffer size 使用预设值，那么</span></span><br><span class="line"><span class="comment">//   如果 sz（元素大小，sizeof(value_type)）小于 512，传回 512/sz，</span></span><br><span class="line"><span class="comment">//   如果 sz 不小于 512，传回 1。</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">size_t</span> __deque_buf_size(<span class="type">size_t</span> n, <span class="type">size_t</span> sz)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="built_in">size_t</span>(<span class="number">512</span> / sz) : <span class="built_in">size_t</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有了迭代器，缓存区，中控map，我们的deque的原型就出来啦：</p>
<p><img src="/2023/03/05/stl-deque/1659233-20210331190429201-661795156.png"></p>
<h5 id="迭代器操作"><a href="#迭代器操作" class="headerlink" title="迭代器操作"></a>迭代器操作</h5><p>迭代器到buffer边缘，则需要请求中控map，看怎么跳转buffer。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span> </span>&#123;</span><br><span class="line">    node = new_node;</span><br><span class="line">    first = *new_node;</span><br><span class="line">    last = first + <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解引用操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *cur; &#125;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br></pre></td></tr></table></figure>

<p>计算两迭代器之间距离：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个iterator相减，计算距离</span></span><br><span class="line">difference_type <span class="keyword">operator</span>-(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) * (node - x.node - <span class="number">1</span>) +</span><br><span class="line">           (cur - first) + (x.last - x.cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器的++、–操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考 More Effective C++, item6: Distinguish between prefix and</span></span><br><span class="line"><span class="comment">// postfix forms of increment and decrement operators.</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    ++cur;				<span class="comment">// 切换至下一个元素。</span></span><br><span class="line">    <span class="keyword">if</span> (cur == last) &#123;		<span class="comment">// 如果已达所在缓冲区的尾端，</span></span><br><span class="line">        <span class="built_in">set_node</span>(node + <span class="number">1</span>);	<span class="comment">// 就切换至下一个节点（亦即缓冲区）</span></span><br><span class="line">        cur = first;			<span class="comment">//   的第一个元素。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>)  &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == first) &#123;	<span class="comment">// 如果已达所在缓冲区的头端，</span></span><br><span class="line">        <span class="built_in">set_node</span>(node - <span class="number">1</span>);	<span class="comment">// 就切换至前一个节点（亦即缓冲区）</span></span><br><span class="line">        cur = last;			<span class="comment">//   的最后一个元素。</span></span><br><span class="line">    &#125;</span><br><span class="line">    --cur;				<span class="comment">// 切换至前一个元素。</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器+一个数值访问实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 參考 More Effective C++, item22: Consider using op= instead of</span></span><br><span class="line"><span class="comment">// stand-alone op.</span></span><br><span class="line">self <span class="keyword">operator</span>+(difference_type n) <span class="type">const</span> &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp += n; <span class="comment">// 调用operator+=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n) &#123;</span><br><span class="line">    difference_type offset = n + (cur - first);</span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()))</span><br><span class="line">        <span class="comment">// 目标位置在同一缓冲区內</span></span><br><span class="line">        cur += n;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 目标位置不在同一缓冲区內</span></span><br><span class="line">        difference_type node_offset =</span><br><span class="line">                offset &gt; <span class="number">0</span> ? offset / <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())</span><br><span class="line">                           : -<span class="built_in">difference_type</span>((-offset - <span class="number">1</span>) / <span class="built_in">buffer_size</span>()) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 切换至正确的节点（亦即缓冲区）</span></span><br><span class="line">        <span class="built_in">set_node</span>(node + node_offset);</span><br><span class="line">        <span class="comment">// 切换至正确的元素</span></span><br><span class="line">        cur = first + (offset - node_offset * <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 參考 More Effective C++, item22: Consider using op= instead of  </span></span><br><span class="line"><span class="comment">// stand-alone op.</span></span><br><span class="line">self <span class="keyword">operator</span>-(difference_type n) <span class="type">const</span> &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp -= n; <span class="comment">// 调用operator-=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>-=(difference_type n) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> += -n; &#125;</span><br><span class="line"><span class="comment">// 以上利用operator+= 来完成 operator-=</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>随机访问实现，模拟连续空间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//随机存取实现</span></span><br><span class="line">reference <span class="keyword">operator</span>[](difference_type n) <span class="type">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + n); &#125;</span><br><span class="line"><span class="comment">// 以上调用operator*, operator+</span></span><br></pre></td></tr></table></figure>

<p>迭代器的比较操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> cur == x.cur; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == x); &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="deque的数据结构"><a href="#deque的数据结构" class="headerlink" title="deque的数据结构"></a>deque的数据结构</h4><p>deque除了维护一个map中控和map中控大小外，还维护了start、finish两个迭代器，分别指向第一个buffer的第一个元素和最后buffer的最后一个元素的下一个位置（左闭右开）。map中控大小的作用是：一旦节点不足，就得配置一块更大的map。</p>
<p>deque的数据结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc, <span class="type">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line"><span class="keyword">class</span> deque &#123;</span><br><span class="line"><span class="keyword">public</span>:                         <span class="comment">// Basic types</span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:                      <span class="comment">// Internal typedefs</span></span><br><span class="line">  <span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">static</span> size_type <span class="title">buffer_size</span><span class="params">()</span> </span>&#123;<span class="comment">//返回</span></span><br><span class="line">    <span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="built_in">sizeof</span>(value_type));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> size_type <span class="title">initial_map_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">8</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:                      <span class="comment">// Data members</span></span><br><span class="line">  map_pointer map;<span class="comment">//指向指针数组</span></span><br><span class="line">  size_type map_size;<span class="comment">//指针数组元素个数</span></span><br><span class="line">  iterator start;<span class="comment">//开始迭代器，其中cur指向头部元素</span></span><br><span class="line">  iterator finish;<span class="comment">//结束迭代器，其中cur指向尾部元素后面的一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>deque的基本对外接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:                         <span class="comment">// Basic accessors</span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line"></span><br><span class="line">reference <span class="keyword">operator</span>[](size_type n) &#123;</span><br><span class="line">    <span class="keyword">return</span> start[<span class="built_in">difference_type</span>(n)]; <span class="comment">// 调用 __deque_iterator&lt;&gt;::operator[]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const_reference <span class="keyword">operator</span>[](size_type n) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> start[<span class="built_in">difference_type</span>(n)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *start; &#125; <span class="comment">// 调用 __deque_iterator&lt;&gt;::operator*</span></span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    iterator tmp = finish;</span><br><span class="line">    --tmp;    <span class="comment">// 调用 __deque_iterator&lt;&gt;::operator--</span></span><br><span class="line">    <span class="keyword">return</span> *tmp;    <span class="comment">// 调用 __deque_iterator&lt;&gt;::operator*</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> finish - start; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上调用iterator::operator-</span></span><br><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> finish == start; &#125;</span><br></pre></td></tr></table></figure>



<h4 id="deque的构造与内存管理"><a href="#deque的构造与内存管理" class="headerlink" title="deque的构造与内存管理"></a>deque的构造与内存管理</h4><h5 id="deque的ctor"><a href="#deque的ctor" class="headerlink" title="deque的ctor"></a>deque的ctor</h5><p>deque自行定义了两个空间配置器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:                      <span class="comment">// Internal typedefs</span></span><br><span class="line"><span class="comment">// 专属之空间配置器，每次配置一个元素大小</span></span><br><span class="line"><span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line"><span class="comment">// 专属之空间配置器，每次配置一个指标大小</span></span><br><span class="line"><span class="keyword">typedef</span> simple_alloc&lt;pointer, Alloc&gt; map_allocator;</span><br></pre></td></tr></table></figure>

<p>并有如下构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>(size_type n, <span class="type">const</span> value_type&amp; value)</span><br><span class="line">  : <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fill_initialize</span>(n, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fill_initialize()负责产生并安排好deque的结构，并将元素的初值设置好：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">fill_initialize</span>(size_type n,</span><br><span class="line">                                               <span class="type">const</span> value_type&amp; value) &#123;</span><br><span class="line">    <span class="built_in">create_map_and_nodes</span>(n);	 <span class="comment">// 把deque的结构都产生并安排好</span></span><br><span class="line">    map_pointer cur;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">            <span class="comment">// 为每个节点的缓冲区設定初值</span></span><br><span class="line">            <span class="keyword">for</span> (cur = start.node; cur &lt; finish.node; ++cur)</span><br><span class="line">            <span class="built_in">uninitialized_fill</span>(*cur, *cur + <span class="built_in">buffer_size</span>(), value);</span><br><span class="line">            <span class="comment">// 最后一个节点的设定稍有不同（因为尾端可能有备用空间，不必设初值）</span></span><br><span class="line">            <span class="built_in">uninitialized_fill</span>(finish.first, finish.cur, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">    <span class="comment">// &quot;commit or rollback&quot; ：若非全部成功，就一个不留。</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其中create_map_and_nodes()复制产生并安排好deque的结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">create_map_and_nodes</span>(size_type num_elements) &#123;</span><br><span class="line">    <span class="comment">// 需要节点数=(元素个数/每个缓冲区可容纳的元素个数)+1</span></span><br><span class="line">    <span class="comment">// 如果刚好整除，會多配一个节点。</span></span><br><span class="line">    size_type num_nodes = num_elements / <span class="built_in">buffer_size</span>() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个 map 要管理几个节点。最少8个，最多是 “所需节点数加2”</span></span><br><span class="line">    <span class="comment">// （前后各預留一个，扩充時可用）。</span></span><br><span class="line">    map_size = <span class="built_in">max</span>(<span class="built_in">initial_map_size</span>(), num_nodes + <span class="number">2</span>);</span><br><span class="line">    map = map_allocator::<span class="built_in">allocate</span>(map_size);</span><br><span class="line">    <span class="comment">// 以上配置出一个 “具有 map_size个节点” 的map。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下令nstart和nfinish指向map所拥有之全部节点的最中央区段。</span></span><br><span class="line">    <span class="comment">// 保持在最中央，可使头尾两端的扩充能量一样大。每个节点可对应一个缓冲区。</span></span><br><span class="line">    map_pointer nstart = map + (map_size - num_nodes) / <span class="number">2</span>;</span><br><span class="line">    map_pointer nfinish = nstart + num_nodes - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    map_pointer cur;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">            <span class="comment">// 为map內的每个現用节点配置缓冲区。所有缓冲区加起来就是deque的空间</span></span><br><span class="line">            <span class="comment">// （最后一个缓冲区可能留有一些余裕）。</span></span><br><span class="line">            <span class="keyword">for</span> (cur = nstart; cur &lt;= nfinish; ++cur)</span><br><span class="line">            *cur = <span class="built_in">allocate_node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">    <span class="comment">// &quot;commit or rollback&quot; ：若非全部成功，就一个不留。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 为deque内的两个迭代器start和end 設定正确的内容。</span></span><br><span class="line">  start.<span class="built_in">set_node</span>(nstart);</span><br><span class="line">  finish.<span class="built_in">set_node</span>(nfinish);</span><br><span class="line">  start.cur = start.first;		<span class="comment">// first, cur都是public</span></span><br><span class="line">  finish.cur = finish.first + num_elements % <span class="built_in">buffer_size</span>();</span><br><span class="line">  <span class="comment">// 前面说过，如果刚好整除，会多配一个节点。</span></span><br><span class="line">  <span class="comment">// 此时即令cur指向這多配的一個节点（所对应之缓冲区）的起点。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="push-back-amp-push-front"><a href="#push-back-amp-push-front" class="headerlink" title="push_back() &amp; push_front()"></a>push_back() &amp; push_front()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:                         <span class="comment">// push_* and pop_*</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> value_type&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish.cur != finish.last - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 最后缓冲区尚有一个以上的备用空间</span></span><br><span class="line">        <span class="built_in">construct</span>(finish.cur, t);	<span class="comment">// 直接在备用空间上建构元素</span></span><br><span class="line">        ++finish.cur;	<span class="comment">// 調整最后缓冲区的使用状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 最后缓冲区已无（或只剩一个）元素备用空间。</span></span><br><span class="line">        <span class="built_in">push_back_aux</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尾端只有一个元素备用空间时，push_back调用push_back_aux()，先设置一整块的buffer，再设置新元素内容，然后更改finish：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有当 finish.cur == finish.last – 1 时才会被呼叫。</span></span><br><span class="line"><span class="comment">// 也就是说只有当最后一个缓冲区只剩一个备用元素空間时才会被呼叫。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">push_back_aux</span>(<span class="type">const</span> value_type&amp; t) &#123;</span><br><span class="line">    value_type t_copy = t;</span><br><span class="line">    <span class="built_in">reserve_map_at_back</span>();		<span class="comment">//  若符合某种条件則必須重换一个map</span></span><br><span class="line">    *(finish.node + <span class="number">1</span>) = <span class="built_in">allocate_node</span>();	<span class="comment">// 配置一个新节点（缓冲区）</span></span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">            <span class="built_in">construct</span>(finish.cur, t_copy);		<span class="comment">// 设值</span></span><br><span class="line">            finish.<span class="built_in">set_node</span>(finish.node + <span class="number">1</span>);	<span class="comment">// 改变finish，令其指向新节点</span></span><br><span class="line">            finish.cur = finish.first;			<span class="comment">// 設定 finish 的状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">deallocate_node</span>(*(finish.node + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>push_front()和push_back()同理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> value_type&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start.cur != start.first) &#123; 	<span class="comment">// 第一缓冲区尚有备用空間</span></span><br><span class="line">        <span class="built_in">construct</span>(start.cur - <span class="number">1</span>, t); 	<span class="comment">// 直接在备用空間上建构元素</span></span><br><span class="line">        --start.cur;		<span class="comment">// 调整第一缓冲区的使用状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 第一缓冲区已无备用空間</span></span><br><span class="line">        <span class="built_in">push_front_aux</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有当start.cur == start.first時才会被呼叫。</span></span><br><span class="line"><span class="comment">// 也就是说只有当第一个缓冲区沒有任何备用元素時才会被呼叫。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">push_front_aux</span>(<span class="type">const</span> value_type&amp; t) &#123;</span><br><span class="line">    value_type t_copy = t;</span><br><span class="line">    <span class="built_in">reserve_map_at_front</span>();		<span class="comment">//  若符合某种条件則必須重换一个map</span></span><br><span class="line">    *(start.node - <span class="number">1</span>) = <span class="built_in">allocate_node</span>();	<span class="comment">// 配置一个新节点（缓冲区）</span></span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">            start.<span class="built_in">set_node</span>(start.node - <span class="number">1</span>);		<span class="comment">// 改变start，令其指向新节点</span></span><br><span class="line">            start.cur = start.last - <span class="number">1</span>;			<span class="comment">// 设定 start的状态</span></span><br><span class="line">            <span class="built_in">construct</span>(start.cur, t_copy);		<span class="comment">// 设值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">    <span class="comment">// &quot;commit or rollback&quot; ：若非全部成功，就一个不留。</span></span><br><span class="line">        start.<span class="built_in">set_node</span>(start.node + <span class="number">1</span>);</span><br><span class="line">        start.cur = start.first;</span><br><span class="line">        <span class="built_in">deallocate_node</span>(*(start.node - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，整治map的操作reserve_map_at_back()和reserve_map_at_front()为调用reallocate_map()：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve_map_at_back</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes_to_add + <span class="number">1</span> &gt; map_size - (finish.node - map))</span><br><span class="line">        <span class="comment">// 如果 map 尾端的节点备用空间不足</span></span><br><span class="line">        <span class="comment">// 符合以上条件則必須重换一个map（配置更大的，拷贝原來的，释放原來的）</span></span><br><span class="line">        <span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve_map_at_front</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes_to_add &gt; start.node - map)</span><br><span class="line">        <span class="comment">// 如果 map 前端的节点备用空间不足</span></span><br><span class="line">        <span class="comment">// 符合以上条件則必須重换一个map（配置更大的，拷贝原來的，释放原來的）</span></span><br><span class="line">        <span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>reallocate_map()函数实现为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">reallocate_map</span>(size_type nodes_to_add,</span><br><span class="line">                                              <span class="type">bool</span> add_at_front) &#123;</span><br><span class="line">    size_type old_num_nodes = finish.node - start.node + <span class="number">1</span>;</span><br><span class="line">    size_type new_num_nodes = old_num_nodes + nodes_to_add;</span><br><span class="line"></span><br><span class="line">    map_pointer new_nstart;</span><br><span class="line">    <span class="keyword">if</span> (map_size &gt; <span class="number">2</span> * new_num_nodes) &#123;</span><br><span class="line">        new_nstart = map + (map_size - new_num_nodes) / <span class="number">2</span></span><br><span class="line">                     + (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (new_nstart &lt; start.node)</span><br><span class="line">            <span class="built_in">copy</span>(start.node, finish.node + <span class="number">1</span>, new_nstart);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">copy_backward</span>(start.node, finish.node + <span class="number">1</span>, new_nstart + old_num_nodes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        size_type new_map_size = map_size + <span class="built_in">max</span>(map_size, nodes_to_add) + <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 配置一块空間，准备给新map使用。</span></span><br><span class="line">        map_pointer new_map = map_allocator::<span class="built_in">allocate</span>(new_map_size);</span><br><span class="line">        new_nstart = new_map + (new_map_size - new_num_nodes) / <span class="number">2</span></span><br><span class="line">                     + (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 把原map 內容拷贝过来。</span></span><br><span class="line">        <span class="built_in">copy</span>(start.node, finish.node + <span class="number">1</span>, new_nstart);</span><br><span class="line">        <span class="comment">// 释放原map</span></span><br><span class="line">        map_allocator::<span class="built_in">deallocate</span>(map, map_size);</span><br><span class="line">        <span class="comment">// 设定新map的起始位址与大小</span></span><br><span class="line">        map = new_map;</span><br><span class="line">        map_size = new_map_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新设定迭代器 start 和 finish</span></span><br><span class="line">    start.<span class="built_in">set_node</span>(new_nstart);</span><br><span class="line">    finish.<span class="built_in">set_node</span>(new_nstart + old_num_nodes - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="deque的元素操作"><a href="#deque的元素操作" class="headerlink" title="deque的元素操作"></a>deque的元素操作</h4><h5 id="pop-back-amp-pop-front"><a href="#pop-back-amp-pop-front" class="headerlink" title="pop_back() &amp; pop_front()"></a>pop_back() &amp; pop_front()</h5><p>pop操作和push操作相反，pop是要把元素拿掉，push需要考虑加入buffer，而pop则需要考虑释放buffer。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish.cur != finish.first) &#123;</span><br><span class="line">        <span class="comment">// 最后缓冲区有一个（或更多）元素</span></span><br><span class="line"></span><br><span class="line">        --finish.cur;		<span class="comment">// 调整指标，相当于排除了最后元素</span></span><br><span class="line">        <span class="built_in">destroy</span>(finish.cur);	<span class="comment">// 将最后元素析构</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 最后缓冲区没有任何元素</span></span><br><span class="line">        <span class="built_in">pop_back_aux</span>();		<span class="comment">// 這里将进行缓冲区的释放工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有当finish.cur == finish.first时才會被呼叫。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">pop_back_aux</span>() &#123;</span><br><span class="line">    <span class="built_in">deallocate_node</span>(finish.first);	<span class="comment">// 释放最后一个缓冲区</span></span><br><span class="line">    finish.<span class="built_in">set_node</span>(finish.node - <span class="number">1</span>);	<span class="comment">// 调整 finish 的状态，使指向</span></span><br><span class="line">    finish.cur = finish.last - <span class="number">1</span>;		<span class="comment">//  上一个缓冲区的最后一个元素</span></span><br><span class="line">    <span class="built_in">destroy</span>(finish.cur);				<span class="comment">// 将该元素析构。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start.cur != start.last - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一缓冲区有一个（或更多）元素</span></span><br><span class="line">        <span class="built_in">destroy</span>(start.cur);	<span class="comment">// 将第一元素析构</span></span><br><span class="line">        ++start.cur;			<span class="comment">// 调整指标，相当于排除了第一元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 第一缓冲区僅有一个元素</span></span><br><span class="line">        <span class="built_in">pop_front_aux</span>();		<span class="comment">// 這里将进行缓冲区的释放工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有当start.cur == start.last - 1时才會被呼叫。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">pop_front_aux</span>() &#123;</span><br><span class="line">    <span class="built_in">destroy</span>(start.cur);				<span class="comment">// 将第一缓冲区的第一个元素析构。</span></span><br><span class="line">    <span class="built_in">deallocate_node</span>(start.first);		<span class="comment">// 释放第一缓冲区。</span></span><br><span class="line">    start.<span class="built_in">set_node</span>(start.node + <span class="number">1</span>);	<span class="comment">// 调整 start 的状态，使指向</span></span><br><span class="line">    start.cur = start.first;			<span class="comment">//  下一个缓冲区的第一个元素。</span></span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>



<h5 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h5><p>clear()用于清空deque，deque在初始的时候有一个buffer，因此clear之后，也应该有一个buffer。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，最終需要保留一個緩衝區。這是deque 的策略，也是deque 的初始狀態。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">clear</span>() &#123;</span><br><span class="line">    <span class="comment">// 以下針對頭尾以外的每一個緩衝區（它們一定都是飽滿的）</span></span><br><span class="line">    <span class="keyword">for</span> (map_pointer node = start.node + <span class="number">1</span>; node &lt; finish.node; ++node) &#123;</span><br><span class="line">        <span class="comment">// 將緩衝區內的所有元素解構。注意，呼叫的是destroy() 第二版本，見2.2.3節</span></span><br><span class="line">        <span class="built_in">destroy</span>(*node, *node + <span class="built_in">buffer_size</span>());</span><br><span class="line">        <span class="comment">// 釋放緩衝區記憶體</span></span><br><span class="line">        data_allocator::<span class="built_in">deallocate</span>(*node, <span class="built_in">buffer_size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start.node != finish.node) &#123;	<span class="comment">// 至少有頭尾兩個緩衝區</span></span><br><span class="line">        <span class="built_in">destroy</span>(start.cur, start.last);	<span class="comment">// 將頭緩衝區的目前所有元素解構</span></span><br><span class="line">        <span class="built_in">destroy</span>(finish.first, finish.cur); <span class="comment">// 將尾緩衝區的目前所有元素解構</span></span><br><span class="line">        <span class="comment">// 以下釋放尾緩衝區。注意，頭緩衝區保留。</span></span><br><span class="line">        data_allocator::<span class="built_in">deallocate</span>(finish.first, <span class="built_in">buffer_size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">// 只有一個緩衝區</span></span><br><span class="line">        <span class="built_in">destroy</span>(start.cur, finish.cur);	<span class="comment">// 將此唯一緩衝區內的所有元素解構</span></span><br><span class="line">    <span class="comment">// 注意，並不釋放緩衝區空間。這唯一的緩衝區將保留。</span></span><br><span class="line"></span><br><span class="line">    finish = start;	<span class="comment">// 調整狀態</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="erase"><a href="#erase" class="headerlink" title="erase()"></a>erase()</h5><p>erase()函数可以清除一个iterator的内容，也可以清除一个范围的内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除 pos 所指的元素。pos 為清除點。</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span> </span>&#123;</span><br><span class="line">    iterator next = pos;</span><br><span class="line">    ++next;</span><br><span class="line">    difference_type index = pos - start;    <span class="comment">// 清除點之前的元素個數</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>)) &#123;            <span class="comment">// 如果清除點之前的元素比較少，</span></span><br><span class="line">        <span class="built_in">copy_backward</span>(start, pos, next);    <span class="comment">// 就搬移清除點之前的元素</span></span><br><span class="line">        <span class="built_in">pop_front</span>();                <span class="comment">// 搬移完畢，最前一個元素贅餘，去除之</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// 清除點之後的元素比較少，</span></span><br><span class="line">        <span class="built_in">copy</span>(next, finish, pos);    <span class="comment">// 就搬移清除點之後的元素</span></span><br><span class="line">        <span class="built_in">pop_back</span>();                <span class="comment">// 搬移完畢，最後一個元素贅餘，去除之</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start + index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::iterator deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">erase</span>(iterator first, iterator last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (first == start &amp;&amp; last == finish) &#123; <span class="comment">// 如果清除區間就是整個 deque</span></span><br><span class="line">        <span class="built_in">clear</span>();                            <span class="comment">// 直接呼叫 clear() 即可</span></span><br><span class="line">        <span class="keyword">return</span> finish;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        difference_type n = last - first;            <span class="comment">// 清除區間的長度</span></span><br><span class="line">        difference_type elems_before = first - start;    <span class="comment">// 清除區間前方的元素個數</span></span><br><span class="line">        <span class="keyword">if</span> (elems_before &lt; (<span class="built_in">size</span>() - n) / <span class="number">2</span>) &#123;        <span class="comment">// 如果前方的元素比較少，</span></span><br><span class="line">            <span class="built_in">copy_backward</span>(start, first, last);        <span class="comment">// 向後搬移前方元素（覆蓋清除區間）</span></span><br><span class="line">            iterator new_start = start + n;            <span class="comment">// 標記 deque 的新起點</span></span><br><span class="line">            <span class="built_in">destroy</span>(start, new_start);                <span class="comment">// 搬移完畢，將贅餘的元素解構</span></span><br><span class="line"><span class="comment">// 以下將贅餘的緩衝區釋放</span></span><br><span class="line">            <span class="keyword">for</span> (map_pointer cur = start.node; cur &lt; new_start.node; ++cur)</span><br><span class="line">                data_allocator::<span class="built_in">deallocate</span>(*cur, <span class="built_in">buffer_size</span>());</span><br><span class="line">            start = new_start;    <span class="comment">// 設定 deque 的新起點</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 如果清除區間後方的元素比較少</span></span><br><span class="line">            <span class="built_in">copy</span>(last, finish, first);            <span class="comment">// 向前搬移後方元素（覆蓋清除區間）</span></span><br><span class="line">            iterator new_finish = finish - n;    <span class="comment">// 標記 deque 的新尾點</span></span><br><span class="line">            <span class="built_in">destroy</span>(new_finish, finish);        <span class="comment">// 搬移完畢，將贅餘的元素解構</span></span><br><span class="line"><span class="comment">// 以下將贅餘的緩衝區釋放</span></span><br><span class="line">            <span class="keyword">for</span> (map_pointer cur = new_finish.node + <span class="number">1</span>; cur &lt;= finish.node; ++cur)</span><br><span class="line">                data_allocator::<span class="built_in">deallocate</span>(*cur, <span class="built_in">buffer_size</span>());</span><br><span class="line">            finish = new_finish;    <span class="comment">// 設定 deque 的新尾點</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start + elems_before;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h5><p>insert()功能：在某一点之前插入一个元素，并设定其值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在position 處安插一個元素，其值為 x</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> value_type &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position.cur == start.cur) &#123;    <span class="comment">// 如果安插點是deque 最前端</span></span><br><span class="line">        <span class="built_in">push_front</span>(x);                <span class="comment">// 交給push_front 去做</span></span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur) &#123; <span class="comment">// 如果安插點是deque 最尾端</span></span><br><span class="line">        <span class="built_in">push_back</span>(x);                      <span class="comment">// 交給push_back 去做</span></span><br><span class="line">        iterator tmp = finish;</span><br><span class="line">        --tmp;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_aux</span>(position, x);        <span class="comment">// 交給 insert_aux 去做</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="keyword">typename</span> deque&lt;T, Alloc, BufSize&gt;::iterator</span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert_aux</span>(iterator pos, <span class="type">const</span> value_type &amp;x) &#123;</span><br><span class="line">    difference_type index = pos - start;    <span class="comment">// 安插點之前的元素個數</span></span><br><span class="line">    value_type x_copy = x;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="built_in">size</span>() / <span class="number">2</span>) &#123;            <span class="comment">// 如果安插點之前的元素個數比較少</span></span><br><span class="line">        <span class="built_in">push_front</span>(<span class="built_in">front</span>());            <span class="comment">// 在最前端加入與第一元素同值的元素。</span></span><br><span class="line">        iterator front1 = start;        <span class="comment">// 以下標示記號，然後進行元素搬移...</span></span><br><span class="line">        ++front1;</span><br><span class="line">        iterator front2 = front1;</span><br><span class="line">        ++front2;</span><br><span class="line">        pos = start + index;</span><br><span class="line">        iterator pos1 = pos;</span><br><span class="line">        ++pos1;</span><br><span class="line">        <span class="built_in">copy</span>(front2, pos1, front1);        <span class="comment">// 元素搬移</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                        <span class="comment">// 安插點之後的元素個數比較少</span></span><br><span class="line">        <span class="built_in">push_back</span>(<span class="built_in">back</span>());            <span class="comment">// 在最尾端加入與最後元素同值的元素。</span></span><br><span class="line">        iterator back1 = finish;    <span class="comment">// 以下標示記號，然後進行元素搬移...</span></span><br><span class="line">        --back1;</span><br><span class="line">        iterator back2 = back1;</span><br><span class="line">        --back2;</span><br><span class="line">        pos = start + index;</span><br><span class="line">        <span class="built_in">copy_backward</span>(pos, back2, back1);    <span class="comment">// 元素搬移</span></span><br><span class="line">    &#125;</span><br><span class="line">    *pos = x_copy;    <span class="comment">// 在安插點上設定新值</span></span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-05T15:01:10.000Z" title="3/5/2023, 11:01:10 PM">2023-03-05</time>发表</span><span class="level-item"><time dateTime="2023-03-05T15:13:26.417Z" title="3/5/2023, 11:13:26 PM">2023-03-05</time>更新</span><span class="level-item">5 分钟读完 (大约744个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/03/05/stl-priority-queue/">STL - 番外2 优先队列默认是大根堆？</a></p><div class="content"><p>stl中默认堆为大根堆，大根堆的定义为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br></pre></td></tr></table></figure>

<p>根据源码中的定义，有如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Container</span> = vector&lt;_Tp&gt;,</span><br><span class="line">          <span class="keyword">class</span> _Compare = less&lt;<span class="keyword">typename</span> _Container::value_type&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> _LIBCPP_TEMPLATE_VIS priority_queue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Container                               container_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Compare                                 value_compare;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> container_type::value_type      value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> container_type::reference       reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> container_type::size_type       size_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    container_type c;</span><br><span class="line">    value_compare comp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从最开头我们可以看出，声明优先队列时，第一参数为类型，第二参数为容器，第三参数为比较函数（默认小于）。</p>
<p>那么问题来了，为什么默认的这个cmp仿函数为小于的堆，是个大根堆（堆顶元素为最大值）？</p>
<p>建堆时都是一步步push()的，查看源码，可以看到如下函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类里边的声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(value_type&amp;&amp; __v)</span></span>;</span><br><span class="line"><span class="comment">// push实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>, <span class="keyword">class</span> <span class="title class_">_Container</span>, <span class="keyword">class</span> <span class="title class_">_Compare</span>&gt;</span><br><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">priority_queue&lt;_Tp, _Container, _Compare&gt;::<span class="built_in">push</span>(value_type&amp;&amp; __v)</span><br><span class="line">&#123;</span><br><span class="line">    c.<span class="built_in">push_back</span>(_VSTD::<span class="built_in">move</span>(__v));</span><br><span class="line">    _VSTD::<span class="built_in">push_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码可以看出，优先队列的push操作就是往容器内push_back一个数，然后执行一个push_heap()操作。</p>
<p>查看push_heap()操作，可以看到如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title class_">_Compare</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">push_heap</span><span class="params">(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __comp_ref_type&lt;_Compare&gt;::type _Comp_ref;</span><br><span class="line">    __sift_up&lt;_Comp_ref&gt;(__first, __last, __comp, __last - __first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其又掉用了__sift_up()函数，学过堆的小伙伴应该对这个up操作十分熟悉吧！</p>
<p>__sift_up()函数实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Compare</span>, <span class="keyword">class</span> <span class="title class_">_RandomAccessIterator</span>&gt;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,</span><br><span class="line">          <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::difference_type __len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;_RandomAccessIterator&gt;::value_type value_type;</span><br><span class="line">    <span class="keyword">if</span> (__len &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ((__len - 1) -1) / 2;</span></span><br><span class="line">        __len = (__len - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">        _RandomAccessIterator __ptr = __first + __len;</span><br><span class="line">        <span class="keyword">if</span> (__comp(*__ptr, *--__last))</span><br><span class="line">        &#123;</span><br><span class="line">            value_type <span class="type">__t</span>(_VSTD::<span class="built_in">move</span>(*__last));</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                *__last = _VSTD::<span class="built_in">move</span>(*__ptr);</span><br><span class="line">                __last = __ptr;</span><br><span class="line">                <span class="keyword">if</span> (__len == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                __len = (__len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                __ptr = __first + __len;</span><br><span class="line">            &#125; <span class="keyword">while</span> (__comp(*__ptr, <span class="type">__t</span>));</span><br><span class="line">            *__last = _VSTD::<span class="built_in">move</span>(<span class="type">__t</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;_Tp&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(_Tp&amp;&amp; <span class="type">__t</span>)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE <span class="keyword">typename</span> remove_reference&lt;_Tp&gt;::type _Up;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Up&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从__sift_up()函数的代码我们可以看出：这个cmp仿函数时一直传进来了的，而且是根据</p>
<p>__comp(*__ptr, __t)一直在执行某操作的。</p>
<p>这里就要涉及到heap的up操作了。</p>
<p>heap的up，简而言之，就是把元素和他的父亲节点（&#x2F;2便是父亲节点，完全二叉树性质）比较，如果符合某性质，就将该节点上移。</p>
<p>以上源码类似于如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> sift-<span class="built_in">up</span> ( MaxHeap H)</span><br><span class="line">&#123;</span><br><span class="line">    i = H-&gt;size;</span><br><span class="line">    item = H-&gt;Element [i];</span><br><span class="line">    <span class="keyword">for</span> ( ; H -&gt; Element [ i/<span class="number">2</span> ] &lt; item; i /= <span class="number">2</span> ) <span class="comment">// 与父结点做比较，i / 2 表示的就是父结点的下标</span></span><br><span class="line">    &#123;</span><br><span class="line">            H -&gt; Element [ i ] = H -&gt; Element [ i/<span class="number">2</span> ]; <span class="comment">// 向下过滤结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    H -&gt; Element [ i ] = item ; <span class="comment">//若for循环完成后,i更新为父节点i，然后将 item 插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于less的话，就是满足小于，则将节点上移，这样就形成了一个大根堆。</p>
<p>所以大小根堆可以以以下方式声明。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大根堆   </span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"><span class="comment">// 小根堆   </span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-05T14:52:52.000Z" title="3/5/2023, 10:52:52 PM">2023-03-05</time>发表</span><span class="level-item"><time dateTime="2023-03-05T15:14:00.432Z" title="3/5/2023, 11:14:00 PM">2023-03-05</time>更新</span><span class="level-item">5 分钟读完 (大约784个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/03/05/cpp-virtual-function/">CPP - 虚函数指针和虚函数表</a></p><div class="content"><h4 id="虚函数指针和虚函数表"><a href="#虚函数指针和虚函数表" class="headerlink" title="虚函数指针和虚函数表"></a>虚函数指针和虚函数表</h4><h5 id="虚函数表的定义"><a href="#虚函数表的定义" class="headerlink" title="虚函数表的定义"></a>虚函数表的定义</h5><p>多态是由虚函数实现的，而虚函数主要是通过<strong>虚函数表（V-Table）</strong>来实现的。</p>
<p>如果一个类中包含虚函数（virtual修饰的函数），那么这个类就会包含一张虚函数表(vftbl)，虚函数表存储的每一项是一个虚函数的地址。在一个对象的内存布局中，指向这张虚函数表的指针（vfptr）位于最前端。如下图：</p>
<p><img src="/2023/03/05/cpp-virtual-function/1659233-20210529214535575-66863680.jpg"></p>
<h5 id="一般继承（无虚函数覆盖）"><a href="#一般继承（无虚函数覆盖）" class="headerlink" title="一般继承（无虚函数覆盖）"></a>一般继承（无虚函数覆盖）</h5><p>对于如下UML的类：在普通继承情况，派生类没有重写基类的虚函数：</p>
<p><img src="/2023/03/05/cpp-virtual-function/1659233-20210529214529855-1319163568.jpg"></p>
<p>体现在代码上为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base:f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base:g()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base:h()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derive:f1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derive:g1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derive:h1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base base;</span><br><span class="line">    Derive derive;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用lldb查看虚函数指针和虚函数表内容：</p>
<p><img src="/2023/03/05/cpp-virtual-function/1659233-20210529214524333-1044247564.png"></p>
<p>根据结果，可以得知其虚函数表如下图：</p>
<p><img src="/2023/03/05/cpp-virtual-function/1659233-20210529214510752-1056469631.jpg"></p>
<h5 id="一般继承（有虚函数覆盖）"><a href="#一般继承（有虚函数覆盖）" class="headerlink" title="一般继承（有虚函数覆盖）"></a>一般继承（有虚函数覆盖）</h5><p>对于如下UML的类：在普通继承情况，派生类重写了基类的虚函数( f() )：</p>
<p><img src="/2023/03/05/cpp-virtual-function/1659233-20210529214501516-1620662059.jpg"></p>
<p>代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base:f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base:g()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base:h()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derive:f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derive:g1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derive:h1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base base;</span><br><span class="line">    Derive derive;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<p><img src="/2023/03/05/cpp-virtual-function/1659233-20210529214451208-554007163.png"></p>
<p>绘制成图，为：</p>
<p><img src="/2023/03/05/cpp-virtual-function/1659233-20210529214438504-170009018.jpg"></p>
<h5 id="多重继承（无虚函数覆盖）"><a href="#多重继承（无虚函数覆盖）" class="headerlink" title="多重继承（无虚函数覆盖）"></a>多重继承（无虚函数覆盖）</h5><p>对于如下UML的类：在多重继承情况，派生类没有重写了基类的虚函数：</p>
<p><img src="/2023/03/05/cpp-virtual-function/1659233-20210529214428962-1738869780.jpg"></p>
<p>代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base1:f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base1:g()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base1:h()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base2:f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base2:g()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base2:h()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base3:f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base3:g()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base3:h()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derive:f1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derive:g1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derive derive;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为：</p>
<p><img src="/2023/03/05/cpp-virtual-function/1659233-20210529214403872-353357540.png"></p>
<p>绘制成图，为：</p>
<p><img src="/2023/03/05/cpp-virtual-function/1659233-20210529214416210-180872272.jpg"></p>
<h5 id="多重继承（有虚函数覆盖）"><a href="#多重继承（有虚函数覆盖）" class="headerlink" title="多重继承（有虚函数覆盖）"></a>多重继承（有虚函数覆盖）</h5><p>对于如下UML的类：在多重继承情况，派生类没有重写了基类的虚函数：</p>
<p><img src="/2023/03/05/cpp-virtual-function/1659233-20210529214318267-1810262328.jpg"></p>
<p>代码为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base1:f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base1:g()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base1:h()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base2:f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base2:g()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base2:h()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base3:f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base3:g()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base3:h()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derive:f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derive:g1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derive derive;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果为：</p>
<p><img src="/2023/03/05/cpp-virtual-function/1659233-20210529214245967-62727916.png"></p>
<p>绘制成图，为：</p>
<p><img src="/2023/03/05/cpp-virtual-function/1659233-20210529214257465-1080274430.jpg"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-05T14:50:30.000Z" title="3/5/2023, 10:50:30 PM">2023-03-05</time>发表</span><span class="level-item"><time dateTime="2023-03-05T15:14:02.501Z" title="3/5/2023, 11:14:02 PM">2023-03-05</time>更新</span><span class="level-item">6 分钟读完 (大约931个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/03/05/cpp-stack-unwinding/">CPP - 栈展开(stack unwinding)</a></p><div class="content"><h1 id="栈展开（stack-unwinding）的定义"><a href="#栈展开（stack-unwinding）的定义" class="headerlink" title="栈展开（stack unwinding）的定义"></a>栈展开（stack unwinding）的定义</h1><p>抛出异常时，将暂停当前函数的执行，开始查找匹配的 <code>catch</code> 子句。首先检查 <code>throw</code> 本身是否在 <code>try</code> 块内部，如果是，检查与该 <code>try</code> 相关的 <code>catch</code> 子句，看是否可以处理该异常。如果不能处理，就退出当前函数，并且释放当前函数的内存并销毁局部对象，继续到上层的调用函数中查找，直到找到一个可以处理该异常的 <code>catch</code> 。这个过程称为<strong>栈展开（stack unwinding）</strong>。当处理该异常的 <code>catch</code> 结束之后，紧接着该 <code>catch</code> 之后的点继续执行。</p>
<ol>
<li><p>为局部对象调用析构函数</p>
<p>在栈展开的过程中，会释放局部对象所占用的内存并运行类类型局部对象的析构函数。但需要注意的是，如果一个块通过 <code>new</code> 动态分配内存，并且在释放该资源之前发生异常，该块因异常而退出，那么在栈展开期间不会释放该资源，编译器不会删除该指针，这样就会造成内存泄露。</p>
</li>
<li><p>析构函数应该从不抛出异常</p>
<p>在为某个异常进行栈展开的时候，析构函数如果又抛出自己的未经处理的另一个异常，将会导致调用标准库 <code>terminate</code> 函数。通常 <code>terminate</code> 函数将调用 <code>abort</code> 函数，导致程序的非正常退出。所以析构函数应该从不抛出异常。</p>
</li>
<li><p>异常与构造函数</p>
<p>如果在构造函数对象时发生异常，此时该对象可能只是被部分构造，要保证能够适当的撤销这些已构造的成员。</p>
</li>
<li><p>未捕获的异常将会终止程序</p>
<p>不能不处理异常。如果找不到匹配的catch，程序就会调用库函数<code>terminate</code>。</p>
</li>
</ol>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dummy</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Dummy</span>(string s) : <span class="built_in">MyName</span>(s) &#123; <span class="built_in">PrintMsg</span>(<span class="string">&quot;Created Dummy:&quot;</span>); &#125;</span><br><span class="line">    <span class="comment">// 拷贝构造</span></span><br><span class="line">    <span class="built_in">Dummy</span>(<span class="type">const</span> Dummy&amp; other) : <span class="built_in">MyName</span>(other.MyName)&#123; <span class="built_in">PrintMsg</span>(<span class="string">&quot;Copy created Dummy:&quot;</span>); &#125;</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Dummy</span>()&#123; <span class="built_in">PrintMsg</span>(<span class="string">&quot;Destroyed Dummy:&quot;</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintMsg</span><span class="params">(string s)</span> </span>&#123; cout &lt;&lt; s  &lt;&lt; MyName &lt;&lt;  endl; &#125;</span><br><span class="line">    string MyName;</span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">C</span><span class="params">(Dummy d, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Entering Function C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    d.MyName = <span class="string">&quot; C&quot;</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Exiting Function C&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B</span><span class="params">(Dummy d, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Entering Function B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    d.MyName = <span class="string">&quot; B&quot;</span>;</span><br><span class="line">    <span class="built_in">C</span>(d, i + <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Exiting Function B&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A</span><span class="params">(Dummy d, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Entering Function A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    d.MyName = <span class="string">&quot; A&quot;</span> ;</span><br><span class="line">  <span class="comment">//  Dummy* pd = new Dummy(&quot;new Dummy&quot;); //Not exception safe!!!</span></span><br><span class="line">    <span class="built_in">B</span>(d, i + <span class="number">1</span>);</span><br><span class="line"> <span class="comment">//   delete pd;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Exiting FunctionA&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Entering main&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function">Dummy <span class="title">d</span><span class="params">(<span class="string">&quot; M&quot;</span>)</span></span>;</span><br><span class="line">        <span class="built_in">A</span>(d,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (MyException&amp; e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Caught an exception of type: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(e).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Exiting main.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>进行编译，运行，可得到如下结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ g++ stack_unwinding.cpp -o stack_test -std=c++11</span><br><span class="line"></span><br><span class="line">$ ./stack_test                                    </span><br><span class="line">Entering main</span><br><span class="line">Created Dummy: M</span><br><span class="line">Copy created Dummy: M</span><br><span class="line">Entering Function A</span><br><span class="line">Copy created Dummy: A</span><br><span class="line">Entering Function B</span><br><span class="line">Copy created Dummy: B</span><br><span class="line">Entering Function C</span><br><span class="line">Destroyed Dummy: C</span><br><span class="line">Destroyed Dummy: B</span><br><span class="line">Destroyed Dummy: A</span><br><span class="line">Destroyed Dummy: M</span><br><span class="line">Caught an exception of <span class="built_in">type</span>: 11MyException</span><br><span class="line">Exiting main.</span><br></pre></td></tr></table></figure>

<p>程序运行时对应栈的内容如下图所示：</p>
<p><img src="/2023/03/05/cpp-stack-unwinding/image-20211025141032175.png" alt="image"></p>
<p>程序执行将从 <code>C</code> 中的 throw 语句跳转到 <code>main</code> 中的 catch 语句，并在此过程中展开每个函数。 </p>
<ol>
<li>根据创建 <code>Dummy</code> 对象的顺序，在它们超出范围时将其<strong>销毁</strong>。</li>
<li>除了包含 catch 语句的 <code>main</code> 之外，其他函数均未完成。</li>
<li>函数 <code>A</code> 绝不会从其对 <code>B()</code> 的调用返回，并且 <code>B</code> 绝不会从其对 <code>C()</code> 的调用返回。</li>
</ol>
<h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><p>[1] <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/cpp/exceptions-and-stack-unwinding-in-cpp?view=msvc-160">microsoft C++文档</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhuyf87/archive/2012/12/23/2829725.html">抛出异常与栈展开（stack unwinding）</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-05T14:14:17.000Z" title="3/5/2023, 10:14:17 PM">2023-03-05</time>发表</span><span class="level-item"><time dateTime="2023-03-05T15:14:26.765Z" title="3/5/2023, 11:14:26 PM">2023-03-05</time>更新</span><span class="level-item">10 分钟读完 (大约1461个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/03/05/cmu-15445-lab1/">CMU15445 - lab1</a></p><div class="content"><hr>
<p>本文为本人完成15445 2020fall（B+树版本）时的一些记录，仅作为备忘录使用。</p>
<hr>
<h2 id="TASK-1-LRU-REPLACEMENT-POLICY"><a href="#TASK-1-LRU-REPLACEMENT-POLICY" class="headerlink" title="TASK #1 - LRU REPLACEMENT POLICY"></a>TASK #1 - LRU REPLACEMENT POLICY</h2><p>本任务为实现一个LRU页面置换策略，建立一个关于面向磁盘的数据库的基本的概念是很重要的，如下图：</p>
<p><img src="/2023/03/05/cmu-15445-lab1/dbms.jpeg" alt="dbms"></p>
<p>从中可以看出，实际数据是持久化存储于磁盘之上的，执行引擎主要进行一些数据操作（读&#x2F;写，也即对Page增删改查），而BufferPool则是介于执行引擎和磁盘之间，位于内存中，给执行引擎提供Page。由于存储器体系结构一般表现为内存容量远小于磁盘容量，因此BufferPool是无法加载整个db的所有Pages的，因此需要在合适的时机将Page写入磁盘中，LRU就决定了牺牲哪个Page（即将哪个Page写回到磁盘中），其中包含了局部性原理的思想。</p>
<p>在Buffer Pool中，Page是存放在frame中的，这是要注意的一个点（buffer pool就是一个能容放多个Page的vector）。</p>
<p><img src="/2023/03/05/cmu-15445-lab1/buffer_pool.jpeg" alt="dbms"></p>
<blockquote>
<p>The size of the <code>LRUReplacer</code> is the same as buffer pool since it contains placeholders for all of the frames in the <code>BufferPoolManager</code>. However, not all the frames are considered as in the <code>LRUReplacer</code>. The <code>LRUReplacer</code> is initialized to have no frame in it. Then, only the newly unpinned ones will be considered in the <code>LRUReplacer</code>.</p>
</blockquote>
<p>所要实现的接口主要是下面四个：</p>
<blockquote>
<ul>
<li><code>Victim(T*)</code> : Remove the object that was accessed the least recently compared to all the elements being tracked by the <code>Replacer</code>, store its contents in the output parameter and return <code>True</code>. If the <code>Replacer</code> is empty return <code>False</code>.</li>
<li><code>Pin(T)</code> : This method should be called after a page is pinned to a frame in the <code>BufferPoolManager</code>. It should remove the frame containing the pinned page from the <code>LRUReplacer</code>.</li>
<li><code>Unpin(T)</code> : This method should be called when the <code>pin_count</code> of a page becomes 0. This method should add the frame containing the unpinned page to the <code>LRUReplacer</code>.</li>
<li><code>Size()</code> : This method returns the number of frames that are currently in the <code>LRUReplacer</code>.</li>
</ul>
</blockquote>
<p>LRU的实现十分的简单，是经典的leetcode题，用<code>list</code>套一个<code>unordered_map</code>即可实现。</p>
<p>下面主要讲一下我对<code>Pin</code>和<code>UnPin</code>的理解：</p>
<ul>
<li><code>Pin(T)</code> : 将一个Page(frame)从LRU的list中剔除。即该Page(frame)被Buffer Pool所使用了，LRU不应该牺牲该页面。</li>
<li><code>Unpin(T)</code> : 加入一个Page(frame)入LRU的list。即该页面Buffer Pool目前没人使用了，LRU根据策略决定该页面的去留。</li>
<li><code>Victim(T*)</code> :意思很直接，LRU根据规则（最近最少使用）有选择性的牺牲一个页面(frame)。</li>
</ul>
<p>并发的话，直接加大锁就好了。<code>std::lock_guard</code>是一种RAII的加锁方式，可以不用unlock（在析构的时候unlock），比较方便。给出<code>Victim</code>的实现方法，其他的应 Prof. Pavlo 要求就不放出来了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LRUReplacer::Victim</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(latch_)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (id2iter_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> deleting_id = lru_list_.<span class="built_in">back</span>();</span><br><span class="line">  lru_list_.<span class="built_in">pop_back</span>();</span><br><span class="line">  id2iter_.<span class="built_in">erase</span>(deleting_id);</span><br><span class="line">  *frame_id = deleting_id;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TASK-2-BUFFER-POOL-MANAGER"><a href="#TASK-2-BUFFER-POOL-MANAGER" class="headerlink" title="TASK #2 - BUFFER POOL MANAGER"></a>TASK #2 - BUFFER POOL MANAGER</h2><p>第二个任务为构造一个Buffer Pool。</p>
<blockquote>
<p>The <code>BufferPoolManager</code> is responsible for fetching database pages from the <code>DiskManager</code> and storing them in memory. The <code>BufferPoolManager</code> can also write dirty pages out to disk when it is either explicitly instructed to do so or when it needs to evict a page to make space for a new page.</p>
</blockquote>
<p>实现以下几个接口：</p>
<blockquote>
<ul>
<li><code>FetchPageImpl(page_id)</code></li>
<li><code>NewPageImpl(page_id)</code></li>
<li><code>UnpinPageImpl(page_id, is_dirty)</code></li>
<li><code>FlushPageImpl(page_id)</code></li>
<li><code>DeletePageImpl(page_id)</code></li>
<li><code>FlushAllPagesImpl()</code></li>
</ul>
</blockquote>
<p>(其实可以先通过测试程序了解这几个接口怎么用的，然后再去实现会比较好！)</p>
<ul>
<li><code>NewPageImpl(page_id)</code>：新建一个Page。</li>
<li><code>FetchPageImpl(page_id)</code>：获取一个Page。</li>
<li><code>UnpinPageImpl(page_id, is_dirty)</code>：解除对某个Page的使用（别的进程可能还在使用，pin_count为0的时候可以删除）</li>
<li><code>DeletePageImpl(page_id)</code>：删除一个Page。</li>
<li><code>FlushPageImpl(page_id)</code>：强制将某个Page写盘。</li>
<li><code>FlushAllPagesImpl()</code>：将所有Page写盘。</li>
</ul>
<p>这个task其实本质上就是考验对下面两个点的理解，根据提示看看<code>DiskManager</code> 的API是比较好实现的：</p>
<ul>
<li>Dirty Flag ：当该flag为真时，该页被写过了，要写回磁盘。</li>
<li>Pin&#x2F;Reference Counter：引用计数，当该计数为0时，将对应frame加入LRU中；当该计数不为0时，将对应frame从LRU中删除（即不参与LRU的替换）。</li>
</ul>
<p>该task有几个坑需要注意一下：</p>
<ol>
<li><p>重复<code>UnpinPageImpl</code>，但<code>is_dirty</code>标志不同。</p>
<ul>
<li>不是简单的赋值设置<code>is_dirty</code>标志，而是累计，即或一下。</li>
<li><code>page-&gt;is_dirty_ |= is_dirty;</code></li>
</ul>
</li>
<li><p>New完一个Page后，其pin_count为1，因此不要将这个Page放入LRU。</p>
<ul>
<li><code>replacer_-&gt;Pin(fid);</code></li>
</ul>
</li>
<li><p>New完一个Page后，要立即刷盘。可能会有new完以后unpin(false)的情况，不刷盘这一页就丢失了</p>
<ul>
<li><code>disk_manager_-&gt;WritePage(new_page-&gt;GetPageId(), new_page-&gt;GetData());</code></li>
</ul>
</li>
<li><p>获取frame时，先从free list获取，再从lru中获取。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief get a free page from free_list or lru_list</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @return frame_id_t frame id, -1 is error</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">frame_id_t</span> <span class="title">BufferPoolManager::get_free_frame</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">frame_id_t</span> frame_id = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (!free_list_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    frame_id = free_list_.<span class="built_in">front</span>();</span><br><span class="line">    free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    replacer_-&gt;<span class="built_in">Victim</span>(&amp;frame_id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> frame_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>删除一个Page时，要保证free list和LRU中只存在一个fid，而不是两边都有。</p>
<ul>
<li><code>  replacer_-&gt;Pin(fid);</code></li>
<li><code> free_list_.emplace_back(fid);</code></li>
</ul>
</li>
</ol>
<p>由于是多线程的程序，可以多跑几次测试一下，通过日志排查出错的原因。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">trap &#x27;exit 1&#x27; INT</span><br><span class="line"></span><br><span class="line">echo &quot;Running test $1 for $2 iters&quot;</span><br><span class="line">for i in $(seq 1 $2); do</span><br><span class="line">    echo -ne &quot;\r$i / $2&quot;</span><br><span class="line">    LOG=&quot;$i.txt&quot;</span><br><span class="line">    # Failed go test return nonzero exit codes</span><br><span class="line">    $1 &amp;&gt; $LOG</span><br><span class="line">    if [[ $? -eq 0 ]]; then</span><br><span class="line">        rm $LOG</span><br><span class="line">    else</span><br><span class="line">        echo &quot;Failed at iter $i, saving log at $LOG&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>（gradescope上测试要是失败了可以直接偷测试文件，逃</p>
<p>若有概念不理解的可以翻翻<a target="_blank" rel="noopener" href="https://15445.courses.cs.cmu.edu/fall2020/slides/05-bufferpool.pdf">课件</a>。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-12-19T04:20:27.000Z" title="12/19/2021, 12:20:27 PM">2021-12-19</time>发表</span><span class="level-item"><time dateTime="2023-03-05T15:13:50.668Z" title="3/5/2023, 11:13:50 PM">2023-03-05</time>更新</span><span class="level-item">8 分钟读完 (大约1140个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/19/effective-cpp-2/">Effective C++ 第二章 构造/析构/赋值运算</a></p><div class="content"><h2 id="第一章-让自己习惯-C-（Accustoming-Youself-to-C-）"><a href="#第一章-让自己习惯-C-（Accustoming-Youself-to-C-）" class="headerlink" title="第一章 让自己习惯 C++（Accustoming Youself to C++）"></a>第一章 让自己习惯 C++（Accustoming Youself to C++）</h2><h3 id="条款1：视C-为一个语言联邦"><a href="#条款1：视C-为一个语言联邦" class="headerlink" title="条款1：视C++为一个语言联邦"></a>条款1：视C++为一个语言联邦</h3><p>C++是个<strong>多重范型</strong>编程语言，同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式。</p>
<p>视C++为一个语言联邦，包括以下四个部分：</p>
<ol>
<li>C：<strong>面向过程</strong>的部分</li>
<li>Object-Oriented C++：<strong>面向对象</strong>的部分，包括封装、继承、多态以及虚函数（动态绑定）等。</li>
<li>Template C++：<strong>泛型编程</strong>部分</li>
<li>STL： 融合泛型编程和OOP编程思想的<strong>C++标准模板库</strong>，包括容器、迭代器、算法以及函数对象等。</li>
</ol>
<p>请记住：</p>
<ul>
<li><strong>C++高效编程守则视状况而变化，取决于使用的是这四个部分中的哪一部分。</strong></li>
</ul>
<h3 id="条款2：尽量以const，enum，inline代替-define"><a href="#条款2：尽量以const，enum，inline代替-define" class="headerlink" title="条款2：尽量以const，enum，inline代替#define"></a>条款2：尽量以const，enum，inline代替#define</h3><p>宁可以<strong>编译器代替预处理器</strong>。</p>
<p>#define即宏定义在预处理阶段进行处理，不进入记号表（<em>symbol table</em>）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">CALL_MAX</span>(++a, b);       <span class="comment">//a被累加2次</span></span><br><span class="line"><span class="built_in">CALL_MAX</span>(++a, b + <span class="number">10</span>);  <span class="comment">//a被累加1次</span></span><br></pre></td></tr></table></figure>

<p>这是不可预料的行为，因此使用内联函数来代替宏定义函数。</p>
<p>请记住：</p>
<ul>
<li><strong>对于单纯常量，最好使用const对象或enum替换#defines。</strong></li>
<li><strong>对于形似函数的宏，最好改用inline函数替换#defines。</strong></li>
</ul>
<h3 id="条款3：尽可能使用const"><a href="#条款3：尽可能使用const" class="headerlink" title="条款3：尽可能使用const"></a>条款3：尽可能使用const</h3><p>const关键字告诉编译器某值应该保持不变，即为只读的。</p>
<h4 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h4><p>两个成员函数如果只是常量性不同，可以被重载。</p>
<p>const成员函数代表this指针的类型为：<code>const className &amp;</code>。</p>
<p>使用const成员函数来处理const对象。</p>
<h4 id="在const和non-cons成员函数中避免重复"><a href="#在const和non-cons成员函数中避免重复" class="headerlink" title="在const和non-cons成员函数中避免重复"></a>在const和non-cons成员函数中避免重复</h4><p>利用non-const版本调用const版本，再加上转型const_cast、static_cast,例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> pos) <span class="type">const</span>;<span class="comment">//const版本</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> pos) &#123; <span class="comment">//non-const版本</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="type">char</span>&amp;&gt; <span class="comment">//返回值转型，移除const</span></span><br><span class="line">     (<span class="built_in">static_cast</span>&lt;<span class="type">const</span> className&amp;&gt;(*<span class="keyword">this</span>)[pos]);<span class="comment">//*this转型,增加const</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但反过来使用const版本调用non-const版本则是一种错误行为。</p>
<p>请记住：</p>
<ul>
<li><strong>将某些东西声明为const可以帮助编译器侦测除错误；const可以被施加在任何作用域内的对象、函数参数、函数返回类型、成员函数本身。</strong></li>
<li><strong>编译器强制实施bitwise constness，但是你编写程序时应该使用“概念上的常量性”。</strong></li>
<li><strong>当const和non-const成员函数有着实质等价的实现时，使用non-const版本来调用const版本可以避免代码重复。</strong></li>
</ul>
<h3 id="条款4：确定对象使用前已被初始化"><a href="#条款4：确定对象使用前已被初始化" class="headerlink" title="条款4：确定对象使用前已被初始化"></a>条款4：确定对象使用前已被初始化</h3><p>永远在对象使用之前将其初始化。</p>
<ol>
<li><p>对于内置类型，手动初始化。</p>
</li>
<li><p>对于非内置类型，使用<strong>构造函数</strong>进行初始化。</p>
</li>
</ol>
<p><strong>赋值和初始化</strong>有区别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值，而非初始化</span></span><br><span class="line"><span class="built_in">ABEntry</span>(<span class="type">const</span> string&amp; name, <span class="type">const</span> string&amp; address, <span class="type">int</span> num) &#123;</span><br><span class="line">        _name = name;</span><br><span class="line">        _address = address;</span><br><span class="line">        _num = num; </span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 初始化，发生在进入构造函数本体之前</span></span><br><span class="line"><span class="comment">// 即成员初值列(member initialization list)</span></span><br><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> string&amp; name, <span class="type">const</span> string&amp; address, <span class="type">int</span> num)</span><br><span class="line">    : _name(name), _address(address), _num(num) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>C++有着固定的初始化顺序：<strong>按照声明顺序进行初始化，且基类先于派生类初始化</strong></p>
<p>static对象：其寿命从被构造出来直到程序结束为止。</p>
<p>local static object(局部静态对象)：函数内的static对象。</p>
<p>non-local static object(非局部静态对象)：非函数内的static对象，不同编译单元之间初始化次序不确定</p>
<p>因此，要解决non-local static object初始化次序问题，就要将non-local static object转换为local static object（使用单例模式，即封装一层函数）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton s;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;);</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>请记住:</p>
<ul>
<li><strong>为内置类型进行手工初始化，C++不保证初始化它们。</strong></li>
<li><strong>构造函数最好使用成员初值列，不要在构造函数中使用赋值操作，初值列中的成员变量的顺序应该和声明顺序一致。</strong></li>
<li><strong>为免除“跨编译单元之初始化次序”问题，使用返回local static对象引用的函数来代替non-local static对象。</strong></li>
</ul>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] Effective C++ · Scott Meyers</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-12-12T14:28:27.000Z" title="12/12/2021, 10:28:27 PM">2021-12-12</time>发表</span><span class="level-item"><time dateTime="2023-03-05T15:13:29.936Z" title="3/5/2023, 11:13:29 PM">2023-03-05</time>更新</span><span class="level-item">8 分钟读完 (大约1140个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/12/effective-cpp-1/">Effective C++ 第一章 让自己习惯 C++</a></p><div class="content"><h2 id="第一章-让自己习惯-C-（Accustoming-Youself-to-C-）"><a href="#第一章-让自己习惯-C-（Accustoming-Youself-to-C-）" class="headerlink" title="第一章 让自己习惯 C++（Accustoming Youself to C++）"></a>第一章 让自己习惯 C++（Accustoming Youself to C++）</h2><h3 id="条款1：视C-为一个语言联邦"><a href="#条款1：视C-为一个语言联邦" class="headerlink" title="条款1：视C++为一个语言联邦"></a>条款1：视C++为一个语言联邦</h3><p>C++是个<strong>多重范型</strong>编程语言，同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式。</p>
<p>视C++为一个语言联邦，包括以下四个部分：</p>
<ol>
<li>C：<strong>面向过程</strong>的部分</li>
<li>Object-Oriented C++：<strong>面向对象</strong>的部分，包括封装、继承、多态以及虚函数（动态绑定）等。</li>
<li>Template C++：<strong>泛型编程</strong>部分</li>
<li>STL： 融合泛型编程和OOP编程思想的<strong>C++标准模板库</strong>，包括容器、迭代器、算法以及函数对象等。</li>
</ol>
<p>请记住：</p>
<ul>
<li><strong>C++高效编程守则视状况而变化，取决于使用的是这四个部分中的哪一部分。</strong></li>
</ul>
<h3 id="条款2：尽量以const，enum，inline代替-define"><a href="#条款2：尽量以const，enum，inline代替-define" class="headerlink" title="条款2：尽量以const，enum，inline代替#define"></a>条款2：尽量以const，enum，inline代替#define</h3><p>宁可以<strong>编译器代替预处理器</strong>。</p>
<p>#define即宏定义在预处理阶段进行处理，不进入记号表（<em>symbol table</em>）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">CALL_MAX</span>(++a, b);       <span class="comment">//a被累加2次</span></span><br><span class="line"><span class="built_in">CALL_MAX</span>(++a, b + <span class="number">10</span>);  <span class="comment">//a被累加1次</span></span><br></pre></td></tr></table></figure>

<p>这是不可预料的行为，因此使用内联函数来代替宏定义函数。</p>
<p>请记住：</p>
<ul>
<li><strong>对于单纯常量，最好使用const对象或enum替换#defines。</strong></li>
<li><strong>对于形似函数的宏，最好改用inline函数替换#defines。</strong></li>
</ul>
<h3 id="条款3：尽可能使用const"><a href="#条款3：尽可能使用const" class="headerlink" title="条款3：尽可能使用const"></a>条款3：尽可能使用const</h3><p>const关键字告诉编译器某值应该保持不变，即为只读的。</p>
<h4 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h4><p>两个成员函数如果只是常量性不同，可以被重载。</p>
<p>const成员函数代表this指针的类型为：<code>const className &amp;</code>。</p>
<p>使用const成员函数来处理const对象。</p>
<h4 id="在const和non-cons成员函数中避免重复"><a href="#在const和non-cons成员函数中避免重复" class="headerlink" title="在const和non-cons成员函数中避免重复"></a>在const和non-cons成员函数中避免重复</h4><p>利用non-const版本调用const版本，再加上转型const_cast、static_cast,例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> pos) <span class="type">const</span>;<span class="comment">//const版本</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> pos) &#123; <span class="comment">//non-const版本</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="type">char</span>&amp;&gt; <span class="comment">//返回值转型，移除const</span></span><br><span class="line">     (<span class="built_in">static_cast</span>&lt;<span class="type">const</span> className&amp;&gt;(*<span class="keyword">this</span>)[pos]);<span class="comment">//*this转型,增加const</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但反过来使用const版本调用non-const版本则是一种错误行为。</p>
<p>请记住：</p>
<ul>
<li><strong>将某些东西声明为const可以帮助编译器侦测除错误；const可以被施加在任何作用域内的对象、函数参数、函数返回类型、成员函数本身。</strong></li>
<li><strong>编译器强制实施bitwise constness，但是你编写程序时应该使用“概念上的常量性”。</strong></li>
<li><strong>当const和non-const成员函数有着实质等价的实现时，使用non-const版本来调用const版本可以避免代码重复。</strong></li>
</ul>
<h3 id="条款4：确定对象使用前已被初始化"><a href="#条款4：确定对象使用前已被初始化" class="headerlink" title="条款4：确定对象使用前已被初始化"></a>条款4：确定对象使用前已被初始化</h3><p>永远在对象使用之前将其初始化。</p>
<ol>
<li><p>对于内置类型，手动初始化。</p>
</li>
<li><p>对于非内置类型，使用<strong>构造函数</strong>进行初始化。</p>
</li>
</ol>
<p><strong>赋值和初始化</strong>有区别：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值，而非初始化</span></span><br><span class="line"><span class="built_in">ABEntry</span>(<span class="type">const</span> string&amp; name, <span class="type">const</span> string&amp; address, <span class="type">int</span> num) &#123;</span><br><span class="line">        _name = name;</span><br><span class="line">        _address = address;</span><br><span class="line">        _num = num; </span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 初始化，发生在进入构造函数本体之前</span></span><br><span class="line"><span class="comment">// 即成员初值列(member initialization list)</span></span><br><span class="line">ABEntry::<span class="built_in">ABEntry</span>(<span class="type">const</span> string&amp; name, <span class="type">const</span> string&amp; address, <span class="type">int</span> num)</span><br><span class="line">    : _name(name), _address(address), _num(num) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>C++有着固定的初始化顺序：<strong>按照声明顺序进行初始化，且基类先于派生类初始化</strong></p>
<p>static对象：其寿命从被构造出来直到程序结束为止。</p>
<p>local static object(局部静态对象)：函数内的static对象。</p>
<p>non-local static object(非局部静态对象)：非函数内的static对象，不同编译单元之间初始化次序不确定</p>
<p>因此，要解决non-local static object初始化次序问题，就要将non-local static object转换为local static object（使用单例模式，即封装一层函数）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton s;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;);</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>请记住:</p>
<ul>
<li><strong>为内置类型进行手工初始化，C++不保证初始化它们。</strong></li>
<li><strong>构造函数最好使用成员初值列，不要在构造函数中使用赋值操作，初值列中的成员变量的顺序应该和声明顺序一致。</strong></li>
<li><strong>为免除“跨编译单元之初始化次序”问题，使用返回local static对象引用的函数来代替non-local static对象。</strong></li>
</ul>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>[1] Effective C++ · Scott Meyers</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-12-11T14:35:09.000Z" title="12/11/2021, 10:35:09 PM">2021-12-11</time>发表</span><span class="level-item"><time dateTime="2023-03-05T15:13:57.583Z" title="3/5/2023, 11:13:57 PM">2023-03-05</time>更新</span><span class="level-item">1 分钟读完 (大约114个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/11/cpp-default-parameters/">CPP - 函数默认参数</a></p><div class="content"><ol>
<li>c++规定默认参数必须<strong>从函数参数的右边向左边</strong>使用，如下：</li>
</ol>
<p>正确：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b=<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b=<span class="number">10</span>, <span class="type">int</span> c=<span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun3</span><span class="params">(<span class="type">int</span> a=<span class="number">5</span>, <span class="type">int</span> b, <span class="type">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun4</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b=<span class="number">5</span>, <span class="type">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>





<ol start="2">
<li><strong>默认参数不能在声明和定义中同时出现</strong></li>
</ol>
<p>错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> a=<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> a=<span class="number">10</span>)</span></span>&#123;......&#125;</span><br></pre></td></tr></table></figure>

<p>正确：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(<span class="type">int</span> a=<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;......&#125;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(<span class="type">int</span> a=<span class="number">10</span>)</span></span>&#123;......&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-10-26T14:44:16.000Z" title="10/26/2021, 10:44:16 PM">2021-10-26</time>发表</span><span class="level-item"><time dateTime="2023-03-05T15:13:55.846Z" title="3/5/2023, 11:13:55 PM">2023-03-05</time>更新</span><span class="level-item">1 分钟读完 (大约170个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/10/26/cpp-oop-intro/">CPP面向对象 - 概述</a></p><div class="content"><h1 id="C-vs-C"><a href="#C-vs-C" class="headerlink" title="C vs C++"></a>C vs C++</h1><p>C是面向过程的，C++是面向对象的，面向对象即是讲一些数据和函数绑定在一起。</p>
<p><img src="/2021/10/26/cpp-oop-intro/image-20211026211923286.png" alt="image"></p>
<h1 id="对象-classes-的两种经典分类"><a href="#对象-classes-的两种经典分类" class="headerlink" title="对象(classes)的两种经典分类"></a>对象(classes)的两种经典分类</h1><ol>
<li>Class without pointer members<ul>
<li>complex</li>
<li>拷贝都得一一复制（因为数据成员都包含在对象中了）</li>
</ul>
</li>
<li>Class with pointer members<ul>
<li>string</li>
<li>拷贝分深浅，因此有移动语义（C++11支持）</li>
</ul>
</li>
</ol>
<h1 id="C-程序代码的基本形式"><a href="#C-程序代码的基本形式" class="headerlink" title="C++程序代码的基本形式"></a>C++程序代码的基本形式</h1><p>一般而言分 <code>.cpp</code> 或 <code>.h</code> 两种：</p>
<p><img src="/2021/10/26/cpp-oop-intro/image-20211026212814939.png" alt="image"></p>
<ul>
<li><code>.h</code> ：写一些类的声明</li>
<li><code>.cpp</code> ：类的实现</li>
</ul>
<p>也不一定是 <code>.cpp</code> 或 <code>.h</code> 文件，也有可能是 <code>.hpp</code> 等文件。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">上一页</a></div><div class="pagination-next"><a href="/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar2.png" alt="Xinlong Chen"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Xinlong Chen</p><p class="is-size-6 is-block">os | db</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Canton</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">21</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">4</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Xinlong-Chen" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Xinlong-Chen"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.cnblogs.com/cxl-" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">cnblog</span></span><span class="level-right"><span class="level-item tag">www.cnblogs.com</span></span></a></li><li><a class="level is-mobile" href="https://blog.csdn.net/hrbust_cxl" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">csdn</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li><li><a class="level is-mobile" href="https://leetcode.cn/u/zhui-22/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">leetcode</span></span><span class="level-right"><span class="level-item tag">leetcode.cn</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-05T15:32:23.000Z">2023-03-05</time></p><p class="title"><a href="/2023/03/05/stl-intro/">STL - STL概述</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-05T15:31:45.000Z">2023-03-05</time></p><p class="title"><a href="/2023/03/05/stl-programming-style/">stl_programming_style</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-05T15:28:08.000Z">2023-03-05</time></p><p class="title"><a href="/2023/03/05/cpp-reference-pointer/">CPP - 引用&amp;指针</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-05T15:27:02.000Z">2023-03-05</time></p><p class="title"><a href="/2023/03/05/cpp-type/">CPP - 处理类型</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-03-05T15:24:15.000Z">2023-03-05</time></p><p class="title"><a href="/2023/03/05/cpp-operator-override/">CPP - 操作符重载！看这篇就够了！</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Effective-C/"><span class="tag">Effective C++</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cmu15445/"><span class="tag">cmu15445</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cpp/"><span class="tag">cpp</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/stl/"><span class="tag">stl</span><span class="tag">8</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar3.png" alt="Xinlong-Chen&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Xinlong-Chen</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>