<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>mit6.s081 - lab3 page tables - Xinlong-Chen&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="Xinlong Chen&#039;s blog"><meta name="msapplication-TileImage" content="/img/avatar3.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Xinlong Chen&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本文为本人完成6.s081 2021fall时的一些记录，仅作为备忘录使用。 代码仓库地址：代码 task 1: Speed up system calls (easy)"><meta property="og:type" content="blog"><meta property="og:title" content="mit6.s081 - lab3 page tables"><meta property="og:url" content="https://xinlong-chen.github.io/2023/03/12/mit6-s081-lab3-page-tables/"><meta property="og:site_name" content="Xinlong-Chen&#039;s blog"><meta property="og:description" content="本文为本人完成6.s081 2021fall时的一些记录，仅作为备忘录使用。 代码仓库地址：代码 task 1: Speed up system calls (easy)"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://xinlong-chen.github.io/2023/03/12/mit6-s081-lab3-page-tables/process_address_space.jpg"><meta property="og:image" content="https://xinlong-chen.github.io/2023/03/12/mit6-s081-lab3-page-tables/image-20230310235102264.png"><meta property="og:image" content="https://xinlong-chen.github.io/2023/03/12/mit6-s081-lab3-page-tables/image-20230311230848345.png"><meta property="og:image" content="https://xinlong-chen.github.io/2023/03/12/mit6-s081-lab3-page-tables/image-20230312105012660.png"><meta property="article:published_time" content="2023-03-12T02:21:20.000Z"><meta property="article:modified_time" content="2023-08-27T12:05:06.509Z"><meta property="article:author" content="Xinlong-Chen"><meta property="article:tag" content="mit6.s081"><meta property="article:tag" content="xv6"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://xinlong-chen.github.io/2023/03/12/mit6-s081-lab3-page-tables/process_address_space.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xinlong-chen.github.io/2023/03/12/mit6-s081-lab3-page-tables/"},"headline":"mit6.s081 - lab3 page tables","image":["https://xinlong-chen.github.io/2023/03/12/mit6-s081-lab3-page-tables/process_address_space.jpg","https://xinlong-chen.github.io/2023/03/12/mit6-s081-lab3-page-tables/image-20230310235102264.png","https://xinlong-chen.github.io/2023/03/12/mit6-s081-lab3-page-tables/image-20230311230848345.png","https://xinlong-chen.github.io/2023/03/12/mit6-s081-lab3-page-tables/image-20230312105012660.png"],"datePublished":"2023-03-12T02:21:20.000Z","dateModified":"2023-08-27T12:05:06.509Z","author":{"@type":"Person","name":"Xinlong-Chen"},"publisher":{"@type":"Organization","name":"Xinlong-Chen's blog","logo":{"@type":"ImageObject","url":"https://xinlong-chen.github.io/img/avatar3.png"}},"description":"本文为本人完成6.s081 2021fall时的一些记录，仅作为备忘录使用。 代码仓库地址：代码 task 1: Speed up system calls (easy)"}</script><link rel="canonical" href="https://xinlong-chen.github.io/2023/03/12/mit6-s081-lab3-page-tables/"><link rel="icon" href="/img/avatar3.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar3.png" alt="Xinlong-Chen&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-12T02:21:20.000Z" title="2023/3/12 上午10:21:20">2023-03-12</time>发表</span><span class="level-item"><time dateTime="2023-08-27T12:05:06.509Z" title="2023/8/27 下午8:05:06">2023-08-27</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span><span class="level-item">16 分钟读完 (大约2378个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">mit6.s081 - lab3 page tables</h1><div class="content"><p>本文为本人完成6.s081 2021fall时的一些记录，仅作为备忘录使用。</p>
<p>代码仓库地址：<a target="_blank" rel="noopener" href="https://github.com/Xinlong-Chen/mit6.S081-2021fall/tree/pgtbl">代码</a></p>
<h2 id="task-1-Speed-up-system-calls-easy"><a href="#task-1-Speed-up-system-calls-easy" class="headerlink" title="task 1: Speed up system calls (easy)"></a>task 1: Speed up system calls (easy)</h2><span id="more"></span>

<h3 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h3><blockquote>
<p>When each process is created, map one read-only page at USYSCALL (a VA defined in <code>memlayout.h</code>). At the start of this page, store a <code>struct usyscall</code> (also defined in <code>memlayout.h</code>), and initialize it to store the PID of the current process. For this lab, <code>ugetpid()</code> has been provided on the userspace side and will automatically use the USYSCALL mapping. You will receive full credit for this part of the lab if the <code>ugetpid</code> test case passes when running <code>pgtbltest</code>.</p>
</blockquote>
<p>xv6执行系统调用的时候，需要通过ecall指令陷入内核，然后在内核态执行完系统调用时再返回用户态，这样是比较耗时的。</p>
<p>出于性能方面考虑，可以让用户空间和内核空间共享一片只读的物理内存空间，这样可以避免用户态和内核态之间的切换（减少上下文切换），从而加速某些系统调用的性能。</p>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>在每个进程创建时，分配一个物理页面，将其与 <code>USYSCALL</code> 页面建立映射关系，用于存放进程号PID。(如下图所示这个地址在<code>TRAPFRAME</code>下面，<code>kernel/memlayout.h</code>文件中定义)进行映射。</p>
<p>之后再获取PID时就可以不陷入内核态，直接访问 <code>USYSCALL</code> 页面即可。</p>
<p><img src="/2023/03/12/mit6-s081-lab3-page-tables/process_address_space.jpg" alt="process_address_space"></p>
<p>xv6中的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// User memory layout.</span></span><br><span class="line"><span class="comment">// Address zero first:</span></span><br><span class="line"><span class="comment">//   text</span></span><br><span class="line"><span class="comment">//   original data and bss</span></span><br><span class="line"><span class="comment">//   fixed-size stack</span></span><br><span class="line"><span class="comment">//   expandable heap</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   USYSCALL (shared with kernel)</span></span><br><span class="line"><span class="comment">//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)</span></span><br><span class="line"><span class="comment">//   TRAMPOLINE (the same page as in the kernel)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAB_PGTBL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USYSCALL (TRAPFRAME - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> pid;  <span class="comment">// Process ID</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因此要做的事情很简单：</p>
<ol>
<li><p>创建进程时：</p>
<ul>
<li>创建进程的时候分配物理页。</li>
<li>建立虚拟地址和物理地址的映射关系。</li>
<li>给这个 <code>USYSCALL</code> 的pid赋值。</li>
</ul>
</li>
<li><p>销毁进程时：</p>
<ul>
<li>归还这个页的物理内存。</li>
<li>解除映射关系。</li>
</ul>
</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol>
<li><p>创建进程时：</p>
<ul>
<li><p>创建进程的时候分配物理页（<code>kernel/proc.c@allocproc</code>）。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+  if((p-&gt;usyscallframe = (struct usyscall *)kalloc()) == 0)&#123;</span></span><br><span class="line"><span class="addition">+    freeproc(p);</span></span><br><span class="line"><span class="addition">+    release(&amp;p-&gt;lock);</span></span><br><span class="line"><span class="addition">+    return 0;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">   // An empty user page table.</span><br><span class="line">   p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">   if(p-&gt;pagetable == 0)&#123;</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立虚拟地址和物理地址的映射关系（<code>kernel/proc.c@proc_pagetable</code>）。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+  // map pid</span></span><br><span class="line"><span class="addition">+  if(mappages(pagetable, USYSCALL, PGSIZE,</span></span><br><span class="line"><span class="addition">+              (uint64)(p-&gt;usyscallframe), PTE_R | PTE_U) &lt; 0)&#123;</span></span><br><span class="line"><span class="addition">+    uvmunmap(pagetable, TRAMPOLINE, 1, 0);</span></span><br><span class="line"><span class="addition">+    uvmunmap(pagetable, TRAPFRAME, 1, 0);</span></span><br><span class="line"><span class="addition">+    uvmfree(pagetable, 0);</span></span><br><span class="line"><span class="addition">+    return 0;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">   return pagetable;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>给这个 <code>USYSCALL</code> 的pid赋值（<code>kernel/proc.c@allocproc</code>）。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+  p-&gt;usyscallframe-&gt;pid = p-&gt;pid;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">   // Set up new context to start executing at forkret,</span><br><span class="line">   // which returns to user space.</span><br><span class="line">   memset(&amp;p-&gt;context, 0, sizeof(p-&gt;context));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>销毁进程时：</p>
<ul>
<li><p>归还这个页的物理内存（<code>kernel/proc.c@freeproc</code>）。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   if(p-&gt;trapframe)</span><br><span class="line">     kfree((void*)p-&gt;trapframe);</span><br><span class="line"><span class="addition">+  if(p-&gt;usyscallframe)</span></span><br><span class="line"><span class="addition">+    kfree((void*)p-&gt;usyscallframe);</span></span><br><span class="line">   p-&gt;trapframe = 0;</span><br><span class="line">   if(p-&gt;pagetable)</span><br><span class="line">     proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br></pre></td></tr></table></figure>
</li>
<li><p>解除映射关系（<code>kernel/proc.c@proc_freepagetable</code>）。</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> void</span><br><span class="line"> proc_freepagetable(pagetable_t pagetable, uint64 sz)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="addition">+  uvmunmap(pagetable, USYSCALL, 1, 0);</span></span><br><span class="line">   uvmunmap(pagetable, TRAMPOLINE, 1, 0);</span><br><span class="line">   uvmunmap(pagetable, TRAPFRAME, 1, 0);</span><br><span class="line">   uvmfree(pagetable, sz);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="task-2-Print-a-page-table-easy"><a href="#task-2-Print-a-page-table-easy" class="headerlink" title="task 2: Print a page table (easy)"></a>task 2: Print a page table (easy)</h2><h3 id="题意描述-1"><a href="#题意描述-1" class="headerlink" title="题意描述"></a>题意描述</h3><blockquote>
<p>Define a function called <code>vmprint()</code>. It should take a <code>pagetable_t</code> argument, and print that pagetable in the format described below. Insert <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code> in exec.c just before the <code>return argc</code>, to print the first process’s page table. You receive full credit for this part of the lab if you pass the <code>pte printout</code> test of <code>make grade</code>.</p>
</blockquote>
<p>打印pid&#x3D;1的用户页表，效果如下，需要显示出三级页表的结构：</p>
<img src="/2023/03/12/mit6-s081-lab3-page-tables/image-20230310235102264.png" alt="image-20230310235102264" style="zoom:67%;">

<h3 id="解决思路-1"><a href="#解决思路-1" class="headerlink" title="解决思路"></a>解决思路</h3><p>可以参考 <code>walk</code> 函数的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> *</span><br><span class="line"><span class="title function_">walk</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, <span class="type">int</span> alloc)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    panic(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> level = <span class="number">2</span>; level &gt; <span class="number">0</span>; level--) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      pagetable = (<span class="type">pagetable_t</span>)PTE2PA(*pte);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!alloc || (pagetable = (<span class="type">pde_t</span>*)kalloc()) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(pagetable) | PTE_V;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;pagetable[PX(<span class="number">0</span>, va)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，查找页表中一个PTE的关键代码是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pte_t</span> *pte = &amp;pagetable[PX(level, va)];</span><br><span class="line"><span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>借助上面的在页表中查找PTE的代码，采用dfs就行（纯算法题），注意输出格式即可。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p><code>kernel/vm.c</code>：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+void dfs_vmpt(pagetable_t pagetable, int step) &#123;</span></span><br><span class="line"><span class="addition">+  char* pre = 0;</span></span><br><span class="line"><span class="addition">+  if (step == 0) pre = &quot;.. .. ..&quot;;</span></span><br><span class="line"><span class="addition">+  else if (step == 1) pre = &quot;.. ..&quot;;</span></span><br><span class="line"><span class="addition">+  else if (step == 2) pre = &quot;..&quot;;</span></span><br><span class="line"><span class="addition">+  for (int i = 0; i &lt; 512; ++i) &#123;</span></span><br><span class="line"><span class="addition">+    pte_t pte = pagetable[i];</span></span><br><span class="line"><span class="addition">+    if (pte &amp; PTE_V) &#123;</span></span><br><span class="line"><span class="addition">+      printf(&quot;%s%d: pte %p pa %p\n&quot;, pre, i, pte, PTE2PA(pte));</span></span><br><span class="line"><span class="addition">+      if (step != 0) &#123;</span></span><br><span class="line"><span class="addition">+        dfs_vmpt((pagetable_t)PTE2PA(pte), step - 1);</span></span><br><span class="line"><span class="addition">+      &#125;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+void vmprint(pagetable_t pagetable) &#123;</span></span><br><span class="line"><span class="addition">+  printf(&quot;page table %p\n&quot;, pagetable);</span></span><br><span class="line"><span class="addition">+  dfs_vmpt(pagetable, 2);</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="task-3-Detecting-which-pages-have-been-accessed-hard"><a href="#task-3-Detecting-which-pages-have-been-accessed-hard" class="headerlink" title="task 3: Detecting which pages have been accessed (hard)"></a>task 3: Detecting which pages have been accessed (hard)</h2><h3 id="题意描述-2"><a href="#题意描述-2" class="headerlink" title="题意描述"></a>题意描述</h3><p>Some garbage collectors (a form of automatic memory management) can benefit from information about which pages have been accessed (read or write). In this part of the lab, you will add a new feature to xv6 that detects and reports this information to userspace by inspecting the access bits in the RISC-V page table. The RISC-V hardware page walker marks these bits in the PTE whenever it resolves a TLB miss.</p>
<blockquote>
<p>Your job is to implement <code>pgaccess()</code>, a system call that reports which pages have been accessed. The system call takes three arguments. First, it takes the starting virtual address of the first user page to check. Second, it takes the number of pages to check. Finally, it takes a user address to a buffer to store the results into a bitmask (a datastructure that uses one bit per page and where the first page corresponds to the least significant bit). You will receive full credit for this part of the lab if the <code>pgaccess</code> test case passes when running <code>pgtbltest</code>.</p>
</blockquote>
<p>给页表Flags中添加一位用于标志页面是否被访问，并实现pgaccess系统调用。</p>
<p>系统调用pgaccess：获取从上次pgaccess到现在，一段虚拟内存空间的页面是否被访问过。</p>
<ul>
<li>输入：页面起始地址、页面数量、返回结果地址，</li>
<li>输出：通过位图保存的页面的access状态，将其复制到输入的返回结果地址中。</li>
</ul>
<h3 id="解决思路-2"><a href="#解决思路-2" class="headerlink" title="解决思路"></a>解决思路</h3><p>首先要明确的是，我们要利用PTE的FLAGS，其形式如下，可以看到在Sv39硬件下，有一个A标记位：</p>
<p><img src="/2023/03/12/mit6-s081-lab3-page-tables/image-20230311230848345.png" alt="image-20230311230848345"></p>
<p>参考RISC-V的资料[1]，可以看到下面一句话：</p>
<blockquote>
<p>Each leaf PTE contains an accessed (A) and dirty (D) bit. The A bit indicates the virtual page has been read, written, or fetched from since the last time the A bit was cleared. The D bit indicates the virtual page has been written since the last time the D bit was cleared.</p>
</blockquote>
<p>所以第6位即是我们要利用的标记，称之为 <code>PTE_A</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A (1L &lt;&lt; 6)</span></span><br></pre></td></tr></table></figure>

<p>那么此时只要搞清楚需要谁来设置这个标记就可以了：</p>
<ul>
<li><p>根据以下lab文档描述，可以看出，PTE标记是MMU硬件去设置的（置1）。</p>
<blockquote>
<p>The RISC-V hardware page walker marks these bits in the PTE whenever it resolves a TLB miss.</p>
</blockquote>
</li>
<li><p>根据RISC-V的资料[1]，可以看出，PTE标记是需要操作系统这个软件来清除的（置0）。</p>
<blockquote>
<p>Mandating that the PTE updates to be exact, atomic, and in program order simplifies the spec- ification, and makes the feature more useful for system software. Simple implementations may instead generate page-fault exceptions.<br>The A and D bits are never cleared by the implementation. If the supervisor software does not rely on accessed and&#x2F;or dirty bits, e.g. if it does not swap memory pages to secondary storage or if the pages are being used to map I&#x2F;O space, it should always set them to 1 in the PTE to improve performance.</p>
</blockquote>
<p>以及</p>
<blockquote>
<p>For non-leaf PTEs, the D, A, and U bits are reserved for future standard use and must be cleared by software for forward compatibility.</p>
</blockquote>
</li>
</ul>
<p><strong>综合来说，<code>PTE_A</code> 的设置（置1）是MMU完成的，清除（置0）是操作系统完成的。</strong></p>
<p>这样，这个task就比较好完成了，实现一个系统调用去访问给定范围这些PTE，得到一个bitmap的结果，然后再将<code>PTE_A</code> 置0即可。</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>先定义 <code>PTE_A</code>：(<code>kernel/riscv.h</code>)</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> #define PTE_W (1L &lt;&lt; 2)</span><br><span class="line"> #define PTE_X (1L &lt;&lt; 3)</span><br><span class="line"> #define PTE_U (1L &lt;&lt; 4) // 1 -&gt; user can access</span><br><span class="line"><span class="addition">+#define PTE_A (1L &lt;&lt; 6)</span></span><br></pre></td></tr></table></figure>

<p>实现系统调用，是用户态程序与内核交互的接口：(<code>kernel/sysproc.c</code>)</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> int</span><br><span class="line"> sys_pgaccess(void)</span><br><span class="line"> &#123;</span><br><span class="line"><span class="deletion">-  // lab pgtbl: your code here.</span></span><br><span class="line"><span class="addition">+  uint64 base, mask;</span></span><br><span class="line"><span class="addition">+  int len;</span></span><br><span class="line"><span class="addition">+  if(argaddr(0, &amp;base) &lt; 0)</span></span><br><span class="line"><span class="addition">+    return -1;</span></span><br><span class="line"><span class="addition">+  if(argint(1, &amp;len) &lt; 0)</span></span><br><span class="line"><span class="addition">+    return -1;</span></span><br><span class="line"><span class="addition">+  if(argaddr(2, &amp;mask) &lt; 0)</span></span><br><span class="line"><span class="addition">+    return -1;</span></span><br><span class="line"><span class="addition">+  printf(&quot;%d %d %d\n&quot;, base, len, mask);</span></span><br><span class="line"><span class="addition">+  if(len &gt; (sizeof(int) * 8)) return -1;</span></span><br><span class="line"><span class="addition">+  int imask;</span></span><br><span class="line"><span class="addition">+  pgaccess(base, len, &amp;imask);</span></span><br><span class="line"><span class="addition">+  if(copyout(myproc()-&gt;pagetable, mask, (char *)&amp;imask, sizeof(int)) &lt; 0)</span></span><br><span class="line"><span class="addition">+    return -1;</span></span><br><span class="line">   return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>实现对应的获取访问标志位的bitmap的功能，并把<code>PTE_A</code> 标记清除：(<code>kernel/proc.c</code>)</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">     printf(&quot;\n&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+int pgaccess(uint64 base, int len, int *mask) &#123;</span></span><br><span class="line"><span class="addition">+  pte_t *pte;</span></span><br><span class="line"><span class="addition">+  int ans = 0;</span></span><br><span class="line"><span class="addition">+  for (int i = 0 ; i &lt; len; ++i) &#123;</span></span><br><span class="line"><span class="addition">+    pte = walk(myproc()-&gt;pagetable, base, 0);</span></span><br><span class="line"><span class="addition">+    if (pte != 0 &amp;&amp; (*pte) &amp; PTE_A) &#123;</span></span><br><span class="line"><span class="addition">+      ans |= 1 &lt;&lt; i;</span></span><br><span class="line"><span class="addition">+      *pte ^= PTE_A;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+    base += PGSIZE;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+  *mask = ans;</span></span><br><span class="line"><span class="addition">+  return 0;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，把内核数据往用户空间写要使用 <code>copyout</code> 方法：该方法将页表看作是一个数据结构，然后使用软件模拟MMU功能的方式，将虚拟地址转换为物理地址，来进行数据读写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy from kernel to user.</span></span><br><span class="line"><span class="comment">// Copy len bytes from src to virtual address dstva in a given page table.</span></span><br><span class="line"><span class="comment">// Return 0 on success, -1 on error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切换内核态的时候，cpu的参数没变（这个参数的改变和调度相关），因此可以在内核态用 <code>myproc</code> 访问当前用户态的进程信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line">  <span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> <span class="title">cpus</span>[<span class="title">NCPU</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Return this CPU&#x27;s cpu struct.</span></span><br><span class="line"><span class="comment">// Interrupts must be disabled.</span></span><br><span class="line"><span class="keyword">struct</span> cpu*</span><br><span class="line"><span class="title function_">mycpu</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> id = cpuid();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> &amp;cpus[id];</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the current struct proc *, or zero if none.</span></span><br><span class="line"><span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">myproc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  push_off();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> c-&gt;proc;</span><br><span class="line">  pop_off();</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>执行 <code>make grade</code> 进行评分：</p>
<img src="/2023/03/12/mit6-s081-lab3-page-tables/image-20230312105012660.png" alt="image-20230312105012660" style="zoom:67%;">

<p>代码仓库地址：<a target="_blank" rel="noopener" href="https://github.com/Xinlong-Chen/mit6.S081-2021fall/tree/pgtbl">代码</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a target="_blank" rel="noopener" href="https://github.com/riscv/riscv-isa-manual/releases/download/draft-20200727-8088ba4/riscv-privileged.pdf">RISC-V privileged instructions</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>mit6.s081 - lab3 page tables</p><p><a href="https://xinlong-chen.github.io/2023/03/12/mit6-s081-lab3-page-tables/">https://xinlong-chen.github.io/2023/03/12/mit6-s081-lab3-page-tables/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Xinlong-Chen</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-03-12</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-08-27</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/mit6-s081/">mit6.s081</a><a class="link-muted mr-2" rel="tag" href="/tags/xv6/">xv6</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/03/12/mit6-s081-xv6-Page-Mapping/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">mit6.s081 - xv6建立虚拟地址映射</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/03/11/mit6-s081-xv6-Paging/"><span class="level-item">mit6.s081 - xv6虚拟地址转换</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><script src="https://utteranc.es/client.js" repo="Xinlong-Chen/Xinlong-Chen.github.io" issue-term="pathname" label="some-issue-label" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar2.png" alt="Xinlong Chen"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Xinlong Chen</p><p class="is-size-6 is-block">os | db</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Canton</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">100</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Xinlong-Chen" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Xinlong-Chen"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#task-1-Speed-up-system-calls-easy"><span class="level-left"><span class="level-item">1</span><span class="level-item">task 1: Speed up system calls (easy)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题意描述"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">题意描述</span></span></a></li><li><a class="level is-mobile" href="#解决思路"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">解决思路</span></span></a></li><li><a class="level is-mobile" href="#实现"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#task-2-Print-a-page-table-easy"><span class="level-left"><span class="level-item">2</span><span class="level-item">task 2: Print a page table (easy)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题意描述-1"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">题意描述</span></span></a></li><li><a class="level is-mobile" href="#解决思路-1"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">解决思路</span></span></a></li><li><a class="level is-mobile" href="#实现-1"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#task-3-Detecting-which-pages-have-been-accessed-hard"><span class="level-left"><span class="level-item">3</span><span class="level-item">task 3: Detecting which pages have been accessed (hard)</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#题意描述-2"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">题意描述</span></span></a></li><li><a class="level is-mobile" href="#解决思路-2"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">解决思路</span></span></a></li><li><a class="level is-mobile" href="#实现-2"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">实现</span></span></a></li></ul></li><li><a class="level is-mobile" href="#测试结果"><span class="level-left"><span class="level-item">4</span><span class="level-item">测试结果</span></span></a></li><li><a class="level is-mobile" href="#参考资料"><span class="level-left"><span class="level-item">5</span><span class="level-item">参考资料</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.cnblogs.com/cxl-" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">cnblog</span></span><span class="level-right"><span class="level-item tag">www.cnblogs.com</span></span></a></li><li><a class="level is-mobile" href="https://blog.csdn.net/hrbust_cxl" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">csdn</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">分布式系统</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">前端</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"><span class="level-start"><span class="level-item">工具使用</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">40</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">数据库系统</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"><span class="level-start"><span class="level-item">杂七杂八</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%A1%AC%E4%BB%B6/"><span class="level-start"><span class="level-item">硬件</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-28T13:27:52.000Z">2023-08-28</time></p><p class="title"><a href="/2023/08/28/mysql-catalog/">MySQL - 数据目录</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/">数据库系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-28T11:42:52.000Z">2023-08-28</time></p><p class="title"><a href="/2023/08/28/mysql-B-Tree-how-to-use/">MySQL - 如何使用B+树索引</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/">数据库系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-28T09:15:52.000Z">2023-08-28</time></p><p class="title"><a href="/2023/08/28/mysql-B-Tree/">MySQL - B+树索引</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/">数据库系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-28T07:28:52.000Z">2023-08-28</time></p><p class="title"><a href="/2023/08/28/mysql-index-page/">MySQL - InnoDB 数据页结构</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/">数据库系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-28T01:55:52.000Z">2023-08-28</time></p><p class="title"><a href="/2023/08/28/mysql-record-struct/">MySQL - InnoDB 行格式</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/">数据库系统</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">71</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">25</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/algorithm/"><span class="tag">algorithm</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cmu15445/"><span class="tag">cmu15445</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cpp/"><span class="tag">cpp</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/debug/"><span class="tag">debug</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/effective-C/"><span class="tag">effective C++</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hitos/"><span class="tag">hitos</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux0-11/"><span class="tag">linux0.11</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux%E4%BD%BF%E7%94%A8/"><span class="tag">linux使用</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux%E7%BC%96%E7%A8%8B/"><span class="tag">linux编程</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/missing-semester/"><span class="tag">missing semester</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mit6-824/"><span class="tag">mit6.824</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mit6-s081/"><span class="tag">mit6.s081</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ostep/"><span class="tag">ostep</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qt/"><span class="tag">qt</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/stl/"><span class="tag">stl</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xv6/"><span class="tag">xv6</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"><span class="tag">分布式系统</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/"><span class="tag">操作系统理论</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"><span class="tag">树莓派</span><span class="tag">2</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar3.png" alt="Xinlong-Chen&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Xinlong-Chen</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>