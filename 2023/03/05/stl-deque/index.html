<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>STL - deque源码分析 - Xinlong-Chen&#039;s blog</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#3273dc"><meta name="application-name" content="Xinlong Chen&#039;s blog"><meta name="msapplication-TileImage" content="/img/avatar3.png"><meta name="msapplication-TileColor" content="#3273dc"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Xinlong Chen&#039;s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="deque概述deque是一种双向开口的“连续”线性空间（即可以在头尾两端分别做元素的插入和删除操作）。"><meta property="og:type" content="blog"><meta property="og:title" content="STL - deque源码分析"><meta property="og:url" content="https://xinlong-chen.github.io/2023/03/05/stl-deque/"><meta property="og:site_name" content="Xinlong-Chen&#039;s blog"><meta property="og:description" content="deque概述deque是一种双向开口的“连续”线性空间（即可以在头尾两端分别做元素的插入和删除操作）。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://xinlong-chen.github.io/2023/03/05/stl-deque/1659233-20210331190400722-1934546150.png"><meta property="og:image" content="https://xinlong-chen.github.io/2023/03/05/stl-deque/1659233-20210331190410650-118395508.png"><meta property="og:image" content="https://xinlong-chen.github.io/2023/03/05/stl-deque/1659233-20210331190429201-661795156.png"><meta property="article:published_time" content="2023-03-05T15:02:41.000Z"><meta property="article:modified_time" content="2023-08-27T12:05:06.436Z"><meta property="article:author" content="Xinlong-Chen"><meta property="article:tag" content="stl"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://xinlong-chen.github.io/2023/03/05/stl-deque/1659233-20210331190400722-1934546150.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://xinlong-chen.github.io/2023/03/05/stl-deque/"},"headline":"STL - deque源码分析","image":["https://xinlong-chen.github.io/2023/03/05/stl-deque/1659233-20210331190400722-1934546150.png","https://xinlong-chen.github.io/2023/03/05/stl-deque/1659233-20210331190410650-118395508.png","https://xinlong-chen.github.io/2023/03/05/stl-deque/1659233-20210331190429201-661795156.png"],"datePublished":"2023-03-05T15:02:41.000Z","dateModified":"2023-08-27T12:05:06.436Z","author":{"@type":"Person","name":"Xinlong-Chen"},"publisher":{"@type":"Organization","name":"Xinlong-Chen's blog","logo":{"@type":"ImageObject","url":"https://xinlong-chen.github.io/img/avatar3.png"}},"description":"deque概述deque是一种双向开口的“连续”线性空间（即可以在头尾两端分别做元素的插入和删除操作）。"}</script><link rel="canonical" href="https://xinlong-chen.github.io/2023/03/05/stl-deque/"><link rel="icon" href="/img/avatar3.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar3.png" alt="Xinlong-Chen&#039;s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-03-05T15:02:41.000Z" title="2023/3/5 下午11:02:41">2023-03-05</time>发表</span><span class="level-item"><time dateTime="2023-08-27T12:05:06.436Z" title="2023/8/27 下午8:05:06">2023-08-27</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/C/">C++</a></span><span class="level-item">33 分钟读完 (大约4918个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">STL - deque源码分析</h1><div class="content"><h4 id="deque概述"><a href="#deque概述" class="headerlink" title="deque概述"></a>deque概述</h4><p>deque是一种双向开口的“连续”线性空间（即可以在头尾两端分别做元素的插入和删除操作）。</p>
<span id="more"></span>

<p>deque与vector的差别：</p>
<ol>
<li>deque允许在常数时间内对头端进行元素的插入和删除操作，vector尾部插入和删除常数时间，头部操作O（n）时间</li>
<li>deque没有容量概念，不需要和vector一样进行老三样：申请新空间-&gt;复制元素-&gt;释放旧空间</li>
<li>deque的Ramdon Access Iterator进行过特殊设计，复杂度比vector高。</li>
</ol>
<h4 id="deque的中控器"><a href="#deque的中控器" class="headerlink" title="deque的中控器"></a>deque的中控器</h4><h5 id="底层内存分布"><a href="#底层内存分布" class="headerlink" title="底层内存分布"></a>底层内存分布</h5><p>deque的“连续”空间只是在逻辑上连续的，实际上deque是由一段一段的定量连续空间构成。一旦有必要在deque的头端或尾端增加新空间，便配置一段定量的连续空间，串接在整个deque的头端或尾端。</p>
<p>deque的核心任务是维护 <strong>分段的定量连续空间</strong>整体连续的假象，并提供随机存取的接口，避免vector的申请新空间-&gt;复制元素-&gt;释放旧空间，但其代价是deque的迭代器架构较复杂。</p>
<p><img src="/2023/03/05/stl-deque/1659233-20210331190400722-1934546150.png"></p>
<h5 id="中控器"><a href="#中控器" class="headerlink" title="中控器"></a>中控器</h5><p>正如上面那张图看到的，对于<strong>分段的定量连续空间</strong>，我们需要一个map（就是一小段连续空间，和数组类似）来指示他（就像一个包租婆有很多房子，手里得有一个地图，找到他的每个房子）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc, <span class="type">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line"><span class="keyword">class</span> deque &#123;</span><br><span class="line"><span class="keyword">public</span>:                         <span class="comment">// Basic types</span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"><span class="keyword">protected</span>:                      <span class="comment">// Internal typedefs</span></span><br><span class="line">  <span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  map_pointer map;<span class="comment">//指向指针数组 T** 类似于二维数组 T*指向一个缓冲区，T**就是这个map</span></span><br><span class="line">  size_type map_size;<span class="comment">//指针数组元素个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/03/05/stl-deque/1659233-20210331190410650-118395508.png"></p>
<h4 id="deque的迭代器"><a href="#deque的迭代器" class="headerlink" title="deque的迭代器"></a>deque的迭代器</h4><h5 id="迭代器结构"><a href="#迭代器结构" class="headerlink" title="迭代器结构"></a>迭代器结构</h5><p>deque是<strong>分段连续空间</strong>，维护“整体连续”假象的任务就落在了operator++和operator–两个运算上了。</p>
<p>我们可以想象，一个iterator指向一个缓冲区（buffer）内元素时，当到了一个buffer的末端则需要跳到下一个buffer，到了buffer的头端则需要跳转到前一个buffer，这里则需要我们前面所说的map来调节。如何知道我们是否在buffer的头尾端呢？这就需要iterator保存这个buffer的begin和end了。</p>
<p>综上，deque的iterator需要以下元素：</p>
<ol>
<li>指向当前元素的指针</li>
<li>指向当前buffer头端的指针</li>
<li>指向当前buffer尾端的指针</li>
<li>指向map中控的指针</li>
</ol>
<p>SGI STL中源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>, <span class="type">size_t</span> BufSiz&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__deque_iterator</span> &#123; 	<span class="comment">// 未继承 std::iterator</span></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;      iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*, BufSiz&gt; const_iterator;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">buffer_size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="built_in">sizeof</span>(T)); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* __STL_NON_TYPE_TMPL_PARAM_BUG */</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Ref</span>, <span class="keyword">class</span> <span class="title class_">Ptr</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__deque_iterator</span> &#123; 	<span class="comment">// 未继承 std::iterator</span></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="type">const</span> T&amp;, <span class="type">const</span> T*&gt; const_iterator;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">buffer_size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> __deque_buf_size(<span class="number">0</span>, <span class="built_in">sizeof</span>(T)); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 未继承 std::iterator，所以必须自己写五个必要的迭代器相应型别</span></span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="comment">// (1)</span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type; 				<span class="comment">// (2)</span></span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer; 				<span class="comment">// (3)</span></span><br><span class="line">  <span class="keyword">typedef</span> Ref reference; 				<span class="comment">// (4)</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type; 	<span class="comment">// (5)</span></span><br><span class="line">  <span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保持与容器的联结</span></span><br><span class="line">  T* cur;	<span class="comment">// 此迭代器所指之缓冲区中的现行（current）元素</span></span><br><span class="line">  T* first;	<span class="comment">// 此迭代器所指之缓冲区头</span></span><br><span class="line">  T* last;	<span class="comment">// 此迭代器所指之缓冲区尾（含备用空间）</span></span><br><span class="line">  map_pointer node;</span><br><span class="line"></span><br><span class="line">  __deque_iterator(T* x, map_pointer y) </span><br><span class="line">    : <span class="built_in">cur</span>(x), <span class="built_in">first</span>(*y), <span class="built_in">last</span>(*y + <span class="built_in">buffer_size</span>()), <span class="built_in">node</span>(y) &#123;&#125;</span><br><span class="line">  __deque_iterator() : <span class="built_in">cur</span>(<span class="number">0</span>), <span class="built_in">first</span>(<span class="number">0</span>), <span class="built_in">last</span>(<span class="number">0</span>), <span class="built_in">node</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  __deque_iterator(<span class="type">const</span> iterator&amp; x)</span><br><span class="line">    : <span class="built_in">cur</span>(x.cur), <span class="built_in">first</span>(x.first), <span class="built_in">last</span>(x.last), <span class="built_in">node</span>(x.node) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中用来决定缓冲区大小的函数buffer_size()，调用__deque_buf_size()</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 n 不为 0，传回 n，表示 buffer size 由使用者自定。</span></span><br><span class="line"><span class="comment">// 如果 n 为 0，表示buffer size 使用预设值，那么</span></span><br><span class="line"><span class="comment">//   如果 sz（元素大小，sizeof(value_type)）小于 512，传回 512/sz，</span></span><br><span class="line"><span class="comment">//   如果 sz 不小于 512，传回 1。</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">size_t</span> __deque_buf_size(<span class="type">size_t</span> n, <span class="type">size_t</span> sz)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="built_in">size_t</span>(<span class="number">512</span> / sz) : <span class="built_in">size_t</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有了迭代器，缓存区，中控map，我们的deque的原型就出来啦：</p>
<p><img src="/2023/03/05/stl-deque/1659233-20210331190429201-661795156.png"></p>
<h5 id="迭代器操作"><a href="#迭代器操作" class="headerlink" title="迭代器操作"></a>迭代器操作</h5><p>迭代器到buffer边缘，则需要请求中控map，看怎么跳转buffer。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span> </span>&#123;</span><br><span class="line">    node = new_node;</span><br><span class="line">    first = *new_node;</span><br><span class="line">    last = first + <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解引用操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> *cur; &#125;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="type">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br></pre></td></tr></table></figure>

<p>计算两迭代器之间距离：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个iterator相减，计算距离</span></span><br><span class="line">difference_type <span class="keyword">operator</span>-(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) * (node - x.node - <span class="number">1</span>) +</span><br><span class="line">           (cur - first) + (x.last - x.cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器的++、–操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考 More Effective C++, item6: Distinguish between prefix and</span></span><br><span class="line"><span class="comment">// postfix forms of increment and decrement operators.</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    ++cur;				<span class="comment">// 切换至下一个元素。</span></span><br><span class="line">    <span class="keyword">if</span> (cur == last) &#123;		<span class="comment">// 如果已达所在缓冲区的尾端，</span></span><br><span class="line">        <span class="built_in">set_node</span>(node + <span class="number">1</span>);	<span class="comment">// 就切换至下一个节点（亦即缓冲区）</span></span><br><span class="line">        cur = first;			<span class="comment">//   的第一个元素。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>)  &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == first) &#123;	<span class="comment">// 如果已达所在缓冲区的头端，</span></span><br><span class="line">        <span class="built_in">set_node</span>(node - <span class="number">1</span>);	<span class="comment">// 就切换至前一个节点（亦即缓冲区）</span></span><br><span class="line">        cur = last;			<span class="comment">//   的最后一个元素。</span></span><br><span class="line">    &#125;</span><br><span class="line">    --cur;				<span class="comment">// 切换至前一个元素。</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">self <span class="keyword">operator</span>--(<span class="type">int</span>) &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器+一个数值访问实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 參考 More Effective C++, item22: Consider using op= instead of</span></span><br><span class="line"><span class="comment">// stand-alone op.</span></span><br><span class="line">self <span class="keyword">operator</span>+(difference_type n) <span class="type">const</span> &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp += n; <span class="comment">// 调用operator+=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n) &#123;</span><br><span class="line">    difference_type offset = n + (cur - first);</span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()))</span><br><span class="line">        <span class="comment">// 目标位置在同一缓冲区內</span></span><br><span class="line">        cur += n;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 目标位置不在同一缓冲区內</span></span><br><span class="line">        difference_type node_offset =</span><br><span class="line">                offset &gt; <span class="number">0</span> ? offset / <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>())</span><br><span class="line">                           : -<span class="built_in">difference_type</span>((-offset - <span class="number">1</span>) / <span class="built_in">buffer_size</span>()) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 切换至正确的节点（亦即缓冲区）</span></span><br><span class="line">        <span class="built_in">set_node</span>(node + node_offset);</span><br><span class="line">        <span class="comment">// 切换至正确的元素</span></span><br><span class="line">        cur = first + (offset - node_offset * <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 參考 More Effective C++, item22: Consider using op= instead of  </span></span><br><span class="line"><span class="comment">// stand-alone op.</span></span><br><span class="line">self <span class="keyword">operator</span>-(difference_type n) <span class="type">const</span> &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp -= n; <span class="comment">// 调用operator-=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>-=(difference_type n) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> += -n; &#125;</span><br><span class="line"><span class="comment">// 以上利用operator+= 来完成 operator-=</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>随机访问实现，模拟连续空间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//随机存取实现</span></span><br><span class="line">reference <span class="keyword">operator</span>[](difference_type n) <span class="type">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + n); &#125;</span><br><span class="line"><span class="comment">// 以上调用operator*, operator+</span></span><br></pre></td></tr></table></figure>

<p>迭代器的比较操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> cur == x.cur; &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == x); &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> self&amp; x) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="deque的数据结构"><a href="#deque的数据结构" class="headerlink" title="deque的数据结构"></a>deque的数据结构</h4><p>deque除了维护一个map中控和map中控大小外，还维护了start、finish两个迭代器，分别指向第一个buffer的第一个元素和最后buffer的最后一个元素的下一个位置（左闭右开）。map中控大小的作用是：一旦节点不足，就得配置一块更大的map。</p>
<p>deque的数据结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span> = alloc, <span class="type">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line"><span class="keyword">class</span> deque &#123;</span><br><span class="line"><span class="keyword">public</span>:                         <span class="comment">// Basic types</span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:                      <span class="comment">// Internal typedefs</span></span><br><span class="line">  <span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">static</span> size_type <span class="title">buffer_size</span><span class="params">()</span> </span>&#123;<span class="comment">//返回</span></span><br><span class="line">    <span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="built_in">sizeof</span>(value_type));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">static</span> size_type <span class="title">initial_map_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">8</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:                      <span class="comment">// Data members</span></span><br><span class="line">  map_pointer map;<span class="comment">//指向指针数组</span></span><br><span class="line">  size_type map_size;<span class="comment">//指针数组元素个数</span></span><br><span class="line">  iterator start;<span class="comment">//开始迭代器，其中cur指向头部元素</span></span><br><span class="line">  iterator finish;<span class="comment">//结束迭代器，其中cur指向尾部元素后面的一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>deque的基本对外接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:                         <span class="comment">// Basic accessors</span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line"></span><br><span class="line">reference <span class="keyword">operator</span>[](size_type n) &#123;</span><br><span class="line">    <span class="keyword">return</span> start[<span class="built_in">difference_type</span>(n)]; <span class="comment">// 调用 __deque_iterator&lt;&gt;::operator[]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const_reference <span class="keyword">operator</span>[](size_type n) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> start[<span class="built_in">difference_type</span>(n)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *start; &#125; <span class="comment">// 调用 __deque_iterator&lt;&gt;::operator*</span></span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    iterator tmp = finish;</span><br><span class="line">    --tmp;    <span class="comment">// 调用 __deque_iterator&lt;&gt;::operator--</span></span><br><span class="line">    <span class="keyword">return</span> *tmp;    <span class="comment">// 调用 __deque_iterator&lt;&gt;::operator*</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> finish - start; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上调用iterator::operator-</span></span><br><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> finish == start; &#125;</span><br></pre></td></tr></table></figure>



<h4 id="deque的构造与内存管理"><a href="#deque的构造与内存管理" class="headerlink" title="deque的构造与内存管理"></a>deque的构造与内存管理</h4><h5 id="deque的ctor"><a href="#deque的ctor" class="headerlink" title="deque的ctor"></a>deque的ctor</h5><p>deque自行定义了两个空间配置器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:                      <span class="comment">// Internal typedefs</span></span><br><span class="line"><span class="comment">// 专属之空间配置器，每次配置一个元素大小</span></span><br><span class="line"><span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line"><span class="comment">// 专属之空间配置器，每次配置一个指标大小</span></span><br><span class="line"><span class="keyword">typedef</span> simple_alloc&lt;pointer, Alloc&gt; map_allocator;</span><br></pre></td></tr></table></figure>

<p>并有如下构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>(size_type n, <span class="type">const</span> value_type&amp; value)</span><br><span class="line">  : <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fill_initialize</span>(n, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fill_initialize()负责产生并安排好deque的结构，并将元素的初值设置好：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">fill_initialize</span>(size_type n,</span><br><span class="line">                                               <span class="type">const</span> value_type&amp; value) &#123;</span><br><span class="line">    <span class="built_in">create_map_and_nodes</span>(n);	 <span class="comment">// 把deque的结构都产生并安排好</span></span><br><span class="line">    map_pointer cur;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">            <span class="comment">// 为每个节点的缓冲区設定初值</span></span><br><span class="line">            <span class="keyword">for</span> (cur = start.node; cur &lt; finish.node; ++cur)</span><br><span class="line">            <span class="built_in">uninitialized_fill</span>(*cur, *cur + <span class="built_in">buffer_size</span>(), value);</span><br><span class="line">            <span class="comment">// 最后一个节点的设定稍有不同（因为尾端可能有备用空间，不必设初值）</span></span><br><span class="line">            <span class="built_in">uninitialized_fill</span>(finish.first, finish.cur, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">    <span class="comment">// &quot;commit or rollback&quot; ：若非全部成功，就一个不留。</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其中create_map_and_nodes()复制产生并安排好deque的结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">create_map_and_nodes</span>(size_type num_elements) &#123;</span><br><span class="line">    <span class="comment">// 需要节点数=(元素个数/每个缓冲区可容纳的元素个数)+1</span></span><br><span class="line">    <span class="comment">// 如果刚好整除，會多配一个节点。</span></span><br><span class="line">    size_type num_nodes = num_elements / <span class="built_in">buffer_size</span>() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个 map 要管理几个节点。最少8个，最多是 “所需节点数加2”</span></span><br><span class="line">    <span class="comment">// （前后各預留一个，扩充時可用）。</span></span><br><span class="line">    map_size = <span class="built_in">max</span>(<span class="built_in">initial_map_size</span>(), num_nodes + <span class="number">2</span>);</span><br><span class="line">    map = map_allocator::<span class="built_in">allocate</span>(map_size);</span><br><span class="line">    <span class="comment">// 以上配置出一个 “具有 map_size个节点” 的map。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下令nstart和nfinish指向map所拥有之全部节点的最中央区段。</span></span><br><span class="line">    <span class="comment">// 保持在最中央，可使头尾两端的扩充能量一样大。每个节点可对应一个缓冲区。</span></span><br><span class="line">    map_pointer nstart = map + (map_size - num_nodes) / <span class="number">2</span>;</span><br><span class="line">    map_pointer nfinish = nstart + num_nodes - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    map_pointer cur;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">            <span class="comment">// 为map內的每个現用节点配置缓冲区。所有缓冲区加起来就是deque的空间</span></span><br><span class="line">            <span class="comment">// （最后一个缓冲区可能留有一些余裕）。</span></span><br><span class="line">            <span class="keyword">for</span> (cur = nstart; cur &lt;= nfinish; ++cur)</span><br><span class="line">            *cur = <span class="built_in">allocate_node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">    <span class="comment">// &quot;commit or rollback&quot; ：若非全部成功，就一个不留。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 为deque内的两个迭代器start和end 設定正确的内容。</span></span><br><span class="line">  start.<span class="built_in">set_node</span>(nstart);</span><br><span class="line">  finish.<span class="built_in">set_node</span>(nfinish);</span><br><span class="line">  start.cur = start.first;		<span class="comment">// first, cur都是public</span></span><br><span class="line">  finish.cur = finish.first + num_elements % <span class="built_in">buffer_size</span>();</span><br><span class="line">  <span class="comment">// 前面说过，如果刚好整除，会多配一个节点。</span></span><br><span class="line">  <span class="comment">// 此时即令cur指向這多配的一個节点（所对应之缓冲区）的起点。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="push-back-amp-push-front"><a href="#push-back-amp-push-front" class="headerlink" title="push_back() &amp; push_front()"></a>push_back() &amp; push_front()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:                         <span class="comment">// push_* and pop_*</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> value_type&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish.cur != finish.last - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 最后缓冲区尚有一个以上的备用空间</span></span><br><span class="line">        <span class="built_in">construct</span>(finish.cur, t);	<span class="comment">// 直接在备用空间上建构元素</span></span><br><span class="line">        ++finish.cur;	<span class="comment">// 調整最后缓冲区的使用状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// 最后缓冲区已无（或只剩一个）元素备用空间。</span></span><br><span class="line">        <span class="built_in">push_back_aux</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尾端只有一个元素备用空间时，push_back调用push_back_aux()，先设置一整块的buffer，再设置新元素内容，然后更改finish：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有当 finish.cur == finish.last – 1 时才会被呼叫。</span></span><br><span class="line"><span class="comment">// 也就是说只有当最后一个缓冲区只剩一个备用元素空間时才会被呼叫。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">push_back_aux</span>(<span class="type">const</span> value_type&amp; t) &#123;</span><br><span class="line">    value_type t_copy = t;</span><br><span class="line">    <span class="built_in">reserve_map_at_back</span>();		<span class="comment">//  若符合某种条件則必須重换一个map</span></span><br><span class="line">    *(finish.node + <span class="number">1</span>) = <span class="built_in">allocate_node</span>();	<span class="comment">// 配置一个新节点（缓冲区）</span></span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">            <span class="built_in">construct</span>(finish.cur, t_copy);		<span class="comment">// 设值</span></span><br><span class="line">            finish.<span class="built_in">set_node</span>(finish.node + <span class="number">1</span>);	<span class="comment">// 改变finish，令其指向新节点</span></span><br><span class="line">            finish.cur = finish.first;			<span class="comment">// 設定 finish 的状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">deallocate_node</span>(*(finish.node + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>push_front()和push_back()同理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">const</span> value_type&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start.cur != start.first) &#123; 	<span class="comment">// 第一缓冲区尚有备用空間</span></span><br><span class="line">        <span class="built_in">construct</span>(start.cur - <span class="number">1</span>, t); 	<span class="comment">// 直接在备用空間上建构元素</span></span><br><span class="line">        --start.cur;		<span class="comment">// 调整第一缓冲区的使用状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 第一缓冲区已无备用空間</span></span><br><span class="line">        <span class="built_in">push_front_aux</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有当start.cur == start.first時才会被呼叫。</span></span><br><span class="line"><span class="comment">// 也就是说只有当第一个缓冲区沒有任何备用元素時才会被呼叫。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">push_front_aux</span>(<span class="type">const</span> value_type&amp; t) &#123;</span><br><span class="line">    value_type t_copy = t;</span><br><span class="line">    <span class="built_in">reserve_map_at_front</span>();		<span class="comment">//  若符合某种条件則必須重换一个map</span></span><br><span class="line">    *(start.node - <span class="number">1</span>) = <span class="built_in">allocate_node</span>();	<span class="comment">// 配置一个新节点（缓冲区）</span></span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">            start.<span class="built_in">set_node</span>(start.node - <span class="number">1</span>);		<span class="comment">// 改变start，令其指向新节点</span></span><br><span class="line">            start.cur = start.last - <span class="number">1</span>;			<span class="comment">// 设定 start的状态</span></span><br><span class="line">            <span class="built_in">construct</span>(start.cur, t_copy);		<span class="comment">// 设值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">    <span class="comment">// &quot;commit or rollback&quot; ：若非全部成功，就一个不留。</span></span><br><span class="line">        start.<span class="built_in">set_node</span>(start.node + <span class="number">1</span>);</span><br><span class="line">        start.cur = start.first;</span><br><span class="line">        <span class="built_in">deallocate_node</span>(*(start.node - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，整治map的操作reserve_map_at_back()和reserve_map_at_front()为调用reallocate_map()：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve_map_at_back</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes_to_add + <span class="number">1</span> &gt; map_size - (finish.node - map))</span><br><span class="line">        <span class="comment">// 如果 map 尾端的节点备用空间不足</span></span><br><span class="line">        <span class="comment">// 符合以上条件則必須重换一个map（配置更大的，拷贝原來的，释放原來的）</span></span><br><span class="line">        <span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reserve_map_at_front</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes_to_add &gt; start.node - map)</span><br><span class="line">        <span class="comment">// 如果 map 前端的节点备用空间不足</span></span><br><span class="line">        <span class="comment">// 符合以上条件則必須重换一个map（配置更大的，拷贝原來的，释放原來的）</span></span><br><span class="line">        <span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>reallocate_map()函数实现为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">reallocate_map</span>(size_type nodes_to_add,</span><br><span class="line">                                              <span class="type">bool</span> add_at_front) &#123;</span><br><span class="line">    size_type old_num_nodes = finish.node - start.node + <span class="number">1</span>;</span><br><span class="line">    size_type new_num_nodes = old_num_nodes + nodes_to_add;</span><br><span class="line"></span><br><span class="line">    map_pointer new_nstart;</span><br><span class="line">    <span class="keyword">if</span> (map_size &gt; <span class="number">2</span> * new_num_nodes) &#123;</span><br><span class="line">        new_nstart = map + (map_size - new_num_nodes) / <span class="number">2</span></span><br><span class="line">                     + (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (new_nstart &lt; start.node)</span><br><span class="line">            <span class="built_in">copy</span>(start.node, finish.node + <span class="number">1</span>, new_nstart);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">copy_backward</span>(start.node, finish.node + <span class="number">1</span>, new_nstart + old_num_nodes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        size_type new_map_size = map_size + <span class="built_in">max</span>(map_size, nodes_to_add) + <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 配置一块空間，准备给新map使用。</span></span><br><span class="line">        map_pointer new_map = map_allocator::<span class="built_in">allocate</span>(new_map_size);</span><br><span class="line">        new_nstart = new_map + (new_map_size - new_num_nodes) / <span class="number">2</span></span><br><span class="line">                     + (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 把原map 內容拷贝过来。</span></span><br><span class="line">        <span class="built_in">copy</span>(start.node, finish.node + <span class="number">1</span>, new_nstart);</span><br><span class="line">        <span class="comment">// 释放原map</span></span><br><span class="line">        map_allocator::<span class="built_in">deallocate</span>(map, map_size);</span><br><span class="line">        <span class="comment">// 设定新map的起始位址与大小</span></span><br><span class="line">        map = new_map;</span><br><span class="line">        map_size = new_map_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新设定迭代器 start 和 finish</span></span><br><span class="line">    start.<span class="built_in">set_node</span>(new_nstart);</span><br><span class="line">    finish.<span class="built_in">set_node</span>(new_nstart + old_num_nodes - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="deque的元素操作"><a href="#deque的元素操作" class="headerlink" title="deque的元素操作"></a>deque的元素操作</h4><h5 id="pop-back-amp-pop-front"><a href="#pop-back-amp-pop-front" class="headerlink" title="pop_back() &amp; pop_front()"></a>pop_back() &amp; pop_front()</h5><p>pop操作和push操作相反，pop是要把元素拿掉，push需要考虑加入buffer，而pop则需要考虑释放buffer。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish.cur != finish.first) &#123;</span><br><span class="line">        <span class="comment">// 最后缓冲区有一个（或更多）元素</span></span><br><span class="line"></span><br><span class="line">        --finish.cur;		<span class="comment">// 调整指标，相当于排除了最后元素</span></span><br><span class="line">        <span class="built_in">destroy</span>(finish.cur);	<span class="comment">// 将最后元素析构</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 最后缓冲区没有任何元素</span></span><br><span class="line">        <span class="built_in">pop_back_aux</span>();		<span class="comment">// 這里将进行缓冲区的释放工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有当finish.cur == finish.first时才會被呼叫。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">pop_back_aux</span>() &#123;</span><br><span class="line">    <span class="built_in">deallocate_node</span>(finish.first);	<span class="comment">// 释放最后一个缓冲区</span></span><br><span class="line">    finish.<span class="built_in">set_node</span>(finish.node - <span class="number">1</span>);	<span class="comment">// 调整 finish 的状态，使指向</span></span><br><span class="line">    finish.cur = finish.last - <span class="number">1</span>;		<span class="comment">//  上一个缓冲区的最后一个元素</span></span><br><span class="line">    <span class="built_in">destroy</span>(finish.cur);				<span class="comment">// 将该元素析构。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start.cur != start.last - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 第一缓冲区有一个（或更多）元素</span></span><br><span class="line">        <span class="built_in">destroy</span>(start.cur);	<span class="comment">// 将第一元素析构</span></span><br><span class="line">        ++start.cur;			<span class="comment">// 调整指标，相当于排除了第一元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 第一缓冲区僅有一个元素</span></span><br><span class="line">        <span class="built_in">pop_front_aux</span>();		<span class="comment">// 這里将进行缓冲区的释放工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有当start.cur == start.last - 1时才會被呼叫。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">pop_front_aux</span>() &#123;</span><br><span class="line">    <span class="built_in">destroy</span>(start.cur);				<span class="comment">// 将第一缓冲区的第一个元素析构。</span></span><br><span class="line">    <span class="built_in">deallocate_node</span>(start.first);		<span class="comment">// 释放第一缓冲区。</span></span><br><span class="line">    start.<span class="built_in">set_node</span>(start.node + <span class="number">1</span>);	<span class="comment">// 调整 start 的状态，使指向</span></span><br><span class="line">    start.cur = start.first;			<span class="comment">//  下一个缓冲区的第一个元素。</span></span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>



<h5 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h5><p>clear()用于清空deque，deque在初始的时候有一个buffer，因此clear之后，也应该有一个buffer。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意，最終需要保留一個緩衝區。這是deque 的策略，也是deque 的初始狀態。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="type">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">clear</span>() &#123;</span><br><span class="line">    <span class="comment">// 以下針對頭尾以外的每一個緩衝區（它們一定都是飽滿的）</span></span><br><span class="line">    <span class="keyword">for</span> (map_pointer node = start.node + <span class="number">1</span>; node &lt; finish.node; ++node) &#123;</span><br><span class="line">        <span class="comment">// 將緩衝區內的所有元素解構。注意，呼叫的是destroy() 第二版本，見2.2.3節</span></span><br><span class="line">        <span class="built_in">destroy</span>(*node, *node + <span class="built_in">buffer_size</span>());</span><br><span class="line">        <span class="comment">// 釋放緩衝區記憶體</span></span><br><span class="line">        data_allocator::<span class="built_in">deallocate</span>(*node, <span class="built_in">buffer_size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start.node != finish.node) &#123;	<span class="comment">// 至少有頭尾兩個緩衝區</span></span><br><span class="line">        <span class="built_in">destroy</span>(start.cur, start.last);	<span class="comment">// 將頭緩衝區的目前所有元素解構</span></span><br><span class="line">        <span class="built_in">destroy</span>(finish.first, finish.cur); <span class="comment">// 將尾緩衝區的目前所有元素解構</span></span><br><span class="line">        <span class="comment">// 以下釋放尾緩衝區。注意，頭緩衝區保留。</span></span><br><span class="line">        data_allocator::<span class="built_in">deallocate</span>(finish.first, <span class="built_in">buffer_size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">// 只有一個緩衝區</span></span><br><span class="line">        <span class="built_in">destroy</span>(start.cur, finish.cur);	<span class="comment">// 將此唯一緩衝區內的所有元素解構</span></span><br><span class="line">    <span class="comment">// 注意，並不釋放緩衝區空間。這唯一的緩衝區將保留。</span></span><br><span class="line"></span><br><span class="line">    finish = start;	<span class="comment">// 調整狀態</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="erase"><a href="#erase" class="headerlink" title="erase()"></a>erase()</h5><p>erase()函数可以清除一个iterator的内容，也可以清除一个范围的内容。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除 pos 所指的元素。pos 為清除點。</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span> </span>&#123;</span><br><span class="line">    iterator next = pos;</span><br><span class="line">    ++next;</span><br><span class="line">    difference_type index = pos - start;    <span class="comment">// 清除點之前的元素個數</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>)) &#123;            <span class="comment">// 如果清除點之前的元素比較少，</span></span><br><span class="line">        <span class="built_in">copy_backward</span>(start, pos, next);    <span class="comment">// 就搬移清除點之前的元素</span></span><br><span class="line">        <span class="built_in">pop_front</span>();                <span class="comment">// 搬移完畢，最前一個元素贅餘，去除之</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// 清除點之後的元素比較少，</span></span><br><span class="line">        <span class="built_in">copy</span>(next, finish, pos);    <span class="comment">// 就搬移清除點之後的元素</span></span><br><span class="line">        <span class="built_in">pop_back</span>();                <span class="comment">// 搬移完畢，最後一個元素贅餘，去除之</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start + index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::iterator deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">erase</span>(iterator first, iterator last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (first == start &amp;&amp; last == finish) &#123; <span class="comment">// 如果清除區間就是整個 deque</span></span><br><span class="line">        <span class="built_in">clear</span>();                            <span class="comment">// 直接呼叫 clear() 即可</span></span><br><span class="line">        <span class="keyword">return</span> finish;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        difference_type n = last - first;            <span class="comment">// 清除區間的長度</span></span><br><span class="line">        difference_type elems_before = first - start;    <span class="comment">// 清除區間前方的元素個數</span></span><br><span class="line">        <span class="keyword">if</span> (elems_before &lt; (<span class="built_in">size</span>() - n) / <span class="number">2</span>) &#123;        <span class="comment">// 如果前方的元素比較少，</span></span><br><span class="line">            <span class="built_in">copy_backward</span>(start, first, last);        <span class="comment">// 向後搬移前方元素（覆蓋清除區間）</span></span><br><span class="line">            iterator new_start = start + n;            <span class="comment">// 標記 deque 的新起點</span></span><br><span class="line">            <span class="built_in">destroy</span>(start, new_start);                <span class="comment">// 搬移完畢，將贅餘的元素解構</span></span><br><span class="line"><span class="comment">// 以下將贅餘的緩衝區釋放</span></span><br><span class="line">            <span class="keyword">for</span> (map_pointer cur = start.node; cur &lt; new_start.node; ++cur)</span><br><span class="line">                data_allocator::<span class="built_in">deallocate</span>(*cur, <span class="built_in">buffer_size</span>());</span><br><span class="line">            start = new_start;    <span class="comment">// 設定 deque 的新起點</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 如果清除區間後方的元素比較少</span></span><br><span class="line">            <span class="built_in">copy</span>(last, finish, first);            <span class="comment">// 向前搬移後方元素（覆蓋清除區間）</span></span><br><span class="line">            iterator new_finish = finish - n;    <span class="comment">// 標記 deque 的新尾點</span></span><br><span class="line">            <span class="built_in">destroy</span>(new_finish, finish);        <span class="comment">// 搬移完畢，將贅餘的元素解構</span></span><br><span class="line"><span class="comment">// 以下將贅餘的緩衝區釋放</span></span><br><span class="line">            <span class="keyword">for</span> (map_pointer cur = new_finish.node + <span class="number">1</span>; cur &lt;= finish.node; ++cur)</span><br><span class="line">                data_allocator::<span class="built_in">deallocate</span>(*cur, <span class="built_in">buffer_size</span>());</span><br><span class="line">            finish = new_finish;    <span class="comment">// 設定 deque 的新尾點</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start + elems_before;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h5><p>insert()功能：在某一点之前插入一个元素，并设定其值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在position 處安插一個元素，其值為 x</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="type">const</span> value_type &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position.cur == start.cur) &#123;    <span class="comment">// 如果安插點是deque 最前端</span></span><br><span class="line">        <span class="built_in">push_front</span>(x);                <span class="comment">// 交給push_front 去做</span></span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur) &#123; <span class="comment">// 如果安插點是deque 最尾端</span></span><br><span class="line">        <span class="built_in">push_back</span>(x);                      <span class="comment">// 交給push_back 去做</span></span><br><span class="line">        iterator tmp = finish;</span><br><span class="line">        --tmp;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">insert_aux</span>(position, x);        <span class="comment">// 交給 insert_aux 去做</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>, <span class="type">size_t</span> BufSize&gt;</span><br><span class="line"><span class="keyword">typename</span> deque&lt;T, Alloc, BufSize&gt;::iterator</span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert_aux</span>(iterator pos, <span class="type">const</span> value_type &amp;x) &#123;</span><br><span class="line">    difference_type index = pos - start;    <span class="comment">// 安插點之前的元素個數</span></span><br><span class="line">    value_type x_copy = x;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="built_in">size</span>() / <span class="number">2</span>) &#123;            <span class="comment">// 如果安插點之前的元素個數比較少</span></span><br><span class="line">        <span class="built_in">push_front</span>(<span class="built_in">front</span>());            <span class="comment">// 在最前端加入與第一元素同值的元素。</span></span><br><span class="line">        iterator front1 = start;        <span class="comment">// 以下標示記號，然後進行元素搬移...</span></span><br><span class="line">        ++front1;</span><br><span class="line">        iterator front2 = front1;</span><br><span class="line">        ++front2;</span><br><span class="line">        pos = start + index;</span><br><span class="line">        iterator pos1 = pos;</span><br><span class="line">        ++pos1;</span><br><span class="line">        <span class="built_in">copy</span>(front2, pos1, front1);        <span class="comment">// 元素搬移</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                        <span class="comment">// 安插點之後的元素個數比較少</span></span><br><span class="line">        <span class="built_in">push_back</span>(<span class="built_in">back</span>());            <span class="comment">// 在最尾端加入與最後元素同值的元素。</span></span><br><span class="line">        iterator back1 = finish;    <span class="comment">// 以下標示記號，然後進行元素搬移...</span></span><br><span class="line">        --back1;</span><br><span class="line">        iterator back2 = back1;</span><br><span class="line">        --back2;</span><br><span class="line">        pos = start + index;</span><br><span class="line">        <span class="built_in">copy_backward</span>(pos, back2, back1);    <span class="comment">// 元素搬移</span></span><br><span class="line">    &#125;</span><br><span class="line">    *pos = x_copy;    <span class="comment">// 在安插點上設定新值</span></span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div><div class="article-licensing box"><div class="licensing-title"><p>STL - deque源码分析</p><p><a href="https://xinlong-chen.github.io/2023/03/05/stl-deque/">https://xinlong-chen.github.io/2023/03/05/stl-deque/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Xinlong-Chen</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-03-05</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-08-27</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="" rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/stl/">stl</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2023/03/05/stl-array/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">STL - array源码分析</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/03/05/stl-priority-queue/"><span class="level-item">STL - 番外2 优先队列默认是大根堆？</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><script src="https://utteranc.es/client.js" repo="Xinlong-Chen/Xinlong-Chen.github.io" issue-term="pathname" label="some-issue-label" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar2.png" alt="Xinlong Chen"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Xinlong Chen</p><p class="is-size-6 is-block">os | db</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Canton</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">98</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Xinlong-Chen" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Xinlong-Chen"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#deque概述"><span class="level-left"><span class="level-item">1</span><span class="level-item">deque概述</span></span></a></li><li><a class="level is-mobile" href="#deque的中控器"><span class="level-left"><span class="level-item">2</span><span class="level-item">deque的中控器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#底层内存分布"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">底层内存分布</span></span></a></li><li><a class="level is-mobile" href="#中控器"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">中控器</span></span></a></li></ul></li><li><a class="level is-mobile" href="#deque的迭代器"><span class="level-left"><span class="level-item">3</span><span class="level-item">deque的迭代器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#迭代器结构"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">迭代器结构</span></span></a></li><li><a class="level is-mobile" href="#迭代器操作"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">迭代器操作</span></span></a></li></ul></li><li><a class="level is-mobile" href="#deque的数据结构"><span class="level-left"><span class="level-item">4</span><span class="level-item">deque的数据结构</span></span></a></li><li><a class="level is-mobile" href="#deque的构造与内存管理"><span class="level-left"><span class="level-item">5</span><span class="level-item">deque的构造与内存管理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#deque的ctor"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">deque的ctor</span></span></a></li><li><a class="level is-mobile" href="#push-back-amp-push-front"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">push_back() &amp; push_front()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#deque的元素操作"><span class="level-left"><span class="level-item">6</span><span class="level-item">deque的元素操作</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#pop-back-amp-pop-front"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">pop_back() &amp; pop_front()</span></span></a></li><li><a class="level is-mobile" href="#clear"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">clear()</span></span></a></li><li><a class="level is-mobile" href="#erase"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">erase()</span></span></a></li><li><a class="level is-mobile" href="#insert"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">insert()</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://www.cnblogs.com/cxl-" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">cnblog</span></span><span class="level-right"><span class="level-item tag">www.cnblogs.com</span></span></a></li><li><a class="level is-mobile" href="https://blog.csdn.net/hrbust_cxl" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">csdn</span></span><span class="level-right"><span class="level-item tag">blog.csdn.net</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">23</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">分布式系统</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">前端</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"><span class="level-start"><span class="level-item">工具使用</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">40</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">数据库系统</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"><span class="level-start"><span class="level-item">杂七杂八</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%A1%AC%E4%BB%B6/"><span class="level-start"><span class="level-item">硬件</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-28T09:15:52.000Z">2023-08-28</time></p><p class="title"><a href="/2023/08/28/mysql-B-Tree/">MySQL - B+树索引</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/">数据库系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-28T07:28:52.000Z">2023-08-28</time></p><p class="title"><a href="/2023/08/28/mysql-index-page/">MySQL - InnoDB 数据页结构</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/">数据库系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-28T01:55:52.000Z">2023-08-28</time></p><p class="title"><a href="/2023/08/28/mysql-record-struct/">MySQL - InnoDB 行格式</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/">数据库系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-27T14:55:52.000Z">2023-08-27</time></p><p class="title"><a href="/2023/08/27/mysql-log-system/">MySQL - 日志系统</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/">数据库系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-26T13:00:52.000Z">2023-08-26</time></p><p class="title"><a href="/2023/08/26/mysql-architecture/">MySQL - 基础架构</a></p><p class="categories"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/">数据库系统</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">69</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">25</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/"><span class="level-start"><span class="level-item">2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/algorithm/"><span class="tag">algorithm</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cmu15445/"><span class="tag">cmu15445</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cpp/"><span class="tag">cpp</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/debug/"><span class="tag">debug</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/effective-C/"><span class="tag">effective C++</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hitos/"><span class="tag">hitos</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux0-11/"><span class="tag">linux0.11</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux%E4%BD%BF%E7%94%A8/"><span class="tag">linux使用</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux%E7%BC%96%E7%A8%8B/"><span class="tag">linux编程</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/missing-semester/"><span class="tag">missing semester</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mit6-824/"><span class="tag">mit6.824</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mit6-s081/"><span class="tag">mit6.s081</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ostep/"><span class="tag">ostep</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qt/"><span class="tag">qt</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/stl/"><span class="tag">stl</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xv6/"><span class="tag">xv6</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"><span class="tag">分布式系统</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/"><span class="tag">操作系统理论</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"><span class="tag">树莓派</span><span class="tag">2</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar3.png" alt="Xinlong-Chen&#039;s blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Xinlong-Chen</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>